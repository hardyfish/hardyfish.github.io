<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		网络基础 | 
	 
	月伴飞鱼
	</title>
	
	<!-- keywords,description -->
	 

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/%E5%A4%B4%E5%83%8F.jpg">
	
  
  	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="/css/jquery.fancybox.min.css">

	
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="/lib/highlight/darcula.css">

	
<link rel="stylesheet" href="/css/clipboard-use.css">


	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">

	
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>


	
<script src="/lib/highlight/highlight.min.js"></script>

	
<script src="https://readmore.openwrite.cn/js/readmore.js"></script>

	
<script src="/lib/jquery-3.4.1.min.js"></script>

	
<script src="/lib/jquery.pjax.js"></script>


	
<script src="/js/main.js"></script>

	
<script src="/js/jquery.fancybox.min.js"></script>

	
		
<script src="/lib/valine/av-3.0.4-min.js"></script>

		
<script src="/lib/valine/Valine-1.3.10-min.js"></script>

	
	
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
	
<script src="/js/clipboard.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
	<header id="header">
    <a id="title" href="/" class="logo">公众号月伴飞鱼</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">关于我</a>
		</li>

		<li class="menu-item">
			<a href="/个人公众号.jpg" class="menu-item-link" target="_blank">我的公众号</a>
		</li>
		
		<li class="menu-item">
			<a href="https://tech.meituan.com/" class="menu-item-link" target="_blank">
				美团技术团队
			</a>
		</li>
		<li class="menu-item">
			<a href="https://tech.youzan.com/" class="menu-item-link" target="_blank">
				有赞技术团队
			</a>
		</li>
		<!--<li class="menu-item">
			<select class="menu-item-link menu-item-select">
				<option class="menu-item-link"  value="volvo">Volvo</option>
				<option class="menu-item-link"  value="saab">Saab</option>
				<option class="menu-item-link"  value="fiat">Fiat</option>
				<option class="menu-item-link"  value="audi">Audi</option>
			</select>
		</li>-->
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="text" placeholder="按目录搜索一下">
		<div id="tree">
			

			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										中间件
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/12/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/Elasticsearch/">
										Elasticsearch
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										前端相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/CSS/">
										CSS
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/Vue/">
										Vue
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										基础知识
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/11/27/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM/">
										JVM
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/11/21/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E5%9F%BA%E7%A1%80/">
										Java基础
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F/">
										分布式
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/12/10/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">
										并发编程
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
										设计模式
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										工具相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/">
										实用工具
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/07/28/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/">
										常用代码
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">
										开发工具
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										数据库
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/12/02/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">
										MySQL
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										服务器
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E6%9C%8D%E5%8A%A1%E5%99%A8/Docker/">
										Docker
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/09/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/">
										Nginx
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/09/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E8%BF%90%E7%BB%B4%E7%9F%A5%E8%AF%86/">
										运维知识
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										框架相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/08/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/MyBatis/">
										MyBatis
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/01/17/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/Thrift/">
										Thrift
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										消息队列
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/KAFKA/">
										KAFKA
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/">
										RocketMQ
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										生活相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/09/%E7%94%9F%E6%B4%BB%E7%9B%B8%E5%85%B3/%E9%9F%B3%E4%B9%90/">
										音乐
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										算法相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/11/26/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/LeetCode/">
										LeetCode
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/11/26/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E5%89%91%E6%8C%87OFFER/">
										剑指OFFER
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/11/25/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/">
										面试算法
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										英语相关
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										老友记
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/08/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E8%80%81%E5%8F%8B%E8%AE%B0/%E7%AC%AC%E4%B8%80%E5%AD%A3/">
										第一季
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/08/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E8%80%81%E5%8F%8B%E8%AE%B0/%E7%AC%AC%E4%B8%89%E5%AD%A3/">
										第三季
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										计算机基础
									</a>
									
							<ul>
								<li class="file active">
									<a href="/2022/12/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">
										网络基础
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">

	网络基础
</h1>
<div class="article-meta">
	<span>月伴飞鱼</span>
	<span>2022-12-19 17:51:44</span>
    
		<div id="article-categories">
            
                
                    <span>
                        <i class="fa fa-folder" aria-hidden="true"></i>
                        <a href="/categories/计算机基础/">计算机基础</a>
						
                    </span>
                
            
		</div>
    
</div>

<div id="container" class = "content999">
	<div id="article-content">
		<h1 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h1><p><strong>OSI七层模型</strong></p>
<p>物理层：</p>
<blockquote>
<p>解决两个硬件之间怎么通信的问题，常见的物理媒介有光纤、电缆、中继器等。它主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。</p>
<p>它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。</p>
</blockquote>
<blockquote>
<p>我们当时去学校配电脑的地方买网线，卖网线的师傅都会问，你的网线是要电脑连电脑啊，还是电脑连网口啊？</p>
<p>我们要的是电脑连电脑。这种方式就是一根网线，有两个头。一头插在一台电脑的网卡上，另一头插在另一台电脑的网卡上。但是在当时，普通的网线这样是通不了的，所以水晶头要做交叉线，用的就是所谓的<strong>1－3</strong>、<strong>2－6交叉接法</strong>。</p>
<p>水晶头的第1、2和第3、6脚，它们分别起着收、发信号的作用。将一端的1号和3号线、2号和6号线互换一下位置，就能够在物理层实现一端发送的信号，另一端能收到。</p>
<p>当然电脑连电脑，除了网线要交叉，还需要配置这两台电脑的IP地址、子网掩码和默认网关。要想两台电脑能够通信，这三项必须配置成为一个网络，可以一个是192.168.0.1&#x2F;24，另一个是192.168.0.2&#x2F;24，否则是不通的。</p>
<p>这里我想问你一个问题，两台电脑之间的网络包，包含MAC层吗？当然包含，要完整。IP层要封装了MAC层才能将包放入物理层。</p>
<p>到此为止，两台电脑已经构成了一个最小的<strong>局域网</strong>，也即<strong>LAN。</strong>可以玩联机局域网游戏啦！</p>
<p>等到第三个哥们也买了一台电脑，怎么把三台电脑连在一起呢？</p>
<p>先别说交换机，当时交换机也贵。有一个叫做<strong>Hub</strong>的东西，也就是<strong>集线器</strong>。这种设备有多个口，可以将宿舍里的多台电脑连接起来。但是，和交换机不同，集线器没有大脑，它完全在物理层工作。它会将自己收到的每一个字节，都复制到其他端口上去。这是第一层物理层联通的方案。</p>
</blockquote>
<p>数据链路层：</p>
<blockquote>
<p>在计算机网络中由于各种干扰的存在，物理链路是不可靠的。该层的主要功能就是：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。</p>
<p>它的具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层的数据叫做帧。</p>
</blockquote>
<p>网络层：</p>
<blockquote>
<p>计算机网络中如果有多台计算机，怎么找到要发的那台？如果中间有多个节点，怎么选择路径？这就是路由要做的事。</p>
<p>该层的主要任务就是：通过路由选择算法，为报文（该层的数据单位，由上一层数据打包而来）通过通信子网选择最适当的路径。这一层定义的是IP地址，通过IP地址寻址，所以产生了IP协议。</p>
</blockquote>
<p>传输层：</p>
<blockquote>
<p>当发送大量数据时，很可能会出现丢包的情况，另一台电脑要告诉是否完整接收到全部的包。如果缺了，就告诉丢了哪些包，然后再发一次，直至全部接收为止。</p>
<p>简单来说，传输层的主要功能就是：监控数据传输服务的质量，保证报文的正确传输。</p>
</blockquote>
<p>会话层：</p>
<blockquote>
<p>虽然已经可以实现给正确的计算机，发送正确的封装过后的信息了。但我们总不可能每次都要调用传输层协议去打包，然后再调用IP协议去找路由，所以我们要建立一个自动收发包，自动寻址的功能。</p>
<p>于是会话层出现了：它的作用就是建立和管理应用程序之间的通信。</p>
</blockquote>
<p>表示层：</p>
<blockquote>
<p>表示层负责数据格式的转换，将应用处理的信息转换为适合网络传输的格式，或者将来自下一层的数据转换为上层能处理的格式。</p>
</blockquote>
<p>应用层：</p>
<blockquote>
<p>应用层是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。前端同学对应用层肯定是最熟悉的。</p>
</blockquote>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p><strong>请求报文和响应报文组成</strong></p>
<p>HTTP请求报文由3部分组成： <strong>请求行</strong> + <strong>请求头</strong> + <strong>请求体</strong> </p>
<p><strong>请求的报文结构</strong></p>
<blockquote>
<p><strong>请求行：</strong></p>
<ul>
<li><p>请求方法，GET和POST是最常见的HTTP方法，除此以外还包括DELETE、HEAD、OPTIONS、PUT、TRACE。</p>
</li>
<li><p>请求对应的URL地址，它和报文头的Host属性组成完整的请求URL。</p>
</li>
<li><p>协议名称及版本号。</p>
</li>
</ul>
<p><strong>请求头：</strong></p>
<ul>
<li><p>是HTTP的报文头，报文头包含若干个属性，格式为 属性名:属性值，服务端据此获取客户端的信息。</p>
</li>
<li><p>与缓存相关的规则信息，均包含在header中</p>
</li>
</ul>
<p><strong>请求体：</strong></p>
<ul>
<li><p>是报文体，它将一个页面表单中的组件值通过param1&#x3D;value1&amp;param2&#x3D;value2的键值对形式编码成一个格式化串，它承载多个请求参数的数据。</p>
</li>
<li><p>不但报文体可以传递请求参数，请求URL也可以通过类似于“&#x2F;chapter15&#x2F;user.html? param1&#x3D;value1&amp;param2&#x3D;value2”的方式传递请求参数。</p>
</li>
</ul>
</blockquote>
<p><strong>响应报文结构</strong></p>
<p>HTTP的响应报文也由三部分组成：响应行 + 响应头 + 响应体</p>
<p><strong>状态码</strong></p>
<p>状态码由三位数字组成，第一个数定义了响应的类别，有五种可能取值</p>
<blockquote>
<p>+1xx：指示信息—-表示请求已接收，继续处理</p>
<p>+2xx：成功—-表示请求已被成功接收、理解</p>
<p>+3xx：重定向—-信息不够完整需要进一步补充</p>
<p>+4xx：客户端错误—-请求有语法错误或者请求无法实现</p>
<p>+5xx：服务器端错误—-服务器未能实现合法的请求</p>
</blockquote>
<blockquote>
<p>301 永久重定向，在location响应首部的值为当前的url（隐式）</p>
<p>302 临时重定向，在location响应首部的值为新的url（显式）</p>
</blockquote>
<p><strong>GET和POST的区别</strong></p>
<blockquote>
<p>GET请求参数是通过URL进行传递的，POST请求的参数包含在请求体当中。</p>
<p>GET请求比POST请求更不安全，因为参数直接暴露在URL中，所以，GET请求不能用来传递敏感信息。</p>
<p>GET请求在url中传递的参数是有长度限制的(在HTTP协议中并没有对URL的长度进行限制，限制是特定的浏览器以及服务器对他的限制，不同浏览器限制的长度不同。)，POST对长度没有限制。</p>
<p>GET请求参数会完整的保留在浏览器的历史记录中，POST请求的参数不会保留。</p>
<p>GET请求进行url编码(百分号编码)，POST请求支持多种编码方式。</p>
<p>GET请求产生的URL地址是可以被bookmark(添加书签)的，POST请求不可以。</p>
<p>GET请求在浏览器回退的时候是无害的，POST请求会.再次提交数据。</p>
<p>GET请求在浏览器中可以被主动cache(缓存)，而POST请求不会,可以手动设置。</p>
<p>GET产生一个TCP数据包。</p>
<p>POST产生两个TCP数据包。</p>
<p>对于GET请求，浏览器会把http header和data一起发送出去，服务器响应200，请求成功。</p>
<p>对于POST请求，浏览器先发送header，服务器会响应100（已经收到请求的第一部分，正在等待其余部分），浏览器再次发送data，服务器返回200，请求成功。</p>
</blockquote>
<h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h2><blockquote>
<p>HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理</p>
<p>HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。</p>
<p>HTTP 1.1则支持持久连接Persistent Connection, 并且默认使用persistent connection. 在同一个tcp的连接中可以传送多个HTTP请求和响应. 多个请求和响应可以重叠，多个请求和响应可以同时进行. 更加多的请求头和响应头(比如HTTP1.0没有host的字段).</p>
<p> HTTP 1.1的持续连接，也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接。</p>
</blockquote>
<p>HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。</p>
<blockquote>
<p>请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。</p>
<p>例如：一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。 HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容。</p>
</blockquote>
<p><strong>增加Host字段</strong></p>
<blockquote>
<p>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。</p>
<p>HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。此外，服务器应该接受以绝对路径标记的资源请求。</p>
</blockquote>
<p><strong>100(Continue)Status</strong></p>
<blockquote>
<p>HTTP&#x2F;1.1加入了一个新的状态码100（Continue）。客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码401（Unauthorized）；如果服务器接收此请求就回送响应码100，客户端就可以继续发送带实体的完整请求了。</p>
<p>100 (Continue) 状态代码的使用，允许客户端在发request消息body之前先用request header试探一下server，看server要不要接收request body，再决定要不要发request body。</p>
</blockquote>
<p><strong>Chunked</strong></p>
<p>HTTP&#x2F;1.1中引入了Chunked transfer-coding来解决上面这个问题，发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。</p>
<p>这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。</p>
<blockquote>
<p>HTTP&#x2F;1.1在1.0的基础上加入了一些cache的新特性，当缓存对象的Age超过Expire时变为stale对象，cache不需要直接抛弃stale对象，而是与源服务器进行重新激活（revalidation）。</p>
</blockquote>
<h2 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h2><p>HTTP2.0和HTTP1.X相比的新特性</p>
<blockquote>
<ol>
<li><strong>新的二进制格式</strong>（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li>
<li><strong>多路复用</strong>（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</li>
<li><strong>header压缩</strong>，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，差量更新HTTP头部，只发送改变的，既避免了重复header的传输，又减小了需要传输的大小。</li>
<li><strong>服务端推送</strong>（server push），同SPDY一样，HTTP2.0也具有server push功能。</li>
</ol>
</blockquote>
<p><strong>HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？</strong></p>
<blockquote>
<ul>
<li>HTTP&#x2F;1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；</li>
<li>HTTP&#x2F;1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</li>
<li>HTTP&#x2F;2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；</li>
</ul>
</blockquote>
<h1 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h1><h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>不对称加密也会有同样的问题，如何将不对称加密的公钥给对方呢？一种是放在一个公网的地址上，让对方下载；另一种就是在建立连接的时候，传给对方。</p>
<p>这两种方法有相同的问题，那就是，作为一个普通网民，你怎么鉴别别人给你的公钥是对的。</p>
<p>会不会有人冒充外卖网站，发给你一个它的公钥。接下来，你和它所有的互通，看起来都是没有任何问题的。毕竟每个人都可以创建自己的公钥和私钥。</p>
<p>证书里面有什么呢？当然应该有<strong>公钥</strong>，这是最重要的；还有证书的<strong>所有者</strong>，就像户口本上有你的姓名和身份证号，说明这个户口本是你的；</p>
<p>另外还有证书的<strong>发布机构</strong>和证书的<strong>有效期</strong>，这个有点像身份证上的机构是哪个区公安局，有效期到多少年。</p>
<p>这个证书是怎么生成的呢？会不会有人假冒权威机构颁发证书呢？</p>
<p>证书请求可以通过这个命令生成。</p>
<pre><code class="vbnet">openssl req -key cliu8siteprivate.key -new -out cliu8sitecertificate.req
</code></pre>
<p>将这个请求发给权威机构，权威机构会给这个证书卡一个章，我们称为签名算法。</p>
<p>就像有假身份证、假户口本一样。生成证书需要发起一个证书请求，然后将这个请求发给一个权威机构去认证，这个权威机构我们称为<strong>CA</strong>（ <strong>Certificate Authority</strong>）。</p>
<p>签名算法大概是这样工作的：</p>
<blockquote>
<p>一般是对信息做一个Hash计算，得到一个Hash值，这个过程是不可逆的，也就是说无法通过Hash值得出原来的信息内容。</p>
<p>在把信息发送出去时，把这个Hash值加密后，作为一个签名和信息一起发出去。</p>
</blockquote>
<h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>SQL注入常见的Web安全问题之一，其形式主要是把SQL命令插入到Web表单提交或页面请求url的查询字符串，破坏原有SQL结构，最终达到欺骗服务器执行恶意的SQL命令。</p>
<blockquote>
<p>SQL注入的原理是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。</p>
<p>也就是说，在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作时，会拼接对应参数，同时也将一些sql注入攻击的sql拼接起来，导致会执行一些预期之外的操作。</p>
</blockquote>
<p>日常使用的登录接口：在登录界面包括用户名和密码输入框，以及提交按钮，输入用户名和密码，提交。</p>
<blockquote>
<p>登录时调用接口&#x2F;user&#x2F;login&#x2F; 加上参数username、password，首先连接数据库，然后后台对请求参数中携带的用户名、密码进行参数校验，即sql的查询过程。</p>
<p>假设正确的用户名和密码为ls和123456，输入正确的用户名和密码、提交，相当于调用了以下的SQL语句。</p>
<p>SELECT * FROM user WHERE username &#x3D; ‘ls’ AND password &#x3D; ‘123456’</p>
<p>sql中会将#及–以后的字符串当做注释处理，如果我们使用“’ or 1&#x3D;1 #”作为用户名参数，那么服务端构建的sql语句就如下：</p>
<p>select * from users where username&#x3D;’’ or 1&#x3D;1#’ and password&#x3D;’123456’</p>
<p>而#会忽略后面的语句，因此上面的sql也等价于：</p>
<p>select * from users where username&#x3D;’’ or 1&#x3D;1</p>
<p>而1&#x3D;1属于常等型条件，因此这个sql便成为了如下，查询出所有的登陆用户。</p>
<p>select * from users</p>
<p>其实上面的sql注入只是在参数层面做了些手脚，如果是引入了一些功能性的sql那就更危险了，比如上面的登陆接口，如果用户名使用这个”‘ or 1&#x3D;1;delete * from users;#”，那么在”;”之后相当于是另外一条新的sql，这个sql是删除全表，那后果可想而知</p>
</blockquote>
<p><strong>SQL注入的危害：</strong></p>
<p>如果网站存在 SQL 注入漏洞，相当于将数据库直接暴露在攻击者面前。攻击者利用 SQL 注入漏洞能实现包括但不限于以下攻击：</p>
<blockquote>
<p>跳过账户权限验证达到越权；</p>
<p>获取数据库关键信息从而进行脱库</p>
<p>在特别情况下还可以修改数据库内容或者插入内容到数据库，如果数据库权限分配存在问题，或者数据库本身存在缺陷，那么攻击者可以通过SQL注入漏洞直接获取webshell或者服务器系统权限。</p>
</blockquote>
<p><strong>如何有效防止SQL注入：</strong></p>
<blockquote>
<p>数据校验：对来自用户的数据（GET, POST, cookie 等）最好做到以下两种过滤校验(前后端最好能同时校验)：</p>
<p>检查输入的数据是否具有所期望的数据格式。这种在参数是数字的时候特别有效，如果攻击者选择在参数中插入内容的话则会被转换成 NaN 导致攻击失败。</p>
<p>使用数据库特定的敏感字符转义函数把用户提交上来的非数字数据进行转义。</p>
<p>特殊字符：–、#、等等</p>
<p>权限限制</p>
<p>严格限制Web应用的数据库的操作权限，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害。</p>
<p>日志处理：当数据库操作失败的时候，尽量不要将原始错误日志返回，比如类型错误、字段不匹配等，把代码里的 SQL 语句暴露出来，以防止攻击者利用这些错误信息进行 SQL 注入。<br>sql预编译(非ORM框架)</p>
<p>通过prepareStatementsql进行预编译，将绑定的参数传到mysql服务器，mysql服务器对参数进行编译，即填充到相应的占位符的过程中，做了转义操作。 我们常用的jdbc就有预编译功能，不仅提升性能，而且防止sql注入。</p>
<p>ORM框架处理 如myBatis</p>
</blockquote>
<p>MyBatis中并不是百分百的能防止SQL注入，比如#{xxx}这样格式的参数会直接参与SQL编译，从而不能避免注入攻击。但涉及到动态表名和列名时，只能使用${xxx}这样的参数格式。</p>
<p>所以，这样的参数需要我们在代码中手工进行处理来防止注入。</p>
<p>在编写MyBatis的映射语句时，尽量采用#{xxx}这样的格式。若不得不使用${xxx}这样的参数，要手工地做好过滤工作，来防止SQL注入攻击。</p>
<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>Cross-Site Scripting(跨站脚本攻击)，简称XSS，是一种代码注入攻击。</p>
<p>攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如Cookie、SessionID等，进而危害数据安全</p>
<p><strong>XSS的注入方法</strong></p>
<blockquote>
<p>简单来说，任何可以输入的地方都有可能引起XSS攻击，包括URL</p>
<p>在HTML内嵌的文本中，恶意内容以script标签形成注入</p>
<p>在内联的JavaScript中，拼接的数据突破了原本的限制（字符串，变量，方法名）等</p>
<p>在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签</p>
<p>在标签的 href、src 等属性中，包含 javascript: (伪协议)等可执行代码。</p>
<p>在 onload、onerror、onclick 等事件中，注入不受控制代码。</p>
<p>在 style 属性和标签中，包含类似 background-image:url(“javascript:…”); 的代码（新版本浏览器已经可以防范）。</p>
<p>在 style 属性和标签中，包含类似 expression(…) 的 CSS 表达式代码（新版本浏览器已经可以防范）。</p>
</blockquote>
<p><strong>防御XSS攻击的方法</strong></p>
<blockquote>
<p>httpOnly：在cookie中设置HttpOnly属性后，js脚本将无法读取到cookie信息</p>
<p>输入过滤：一般是用于对于输入格式的检查，例如：邮箱，电话号码，用户名，密码……等，按照规定的格式输入。不仅仅是前端负责，后端也要做相同的过滤检查。因为攻击者完全可以绕过正常的输入流程，直接利用相关接口向服务器发送设置。</p>
<p>转义HTML：如果拼接 HTML 是必要的，就需要对于引号，尖括号，斜杠进行转义,但这还不是很完善.想对 HTML 模板各处插入点进行充分的转义,就需要采用合适的转义库</p>
</blockquote>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>Cross-site request forgery(跨站请求伪造)，是一种挟持用户在当前已登陆的Web应用程序上执行非本意的操作的攻击方法。</p>
<blockquote>
<p>如:攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p>
</blockquote>
<p><strong>CSRF攻击流程</strong></p>
<p><strong>CSRF的特点</strong></p>
<blockquote>
<p>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。</p>
<p>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。</p>
<p>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是冒用。</p>
</blockquote>
<p>跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。</p>
<p><strong>防御CSRF的方法</strong></p>
<blockquote>
<p>验证码；强制用户必须与应用进行交互，才能完成最终请求。此种方式能很好的遏制 csrf，但是用户体验比较差。</p>
<p>Referer check；请求来源限制，此种方法成本最低，但是并不能保证 100% 有效，因为服务器并不是什么时候都能取到 Referer，而且低版本的浏览器存在伪造 Referer 的风险。</p>
<p>token；token 验证的 CSRF 防御机制是公认最合适的方案。若网站同时存在 XSS 漏洞的时候，这个方法也是空谈。</p>
</blockquote>
<p><strong>XSS与CSRF的区别</strong></p>
<blockquote>
<p>通常来说 CSRF 是由 XSS 实现的，CSRF 时常也被称为 XSRF（CSRF 实现的方式还可以是直接通过命令行发起请求等）。</p>
<p>本质上讲，XSS 是代码注入问题，CSRF 是 HTTP 问题。 XSS 是内容没有过滤导致浏览器将攻击者的输入当代码执行。</p>
<p>CSRF 则是因为浏览器在发送 HTTP 请求时候自动带上 cookie，而一般网站的 session 都存在 cookie里面(Token验证可以避免)。</p>
</blockquote>
<h2 id="DOS"><a href="#DOS" class="headerlink" title="DOS"></a>DOS</h2><p>DOS：中文名称是拒绝服务，一切能引起DOS行为的攻击都被称为DOS攻击。该攻击的效果是使得计算机或网络无法提供正常的服务。常见的DOS攻击有针对计算机网络带宽和连通性的攻击。 </p>
<p>DOS是单机于单机之间的攻击。</p>
<p><strong>DOS攻击的原理：</strong></p>
<blockquote>
<p> 首先攻击者向被攻击的服务器发送大量的虚假IP请求，被攻击者在收到请求后返回确认信息，等待攻击者进行确认，（此处需要拥有HTTP协议工作方式和TCP三次握手的基本知识）该过程需要TCP的三次握手，由于攻击者发送的请求信息是虚假的，所以服务器接收不到返回的确认信息，在一段时间内服务器会处与等待状态，而分配给这次请求的资源却被有被释放。</p>
<p>当被攻击者等待一定的时间后，会因连接超时而断开，这时攻击者在次发送新的虚假信息请求，这样最终服务器资源被耗尽，直到瘫痪。</p>
</blockquote>
<p><strong>DDOS：</strong></p>
<p>中文名称是分布式拒绝服务攻击。指的是攻击者控制多台主机同时向同一主机或网络发起DOS攻击。</p>
<blockquote>
<p>DoS攻击、DDoS攻击和DRDoS攻击相信大家已经早有耳闻了吧!DoS是Denial of Service的简写就是拒绝服务，而DDoS就是Distributed Denial of Service的简写就是分布式拒绝服务，而DRDoS就是Distributed Reflection Denial of Service的简写，这是分布反射式拒绝服务的意思。</p>
</blockquote>
<p><strong>DDOS究竟如何攻击?</strong></p>
<p>目前最流行也是最好用的攻击方法就是使用SYN-Flood进行攻击，SYN-Flood也就是SYN洪水攻击。</p>
<blockquote>
<p>SYN-Flood不会完成TCP三次握手的第三步，也就是不发送确认连接的信息给服务器。</p>
<p>这样，服务器无法完成第三次握手，但服务器不会立即放弃，服务器会不停的重试并等待一定的时间后放弃这个未完成的连接，这段时间叫做SYN timeout，这段时间大约30秒-2分钟左右。</p>
<p>若是一个用户在连接时出现问题导致服务器的一个线程等待1分钟并不是什么大不了的问题，但是若有人用特殊的软件大量模拟这种情况，那后果就可想而知了。</p>
<p>一个服务器若是处理这些大量的半连接信息而消耗大量的系统资源和网络带宽，这样服务器就不会再有空余去处理普通用户的正常请求(因为客户的正常请求比率很小)。</p>
<p>这样这个服务器就无法工作了，这种攻击就叫做:SYN-Flood攻击。</p>
</blockquote>
<p>到目前为止，进行DDoS攻击的防御还是比较困难的。</p>
<p>首先，这种攻击的特点是它利用了TCP&#x2F;IP协议的漏洞，除非你不用TCP&#x2F;IP，才有可能完全抵御住DDoS攻击。</p>
<p>不过这不等于我们就没有办法阻挡DDoS攻击，我们可以尽力来减少DDoS的攻击。</p>
<blockquote>
<p>确保服务器的系统文件是最新的版本，并及时更新系统补丁。</p>
<p>关闭不必要的服务。</p>
<p>限制同时打开的SYN半连接数目。</p>
<p>缩短SYN半连接的time out 时间。</p>
<p>正确设置防火墙</p>
<p>禁止对主机的非开放服务的访问</p>
<p>限制特定IP地址的访问</p>
<p>启用防火墙的防DDoS的属性</p>
<p>严格限制对外开放的服务器的向外访问</p>
<p>运行端口映射程序祸端口扫描程序，要认真检查特权端口和非特权端口。</p>
</blockquote>
<h1 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h1><p><strong>对称加密和非对称加密</strong></p>
<p>加密算法分 <strong>对称加密</strong> 和 <strong>非对称加密</strong>，其中对称加密算法的加密与解密 <strong>密钥相同</strong>，非对称加密算法的加密密钥与解密 <strong>密钥不同</strong>，此外，还有一类 <strong>不需要密钥</strong> 的 <strong>散列算法</strong>。</p>
<blockquote>
<p>常见的 <strong>对称加密</strong> 算法主要有 <code>DES</code>、<code>3DES</code>、<code>AES</code> 等，常见的 <strong>非对称算法</strong> 主要有 <code>RSA</code>、<code>DSA</code> 等，<strong>散列算法</strong> 主要有 <code>SHA-1</code>、<code>MD5</code> 等。</p>
</blockquote>
<h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p><strong>对称加密算法</strong> 是应用较早的加密算法，又称为 <strong>共享密钥加密算法</strong>。在 <strong>对称加密算法</strong> 中，使用的密钥只有一个，<strong>发送</strong> 和 <strong>接收</strong> 双方都使用这个密钥对数据进行 <strong>加密</strong> 和 <strong>解密</strong>。</p>
<p>这就要求加密和解密方事先都必须知道加密的密钥。</p>
<blockquote>
<ol>
<li>数据加密过程：在对称加密算法中，<strong>数据发送方</strong> 将 <strong>明文</strong> (原始数据) 和 <strong>加密密钥</strong> 一起经过特殊 <strong>加密处理</strong>，生成复杂的 <strong>加密密文</strong> 进行发送。</li>
<li>数据解密过程：<strong>数据接收方</strong> 收到密文后，若想读取原数据，则需要使用 <strong>加密使用的密钥</strong> 及相同算法的 <strong>逆算法</strong> 对加密的密文进行解密，才能使其恢复成 <strong>可读明文</strong>。</li>
</ol>
</blockquote>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p><strong>非对称加密算法</strong>，又称为 <strong>公开密钥加密算法</strong>。它需要两个密钥，一个称为 <strong>公开密钥</strong> (<code>public key</code>)，即 <strong>公钥</strong>，另一个称为 <strong>私有密钥</strong> (<code>private key</code>)，即 <strong>私钥</strong>。</p>
<p>因为 <strong>加密</strong> 和 <strong>解密</strong> 使用的是两个不同的密钥，所以这种算法称为 <strong>非对称加密算法</strong>。</p>
<ol>
<li>如果使用 <strong>公钥</strong> 对数据 <strong>进行加密</strong>，只有用对应的 <strong>私钥</strong> 才能 <strong>进行解密</strong>。</li>
<li>如果使用 <strong>私钥</strong> 对数据 <strong>进行加密</strong>，只有用对应的 <strong>公钥</strong> 才能 <strong>进行解密</strong>。</li>
</ol>
<blockquote>
<p><strong>例子</strong>：甲方生成 <strong>一对密钥</strong> 并将其中的一把作为 <strong>公钥</strong> 向其它人公开，得到该公钥的 <strong>乙方</strong> 使用该密钥对机密信息 <strong>进行加密</strong> 后再发送给甲方，甲方再使用自己保存的另一把 <strong>专用密钥</strong> (<strong>私钥</strong>)，对 <strong>加密</strong> 后的信息 <strong>进行解密</strong>。</p>
</blockquote>
<h1 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h1><p><strong>TCP和UDP区别？</strong></p>
<blockquote>
<p>UDP是无连接的传输层协议；</p>
<p>UDP使用尽最大努力交付，不保证可靠交付；</p>
<p>即不能保证数据在网络中是否丢失</p>
<p>UDP是面向报文传输的，对应用层传输过来的数据不会进行任何处理（不合并，不拆分，保留原报文的边界）；</p>
<p>UDP没有拥塞控制，因此即使网络出现拥塞也不会降低发送速率；</p>
<ul>
<li>适用于一些实时场景，如直播、视频会议等；</li>
</ul>
<p>UDP支持一对一，一对多，多对多的交互通信；</p>
<p>UDP的首部开销很小，总共只有8个字节；</p>
</blockquote>
<blockquote>
<p>TCP是面向连接的传输层协议。也就是说，在双方传输数据之前，必须先建立起连接，传输完数据后要结束连接；</p>
<ul>
<li><p>如三次握手就是建立连接的过程，四次挥手就是结束连接；</p>
</li>
<li><p>比如两个人打电话，通话前需要拨号建立连接，通话结束后要挂机释放连接；</p>
</li>
</ul>
<p>每一条TCP连接只能有两个端点，即点对点通信（一对一）；</p>
<p>TCP提供可靠的传输服务；通过TCP连接传送的数据，无差错、不丢失、不重复、按序到达；</p>
<p>TCP提供全双工的通信；</p>
<ul>
<li><p>TCP允许通信双方的应用进程在任何时候都可以发送数据；因为TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</p>
</li>
<li><p>简单来说，两个计算机在连接的时候，都可以同时地通过连接发送数据或接收数据</p>
</li>
</ul>
<p>TCP是面向字节流的协议；</p>
<ul>
<li>虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP不把它看成一块数据，而是把这些数据仅仅看成是一连串无结构的字节流。</li>
</ul>
</blockquote>
<p><strong>TCP和UDP各自适用的场景</strong></p>
<blockquote>
<p>当要求通信数据可靠时，选择TCP协议；</p>
<ul>
<li>例如文件传输，邮件传输，金融交易，可靠通信，消息队列等；</li>
</ul>
<p>当要求传输速度，不要求数据可靠时，选择UDP；</p>
<ul>
<li>适合多媒体信息分发的场景，如直播，视频，语音，实时信息（股票走势）等；</li>
</ul>
</blockquote>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p><strong>如何保证UDP协议可靠？</strong></p>
<p>基本的思想：模拟TPC的可靠机制来实现,保证四个无即可（无丢失、无失序、无错误、无重复）</p>
<p>可以从以下几点着手：</p>
<blockquote>
<p>加上序号</p>
<p>确认机制，超时重传</p>
<p>校验机制，出错重传</p>
</blockquote>
<p>我们都知道UDP是面向无连接，不可靠的传输方式，而TCP虽然是面向连接，可靠地连接，但是其过程太繁琐，效率太低，传输速度很慢，所以我们可以利用UDP进行底层传输数据，上层进行封装，来弥补UDP的不足。</p>
<p>做到以下4点，就可以保证UDP协议可靠：</p>
<blockquote>
<p>不要TCP的三次握手和四次挥手。</p>
<p>发送方每次发出的数据进行编号，同时保持顺序的正确。</p>
<p>每次接收方接收到数据，发出应答信号。同时发送方在规定的时间检测是否接收到应答，如果没有接收到应答，重发，三次后还未收到应答直接判断发送失败。</p>
<p>发送数据时，发送方增加校验位。如果接收方校验出错，请求重发。</p>
</blockquote>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收数据。</p>
<p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<p><strong>如下图中：</strong></p>
<p>ack&#x3D;201代表期待收到的下一个字节的序号，rwnd&#x3D;300，代表当前的窗口为300，表示说接收方还可以接收300个字节的数据</p>
<p><strong>现在考虑一种特殊的情况：</strong></p>
<p>当接收方窗口大小为0时，发送方不能发送数据，在接收方把数据处理完之后，向接收方发送rwnd&#x3D;1000，通知发送方我还可以接收1000个字节的数据，但是这个字段在传输时丢失了，接收方并没有接收到这个数据，默认接收方当前窗口为0。这种情况该如何处理呢？</p>
<p>可以通过坚持定时器来解决这个问题</p>
<p><strong>坚持定时器</strong></p>
<blockquote>
<p>当接收到窗口为0的消息，则启动坚持定时器</p>
<p>坚持定时器会每隔一段时间发送一个窗口探测报文，来询问接收方当前的窗口大小。</p>
</blockquote>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>网络传输过程中，某段时间如果网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就会变坏，这种情况就叫做<strong>网络拥塞</strong></p>
<p>为解决这个问题，TCP中使用了四种拥塞控制算法</p>
<p><strong>慢开始</strong></p>
<p>发送方会维持一个拥塞窗口cwnd的状态变量，拥塞窗口的大小取决于拥塞程度，并且会在收发包过程中动态的进行变化。发送方会让本端的发送窗口等于拥塞窗口。</p>
<p><strong>慢开始的核心思想</strong>：指数级由小到大逐渐增加拥塞窗口大小，如果网络出现阻塞，拥塞窗口就减小。</p>
<p><strong>判断出现网络拥塞的依据</strong>：没有按时收到应当到达的确认报文（即发生重传）。</p>
<p>维护一个<strong>慢开始门限ssthresh</strong>状态变量：</p>
<blockquote>
<ol>
<li>当cwnd &lt; ssthresh 时，使用慢开始算法。</li>
<li>当cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</li>
<li>当cwnd &#x3D; ssthresh 时，既可以使用慢开始算法，也可以使用拥塞避免算法。</li>
</ol>
<p>假设发送方拥塞窗口cwnd的值为1，发送窗口swnd等于拥塞窗口cwnd，那么目前发送方只能发送一个报文段，cwnd为几就能发送几个报文段，接收方收到报文段后发送回复确认，发送方收到确认报文，会将拥塞窗口的值乘2，变为2。</p>
<p>发送方此时一次就能发送两个报文段，接收方收到报文段后返回两次确认报文段，发送方收到之后拥塞窗口再乘2，cwnd&#x3D;4。知道发送方发送16个报文段都按时收到确认报文，拥塞窗口变为32，但是这一次没有按时收到确认报文，即有报文需要重传，表示网络发生了拥塞，这时候设定ssthresh为当前窗口cwnd的一半，即ssthresh &#x3D; cwnd&#x2F;2 &#x3D; 16。重新开始慢开始。</p>
<p>再一次cwnd&#x3D;16的时候，开启拥塞避免算法。</p>
</blockquote>
<p><strong>拥塞避免算法</strong></p>
<p>拥塞避免算法是让拥塞窗口缓慢增长，每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，拥塞窗口按线性规律缓慢增长。</p>
<p>不论是在慢开始期间还是拥塞避免期间，只要判断网络发生了拥塞ssthresh就设置为当前发送窗口大小的一半，然后重新开始执行慢开始算法，这样做的目的是迅速减少主机发送到网络中的分组数，使发生拥塞的路由器有足够的时间把队列中积压的分组处理完毕。</p>
<p><strong>快速重传</strong></p>
<p>快速重传机制是什么呢？</p>
<blockquote>
<p>考虑下面这种情况，在数据传送过程中，网络有可能不太稳定，个别报文段在网络中丢失了，但是实际上网络并没有发生拥塞。</p>
<p>这样会导致发送方超时重传，误以为网络上发生了拥塞，由于有慢开始和拥塞避免机制，发送方错误的启动了慢开始算法，并且把拥塞窗口cwnd又设置为最小值1，因为降低了传输效率。</p>
</blockquote>
<p>为解决这个问题，快重传要求接收方在收到一个失序的报文段后立即发出重复确认，为的是让发送方知道有一个报文丢失了，快速重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方还没有接收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>
<p><strong>快恢复算法</strong></p>
<p>快恢复算法适合快重传算法配合使用的</p>
<blockquote>
<p>当发送方连续收到三个重复确认的时候，执行 乘法减小 算法，将ssthresh门限减半（为了预防网络发生拥塞），但是接下来不执行慢开始算法，因为如果网络发生拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。</p>
<p>此时不会执行慢开始算法，而是将拥塞窗口cwnd设置为ssthresh减半后的值，然后执行拥塞避免算法，让cwnd缓慢变大。</p>
</blockquote>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><strong>四次挥手的过程如下：</strong></p>
<p>第一次挥手：</p>
<blockquote>
<p>客户端向服务器发送一个 FIN 数据包（FIN &#x3D; 1，seq &#x3D; u）主动断开连接，报文中会指定一个序列号。</p>
<p>告诉服务器：我要跟你断开连接了，不会再给你发数据了；</p>
<p>客户端此时还是可以接收数据的，如果一直没有收到被动连接方的确认包，则可以重新发送这个包。</p>
<p>此时客户端处于 FIN_WAIT1 状态。</p>
</blockquote>
<p>第二次挥手：</p>
<blockquote>
<p>服务器收到 FIN 数据包之后，向客户端发送确认包（ACK &#x3D; 1,ack &#x3D; u + 1），把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了</p>
<p>这是服务器在告诉客户端：我知道你要断开了，但是我还有数据没有发送完，等发送完了所有的数据就进行第三次挥手</p>
<p>此时服务端处于 CLOSE_WAIT 状态，客户端处于 FIN_WAIT2 状态</p>
</blockquote>
<p>第三次挥手：</p>
<blockquote>
<p>服务器向客户端发送FIN 数据包（FIN&#x3D;1，seq &#x3D; w），且指定一个序列号，以及确认包（ACK &#x3D; 1， ack &#x3D; u + 1），用来停止向客户端发送数据</p>
<p>这个动作是告诉客户端：我的数据也发送完了，不再给你发数据了</p>
<p>此时服务端处于LAST_ACK状态，客户端处于TIME_WAIT状态</p>
</blockquote>
<p>第四次挥手：</p>
<blockquote>
<p>客户端收到 FIN数据包 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值</p>
<p>此时客户端处于 TIME_WAIT 状态。</p>
<p>需要过一了一定时间（2MSL）之后，客户端发送确认包（ACK &#x3D; 1， ack &#x3D; w + 1），此时客户端才会进入 CLOSED 状态，以确保发送方的ACK可以到达接收方，防止已失效连接请求报文段出现在此连接中。</p>
<p>至此，完成四次挥手。</p>
</blockquote>
<p><strong>等待计时器（TIME-WAIT）</strong></p>
<p>MSL（Max Segment Lifetime）：最长报文段寿命</p>
<p>等待计时器等待的时间为2MSL，MSL一般设置为2分钟。</p>
<p><strong>为什么需要等待2MSL？</strong></p>
<blockquote>
<p>1.确保发送方发送的第四次挥手ACK报文可以到达接收方；2.确保当前连接的所有报文都已经过期；</p>
<p>在四次挥手时，只要发送方发出了第四次挥手的报文之后，发送方就进入了等待状态，这时最后一个报文其实是并没有确认的，这个等待计时器主要是为了确保发送方发送的第四次挥手ACK报文可以到达接收方；</p>
<p>2MSL是报文在网络中最长可以存活的时间，在2MSL时间里，如果第四次挥手ACK报文没到达服务端，接收方会重新发送第三次挥手的报文给客户端，客户端收到之后，就知道之前第四次挥手的 ACK 报文丢失了，然后再次发送 ACK 报文。确保正确地结束这次连接</p>
<p>另外一个功能是为了确保当前连接的所有报文都已经过期，防止已失效的连接请求报文段出现在本连接中</p>
<p>因为最后一个报文都已经等待了2MSL时间，所以对于其他报文，肯定也超过2MSL的时间，都是过期的报文</p>
</blockquote>

	</div>
</div>


    <div class="post-guide">
        <div class="item left">
            
              <a href="/2022/12/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/Elasticsearch/">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  Elasticsearch
              </a>
            
        </div>
        <div class="item right">
            
              <a href="/2022/12/10/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">
                并发编程
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>




<script>

    //document.oncontextmenu=new Function("event.returnValue=false");
	//document.onselectstart=new Function("event.returnValue=false");

	

	$(function () {
		const btw = new BTWPlugin();
	    btw.init({
	        id: 'container',
	        blogId: '22377-1657723090751-870',
	        name: '月伴飞鱼',
	        qrcode: '/个人公众号.jpg',
	        keyword: '验证码',
	    });

	    var contents = document.getElementsByClassName("content999");
	    //监听文章内容的copy事件
	    contents[0].addEventListener('copy',function(e){
	        setClipboardText(e);
	    });

	    function setClipboardText(event){
	        // clipboardData 对象是为通过编辑菜单、快捷菜单和快捷键执行的编辑操作所保留的，也就是你复制或者剪切内容
	        let clipboardData = event.clipboardData || window.clipboardData;

	        // 如果未复制或者未剪切，则return出去
	        if (!clipboardData) { return; }

	        event.preventDefault();

	        // Selection 对象，表示用户选择的文本范围或光标的当前位置。
	        // 声明一个变量接收 -- 用户输入的剪切或者复制的文本转化为字符串
	        let text = window.getSelection().toString();
	    
	        if (text) {
	            // 如果文本存在则先取消文本默认事件
	            event.preventDefault();
	            // 通过调用常clipboardData对象的 setData(format, data) 方法；来设置相关文本
	            // format: 一个DOMString 表示要添加到 drag object的拖动数据的类型。
	            // data: 一个 DOMString表示要添加到 drag object的数据。
	            var copyright = '\n\n'
	            + '\n著作权归作者所有。'
	            + '\n商业转载请联系作者获得授权，非商业转载请注明出处。'
	            + '\n作者: 月伴飞鱼'
	            + '\n原文地址: https://xiaoflyfish.cn/2022/12/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/'
	    
	            clipboardData.setData('text/plain', text + copyright);
	    
	        }
	    };
	});

	
</script>

<script>
    const btw = new BTWPlugin();
    btw.init({
        id: 'container',
        blogId: '22377-1657723090751-870',
        name: '月伴飞鱼',
        qrcode: '/个人公众号.jpg',
        keyword: '验证码',
    });
</script>
	</div>
	<div id="footer">
	<p>
	©2019-<span id="footerYear"></span> 
	<a href="/">月伴飞鱼</a> 
	
	
		|
		<span id="busuanzi_container_site_pv">
			PV 180986
		</span>
		|
		<span id="busuanzi_container_site_uv"> 
			UV 10079
		</span>
	
	<br>
	微信搜索 <a href="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/个人公众号.jpg" target="_blank">月伴飞鱼</a> 关注我
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>
	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>