<!DOCTYPE html>
<html lang="en" oncontextmenu="return false;">

<head oncontextmenu="return false;">
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta name="baidu-site-verification" content="codeva-QodU0Nk5F7" />
	<meta name="google-site-verification" content="DbSTw8OJwtH5Qei7n8Jnew0YyQ5naPzdLAPiscu7zQE" />
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">

	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "https://hm.baidu.com/hm.js?7eeb54583579fabc0878be210d6ad60a";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>

	
	<!-- title -->
	
	<title>
	
		并发编程 | 
	 
	月伴飞鱼
	</title>
	
	<!-- keywords,description -->
	 

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/%E5%A4%B4%E5%83%8F.jpg">
	
  
  	
<link rel="stylesheet" href="/css/main.css">

  	
<link rel="stylesheet" href="/css/reward.css">

	
<link rel="stylesheet" href="/css/jquery.fancybox.min.css">

	
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="/lib/highlight/darcula.css">

	
<link rel="stylesheet" href="/css/clipboard-use.css">


	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">


	
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>


	
<script src="/lib/highlight/highlight.min.js"></script>


	
<script src="https://readmore.openwrite.cn/js/readmore-2.0.js"></script>

	
<script src="/lib/jquery-3.4.1.min.js"></script>

	
<script src="/lib/jquery.pjax.js"></script>


	
<script src="/js/main.js"></script>

	
<script src="/js/jquery.fancybox.min.js"></script>

	
		
<script src="/lib/valine/av-3.0.4-min.js"></script>

		
<script src="/lib/valine/Valine-1.3.10-min.js"></script>

	
	
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
	
<script src="/js/clipboard.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body oncontextmenu="return false;">
	<header id="header" oncontextmenu="return false;">
    <a id="title" href="/" class="logo">公众号月伴飞鱼</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">关于我</a>
		</li>

		<li class="menu-item">
			<a href="/个人微信.jpeg" class="menu-item-link">联系作者</a>
		</li>

	    <li class="menu-item">
			<a href="/site" class="menu-item-link">关于网站</a>
		</li>

		<li class="menu-item">
			<a href="/个人公众号.jpg" class="menu-item-link" target="_blank">我的公众号</a>
		</li>
		
		<li class="menu-item">
			<a href="https://tech.meituan.com/" class="menu-item-link" target="_blank">
				美团技术团队
			</a>
		</li>
		<li class="menu-item">
			<a href="https://tech.youzan.com/" class="menu-item-link" target="_blank">
				有赞技术团队
			</a>
		</li>
		<!--<li class="menu-item">
			<select class="menu-item-link menu-item-select">
				<option class="menu-item-link"  value="volvo">Volvo</option>
				<option class="menu-item-link"  value="saab">Saab</option>
				<option class="menu-item-link"  value="fiat">Fiat</option>
				<option class="menu-item-link"  value="audi">Audi</option>
			</select>
		</li>-->
	</ul>
</header>

	<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="text" placeholder="按目录搜索一下">
		<div id="tree">
			

			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										AI相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2024/01/14/AI%E7%9B%B8%E5%85%B3/AIGC/">
										AIGC
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/03/07/AI%E7%9B%B8%E5%85%B3/Sora/">
										Sora
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/03/01/AI%E7%9B%B8%E5%85%B3/%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%B7%A5%E7%A8%8B/">
										提示词工程
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										中间件
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/30/%E4%B8%AD%E9%97%B4%E4%BB%B6/Dubbo/">
										Dubbo
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/12/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/Elasticsearch/">
										Elasticsearch
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/30/%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty/">
										Netty
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/12/25/%E4%B8%AD%E9%97%B4%E4%BB%B6/Solr/">
										Solr
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/ZooKeeper/">
										ZooKeeper
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										产品相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2024/02/18/%E4%BA%A7%E5%93%81%E7%9B%B8%E5%85%B3/%E5%B9%BF%E5%91%8A%E4%B8%9A%E5%8A%A1/">
										广告业务
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/18/%E4%BA%A7%E5%93%81%E7%9B%B8%E5%85%B3/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/">
										推荐系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/06/%E4%BA%A7%E5%93%81%E7%9B%B8%E5%85%B3/%E7%94%A8%E6%88%B7%E5%A2%9E%E9%95%BF/">
										用户增长
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										代码思想
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/12/15/%E4%BB%A3%E7%A0%81%E6%80%9D%E6%83%B3/CodeReview/">
										CodeReview
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/02/%E4%BB%A3%E7%A0%81%E6%80%9D%E6%83%B3/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/">
										代码重构
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										前端相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/CSS/">
										CSS
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/26/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/React/">
										React
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/26/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/Vue/">
										Vue
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/12/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">
										小程序
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										基础知识
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/11/27/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM/">
										JVM
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F/">
										分布式
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file active">
									<a href="/2022/12/10/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">
										并发编程
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
										设计模式
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										大数据相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2024/02/21/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3/DataX/">
										DataX
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/25/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3/Doris/">
										Doris
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3/Flink/">
										Flink
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/21/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3/Hadoop/">
										Hadoop
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/07/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3/Hive/">
										Hive
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/23/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3/SQOOP/">
										SQOOP
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3/Spark/">
										Spark
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										学习专栏
									</a>
									
							<ul>
								<li class="file">
									<a href="/2024/02/16/%E5%AD%A6%E4%B9%A0%E4%B8%93%E6%A0%8F/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/">
										从0开始学架构
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/31/%E5%AD%A6%E4%B9%A0%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%91/">
										代码之丑
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/26/%E5%AD%A6%E4%B9%A0%E4%B8%93%E6%A0%8F/%E5%A4%A7%E5%8E%82%E6%99%8B%E5%8D%87%E6%8C%87%E5%8D%97/">
										大厂晋升指南
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/19/%E5%AD%A6%E4%B9%A0%E4%B8%93%E6%A0%8F/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E5%AD%A6%E4%B9%A0%E9%AB%98%E6%89%8B/">
										如何成为学习高手
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										学习书籍
									</a>
									
							<ul>
								<li class="file">
									<a href="/2024/02/05/%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D/HBase%E4%B8%8D%E7%9D%A1%E8%A7%89%E4%B9%A6/">
										HBase不睡觉书
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/02/%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/">
										Java并发编程实战
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/02/%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/">
										Java并发编程的艺术
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/16/%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/">
										Java开发手册
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/03/11/%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/">
										亿级流量网站架构核心技术
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/05/%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/">
										代码整洁之道
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/03/03/%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/">
										大型网站技术架构
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/07/%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F/">
										大型网站系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/06/%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/">
										深入理解Java虚拟机
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/08/%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D/%E8%8B%B1%E8%AF%AD%E9%AD%94%E6%B3%95%E5%B8%88%E4%B9%8B%E8%AF%AD%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8/">
										英语魔法师之语法俱乐部
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										工具相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/11/09/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Arthas/">
										Arthas
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/12/24/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/ChatGPT/">
										ChatGPT
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/21/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/GIT/">
										GIT
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/21/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Hexo/">
										Hexo
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/21/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/MAC/">
										MAC
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/01/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Maven/">
										Maven
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/09/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/PlantUML/">
										PlantUML
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/12/22/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/UTools/">
										UTools
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/">
										实用工具
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										成长相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/31/%E6%88%90%E9%95%BF%E7%9B%B8%E5%85%B3/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">
										技术学习
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/07/%E6%88%90%E9%95%BF%E7%9B%B8%E5%85%B3/%E8%AF%BB%E4%B9%A6%E8%AE%A1%E5%88%92/">
										读书计划
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/09/%E6%88%90%E9%95%BF%E7%9B%B8%E5%85%B3/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/">
										面试相关
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										数据库
									</a>
									
							<ul>
								<li class="file">
									<a href="/2024/02/06/%E6%95%B0%E6%8D%AE%E5%BA%93/ClickHouse/">
										ClickHouse
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/27/%E6%95%B0%E6%8D%AE%E5%BA%93/HBase/">
										HBase
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/09/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/">
										MongoDB
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/12/02/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">
										MySQL
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/">
										Redis
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										文章速读
									</a>
									
							<ul>
								<li class="file">
									<a href="/2024/03/14/%E6%96%87%E7%AB%A0%E9%80%9F%E8%AF%BB/%E4%BA%AC%E4%B8%9C/">
										京东
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/03/11/%E6%96%87%E7%AB%A0%E9%80%9F%E8%AF%BB/%E5%AD%97%E8%8A%82/">
										字节
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/03/13/%E6%96%87%E7%AB%A0%E9%80%9F%E8%AF%BB/%E7%BE%8E%E5%9B%A2/">
										美团
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/03/10/%E6%96%87%E7%AB%A0%E9%80%9F%E8%AF%BB/%E8%85%BE%E8%AE%AF/">
										腾讯
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/03/10/%E6%96%87%E7%AB%A0%E9%80%9F%E8%AF%BB/%E9%98%BF%E9%87%8C/">
										阿里
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										服务器
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E6%9C%8D%E5%8A%A1%E5%99%A8/Docker/">
										Docker
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/09/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/">
										Nginx
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/03/%E6%9C%8D%E5%8A%A1%E5%99%A8/Tomcat/">
										Tomcat
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/09/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E8%BF%90%E7%BB%B4%E7%9F%A5%E8%AF%86/">
										运维知识
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										架构相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/21/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/DDD/">
										DDD
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/02/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/%E6%9E%B6%E6%9E%84%E5%9B%BE/">
										架构图
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/02/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0/">
										架构学习
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/26/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/%E7%B3%BB%E7%BB%9F%E4%BF%9D%E9%9A%9C/">
										系统保障
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/31/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD/">
										系统性能
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/26/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">
										系统设计
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										框架相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2024/01/07/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/Caffeine/">
										Caffeine
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/06/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/Guava/">
										Guava
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/15/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/JWT/">
										JWT
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/08/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/MyBatis/">
										MyBatis
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/14/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/RPC%E6%A1%86%E6%9E%B6/">
										RPC框架
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/26/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/Seata/">
										Seata
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/03/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/ShardingSphere/">
										ShardingSphere
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/14/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/Spring/">
										Spring
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/03/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/Thrift/">
										Thrift
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/29/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/XXLJOB/">
										XXLJOB
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/10/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/">
										开源框架
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										消息队列
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/KAFKA/">
										KAFKA
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/12/20/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/">
										RabbitMQ
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/">
										RocketMQ
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										源码相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/12/13/%E6%BA%90%E7%A0%81%E7%9B%B8%E5%85%B3/RocketMQ/">
										RocketMQ
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										生活相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/27/%E7%94%9F%E6%B4%BB%E7%9B%B8%E5%85%B3/%E4%B9%A6%E7%B1%8D/">
										书籍
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/12/17/%E7%94%9F%E6%B4%BB%E7%9B%B8%E5%85%B3/%E5%81%9A%E8%8F%9C/">
										做菜
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/24/%E7%94%9F%E6%B4%BB%E7%9B%B8%E5%85%B3/%E6%B3%95%E5%BE%8B/">
										法律
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/10/%E7%94%9F%E6%B4%BB%E7%9B%B8%E5%85%B3/%E7%94%B5%E5%BD%B1/">
										电影
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/10/%E7%94%9F%E6%B4%BB%E7%9B%B8%E5%85%B3/%E7%94%B5%E8%A7%86%E5%89%A7/">
										电视剧
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/11/%E7%94%9F%E6%B4%BB%E7%9B%B8%E5%85%B3/%E7%BA%AA%E5%BD%95%E7%89%87/">
										纪录片
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/09/%E7%94%9F%E6%B4%BB%E7%9B%B8%E5%85%B3/%E9%9F%B3%E4%B9%90/">
										音乐
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										算法相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/11/26/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/LeetCode/">
										LeetCode
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/11/26/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E5%89%91%E6%8C%87OFFER/">
										剑指OFFER
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/11/25/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/">
										面试算法
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										编程语言
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/11/11/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go%E5%9F%BA%E7%A1%80/">
										Go基础
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/11/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java%E5%9F%BA%E7%A1%80/">
										Java基础
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/29/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python%E5%9F%BA%E7%A1%80/">
										Python基础
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										英语相关
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										摩登家庭
									</a>
									
							<ul>
								<li class="file">
									<a href="/2024/03/05/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E6%91%A9%E7%99%BB%E5%AE%B6%E5%BA%AD/%E7%AC%AC%E4%B8%80%E5%AD%A3/">
										第一季
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										老友记
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/08/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E8%80%81%E5%8F%8B%E8%AE%B0/%E7%AC%AC%E4%B8%80%E5%AD%A3/">
										第一季
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/08/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E8%80%81%E5%8F%8B%E8%AE%B0/%E7%AC%AC%E4%B8%89%E5%AD%A3/">
										第三季
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/23/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E8%80%81%E5%8F%8B%E8%AE%B0/%E7%AC%AC%E4%BA%94%E5%AD%A3/">
										第五季
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										雅思
									</a>
									
							<ul>
								<li class="file">
									<a href="/2024/01/25/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E9%9B%85%E6%80%9D/%E5%89%91%E6%A1%A5%E9%9B%85%E6%80%9D%E5%90%AC%E5%8A%9B%E7%9C%9F%E9%A2%9815/">
										剑桥雅思听力真题15
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/12/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E9%9B%85%E6%80%9D/%E5%89%91%E6%A1%A5%E9%9B%85%E6%80%9D%E5%90%AC%E5%8A%9B%E7%9C%9F%E9%A2%984/">
										剑桥雅思听力真题4
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/08/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E9%98%85%E8%AF%BB538%E8%80%83%E7%82%B9%E8%AF%8D/">
										雅思阅读538考点词
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										计算机基础
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
										操作系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
										数据结构
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/">
										算法知识
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/12/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">
										网络基础
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title" oncontextmenu="return false;">

	并发编程
</h1>
<div class="article-meta" oncontextmenu="return false;">
	<span>月伴飞鱼</span>
	<span>2022-12-10 16:36:40</span>
    
		<div id="article-categories">
            
                
                    <span>
                        <i class="fa fa-folder" aria-hidden="true"></i>
                        <a href="/categories/基础知识/">基础知识</a>
						
                    </span>
                
            
		</div>
    
</div>

<div id="container" class = "content999" oncontextmenu="return false;">
<!--打赏-->
        <div class="reward">
       <div class="reward-button">赏 <span class="reward-code">
        <span class="alipay-code"> <img class="alipay-img wdp-appear" src="/alipay.png"><b>支付宝打赏</b> </span> 
        <span class="wechat-code"> <img class="wechat-img wdp-appear" src="/weipay.jpeg"><b>微信打赏</b> </span> 
       </div>
      <p class="reward-notice">如果文章对你有帮助，欢迎点击上方按钮打赏作者！</p>
      </div>
      <!--打赏-->
	<div id="article-content">
		<h1>线程</h1>
<p><strong>线程优先级</strong></p>
<blockquote>
<p>线程的优先级：线程抢占 CPU 时间片的概率，优先级越高的线程优先执行的概率就越大，但并不能保证优先级高的线程一定先执行。</p>
</blockquote>
<pre><code class="language-java">// 线程可以拥有的最小优先级
public final static int MIN_PRIORITY = 1;

// 线程默认优先级
public final static int NORM_PRIORITY = 5;

// 线程可以拥有的最大优先级
public final static int MAX_PRIORITY = 10
</code></pre>
<p><strong>线程的常用方法</strong></p>
<p>join()：</p>
<blockquote>
<p>在一个线程中调用 <code>other.join()</code> ，这时候当前线程会让出执行权给 other 线程，直到 other 线程执行完或者过了超时时间之后再继续执行当前线程。</p>
</blockquote>
<p>yield()：</p>
<blockquote>
<p>给线程调度器一个当前线程愿意出让 CPU 使用权的暗示，但是线程调度器可能会忽略这个暗示。</p>
<ul>
<li>yield() 执行非常不稳定，线程调度器不一定会采纳 yield() 出让 CPU 使用权的建议。</li>
</ul>
</blockquote>
<p><strong>wait/notify和sleep方法的异同？</strong></p>
<blockquote>
<p>wait 方法必须在 synchronized 保护的代码中使用，而 sleep 方法并没有这个要求。</p>
<p>在同步代码中执行 sleep 方法时，并不会释放 monitor 锁，但执行 wait 方法时会主动释放 monitor 锁。</p>
<p>sleep 方法中会要求必须定义一个时间，时间到期后会主动恢复，而对于没有参数的 wait 方法而言，意味着永久等待，直到被中断或被唤醒才能恢复，它并不会主动恢复。</p>
<p>wait/notify 是 Object 类的方法，而 sleep 是 Thread 类的方法。</p>
</blockquote>
<p><strong>线程状态</strong></p>
<p>新建状态（New）:</p>
<blockquote>
<p>通过实现<code>Runnable</code>接口或继承<code>Thread</code>声明一个线程类，<code>new</code>一个实例后，线程就进入了新建状态。</p>
</blockquote>
<p>就绪状态（Ready）:</p>
<blockquote>
<p>线程创建成功后，调用该线程的<code>start()</code>函数，线程进入就绪状态，该状态的线程进入可运行线程池中，等待获取<code>CPU</code>的使用权。</p>
</blockquote>
<p>运行状态（Running)：</p>
<blockquote>
<p>从<strong>可运行线程池</strong>中选择一个线程，该线程进入运行状态。</p>
<ul>
<li>线程获取到了<code>CPU</code>时间片。</li>
<li>当线程时间片用完或调用的<code>yield()</code>函数，该线程回到就绪状态。</li>
</ul>
</blockquote>
<p>终止状态（Terminated）:</p>
<blockquote>
<p>线程执行结束或执行过程中因异常意外终止都会使线程进入终止状态。</p>
</blockquote>
<p>等待状态（Waiting）:</p>
<blockquote>
<p>运行状态的线程执行<code>wait()、join()、LockSupport.park()</code>任意函数，该线程进入等待状态。</p>
<ul>
<li>
<p>其中<code>wait()</code>与<code>join()</code>函数会让JVM把该线程放入锁等待队列。</p>
</li>
<li>
<p>处于这种状态的线程不会被分配CPU执行时间，它们要等待被<strong>主动唤醒</strong>，否则会一直处于等待状态。</p>
</li>
<li>
<p>执行<code>LockSupport.unpark(t)</code>函数唤醒指定线程，该线程回到就绪状态。</p>
</li>
<li>
<p>通过<code>notify()、notifyAll()、join线程执行完毕</code>方式，会唤醒锁等待队列的线程，出队的线程回到就绪状态。</p>
</li>
</ul>
</blockquote>
<p>超时等待状态（Timed waiting）:</p>
<blockquote>
<p>超时等待与等待状态一样，唯一的区别就是多了超时机制，不会一直等待被其他线程主动唤醒，而是到达指定时间后会<strong>自动唤醒</strong>。</p>
</blockquote>
<p>阻塞状态（Blocked）:</p>
<blockquote>
<p>运行状态的线程获取同步锁失败或发出<code>I/O</code>请求，该线程进入阻塞状态。</p>
<ul>
<li>如果是获取同步锁失败<code>JVM</code>还会把该线程放入锁的同步队列。</li>
<li>同步锁被释放时，锁的同步队列会出队所有线程，进入就绪状态。</li>
<li><code>I/O</code>处理完毕时，该线程重新回到就绪状态。</li>
</ul>
</blockquote>
<p><strong>线程安全</strong></p>
<blockquote>
<p>多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行问题，也不需要进行额外的同步，而调用这个对象的行为都可以获得正确的结果，那这个对象便是线程安全的。</p>
</blockquote>
<p><strong>什么场景需要注意线程安全问题？</strong></p>
<p>访问共享变量或资源：</p>
<blockquote>
<p>有访问共享对象的属性，访问 static 静态变量，访问共享的缓存等等。</p>
<p>因为这些信息不仅会被一个线程访问到，还有可能被多个线程同时访问，那么就有可能在并发读写的情况下发生线程安全问题。</p>
</blockquote>
<p>依赖时序的操作：</p>
<blockquote>
<p>如果我们操作的正确性是依赖时序的，而在多线程的情况下又不能保障执行的顺序和我们预想的一致，这个时候就会发生线程安全问题。</p>
</blockquote>
<pre><code class="language-java">if (map.containsKey(key)) &#123;
    map.remove(obj)
&#125;
</code></pre>
<p><strong>互斥与同步的区别</strong></p>
<blockquote>
<p>互斥：</p>
<ul>
<li>某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。</li>
</ul>
<p>同步：</p>
<ul>
<li>实现访问者对资源的有序访问。</li>
</ul>
</blockquote>
<p><strong>停止线程</strong></p>
<p>stop()：</p>
<blockquote>
<p>直接把线程停止，这样就没有给线程足够的时间来处理想要在停止前保存数据的逻辑，任务戛然而止，会导致出现数据完整性等问题。</p>
</blockquote>
<p>suspend() 和 resume()：</p>
<blockquote>
<p>如果线程调用 suspend()，它并不会释放锁，就开始进入休眠，但此时有可能仍持有锁，这样就容易导致死锁问题，因为这把锁在线程被 resume() 之前，是不会被释放的。</p>
</blockquote>
<p>interrupt()：</p>
<blockquote>
<p>一旦调用某个线程的 <strong>interrupt()</strong> 之后，这个线程的<strong>中断标记位就会被设置成 true</strong>。</p>
<p>每个线程都有这样的标记位，当线程执行时，应该定期检查这个标记位，如果标记位被设置成 true，就说明有程序想终止该线程。</p>
</blockquote>
<blockquote>
<p>在 while 循环体判断语句中，通过 <code>Thread.currentThread().isInterrupt()</code>判断线程是否被中断。</p>
</blockquote>
<pre><code class="language-java">while (!Thread.currentThread().islnterrupted() &amp;&amp; more work to do) &#123;
    do more work
&#125;
</code></pre>
<pre><code class="language-java">public class StopThread implements Runnable &#123;
 
    @Override
    public void run() &#123;
        int count = 0;
        while (!Thread.currentThread().isInterrupted() &amp;&amp; count &lt; 1000) &#123;
            System.out.println(&quot;count = &quot; + count++);
        &#125;
    &#125;
 
    public static void main(String[] args) throws InterruptedException &#123;
        Thread thread = new Thread(new StopThread());
        thread.start();
        Thread.sleep(5);
        thread.interrupt();
    &#125;
&#125;
</code></pre>
<blockquote>
<p>如果处于休眠（sleep、wait）中的线程被中断，那么线程是可以感受到中断信号的，并且会抛出一个 InterruptedException 异常，同时清除中断信号，将中断标记位设置成 false。</p>
<p>这样一来就不用担心长时间休眠中线程感受不到中断了，因为即便线程还在休眠，仍然能够响应中断通知，并抛出异常。</p>
</blockquote>
<p>如果我们负责编写的方法需要被别人调用，方法内调用了 sleep 或者 wait 等能响应中断的方法时，仅仅 catch 住异常是不够的。</p>
<p>方式一：方法签名抛异常，run() 强制 try/catch：</p>
<blockquote>
<p>将中断信号层层传递到顶层，最终让 run() 方法可以捕获到异常。</p>
</blockquote>
<pre><code class="language-java">void subTask() throws InterruptedException &#123;
    Thread.sleep(1000);
&#125;
</code></pre>
<p>方式二：再次中断：</p>
<blockquote>
<p>手动添加中断信号，中断信号依然可以被捕捉到。</p>
<p>这样后续执行的方法依然可以检测到这里发生过中断，可以做出相应的处理。</p>
</blockquote>
<pre><code class="language-java">private void reInterrupt() &#123;
    try &#123;
        Thread.sleep(2000);
    &#125; catch (InterruptedException e) &#123;
        Thread.currentThread().interrupt();
        e.printStackTrace();
    &#125;
&#125;
</code></pre>
<p><strong>生产者消费者模式</strong></p>
<pre><code class="language-java">public class MyBlockingQueueForCondition &#123;
 
   private Queue queue;
   private int max = 16;
   private ReentrantLock lock = new ReentrantLock();
   private Condition notEmpty = lock.newCondition();
   private Condition notFull = lock.newCondition();
 
 
   public MyBlockingQueueForCondition(int size) &#123;
       this.max = size;
       queue = new LinkedList();
   &#125;
 
   public void put(Object o) throws InterruptedException &#123;
       lock.lock();
       try &#123;
           while (queue.size() == max) &#123;
               notFull.await();
           &#125;
           queue.add(o);
           notEmpty.signalAll();
       &#125; finally &#123;
           lock.unlock();
       &#125;
   &#125;
 
   public Object take() throws InterruptedException &#123;
       lock.lock();
       try &#123;
           while (queue.size() == 0) &#123;
               notEmpty.await();
           &#125;
           Object item = queue.remove();
           notFull.signalAll();
           return item;
       &#125; finally &#123;
           lock.unlock();
       &#125;
   &#125;
&#125;
</code></pre>
<h2 id="Volatile">Volatile</h2>
<p>相比于 <strong><code>synchronized</code></strong> 关键字（重量级锁）对性能影响较大。</p>
<p>使用 <strong><code>volatile</code></strong> 不会引起上下文的切换和调度，所以 <strong><code>volatile</code></strong> 对性能的影响较小，开销较低。</p>
<blockquote>
<p><code>volatile</code> 可以保证其修饰的变量的<strong>可见性</strong>和<strong>有序性</strong>，无法保证<strong>原子性</strong>（不能保证完全的原子性，只能保证单次读/写操作具有原子性，即无法保证复合操作的原子性）。</p>
</blockquote>
<p><strong><code>volatile</code> 如何实现可见性？</strong></p>
<blockquote>
<p>被 <strong><code>volatile</code></strong> 修饰的共享变量 <code>flag</code> 被一个线程修改后，JMM（Java内存模型）会把该线程的CPU内存中的共享变量 <code>flag</code> 立即强制刷新回主存中，并且让其他线程的CPU内存中的共享变量 <code>flag</code> 缓存失效，这样当其他线程需要访问该共享变量 <code>flag</code> 时，就会从主存获取最新的数据。</p>
</blockquote>
<p><img src="/images/193.png" alt="image-20231017152846451"></p>
<p><strong><code>volatile</code> 实现可见性的原理</strong></p>
<p>Lock指令（汇编指令）：</p>
<blockquote>
<p>被 <code>volatile</code> 修饰的变量会多一个<strong>lock前缀的指令</strong>。</p>
<p>会将处理器缓存的数据写回主存中，同时使其他线程的处理器缓存的数据失效，这样其他线程需要使用数据时，会从主存中读取最新的数据，从而实现可见性。</p>
</blockquote>
<p>内存屏障（CPU指令）：</p>
<blockquote>
<p>为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。</p>
<p>JMM 提供了内存屏障阻止这种重排序。</p>
<p>Store屏障：</p>
<ul>
<li>当一个线程修改了volatile变量的值，它会在修改后插入一个<strong>写屏障</strong>，告诉处理器<strong>在写屏障之前将所有存储在缓存中的数据同步到主内存</strong>。</li>
</ul>
<p>Load屏障：</p>
<ul>
<li>当另一个线程读取volatile变量的值，它会在读取前插入一个<strong>读屏障</strong>，告诉处理器<strong>在读屏障之后的所有读操作都能获得内存屏障之前的所有写操作的最新结果</strong>。</li>
</ul>
<p>如果被 volatile 修饰时会多一个 <code>ACC_VOLATILE</code>，JVM把字节码生成机器码时会在相应位置插入内存屏障指令，因此可以通过读写屏障实现 <code>volatile</code> 修饰变量的可见性。</p>
</blockquote>
<p><strong><code>volatile</code> 如何实现有序性？</strong></p>
<blockquote>
<p><code>volatile</code> 保证变量有序性，禁止指令重排序。</p>
</blockquote>
<p><strong><code>volatile</code> 实现有序性的原理</strong></p>
<blockquote>
<p>Java编译器会在生成指令时在适当位置插入内存屏障来禁止特定类型的处理器重排序。</p>
</blockquote>
<p>内存屏障中<strong>禁止指令重排序</strong>的内存屏障的四种指令:</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>LoadLoad 屏障</td>
<td>保证在该屏障之后的读操作，不会被重排序到该屏障之前的读操作</td>
</tr>
<tr>
<td>StoreStore屏障</td>
<td>保证在该屏障之后的写操作，不会被重排序到该屏障之前的写操作，并且该屏障之前的写操作已被刷入主存</td>
</tr>
<tr>
<td>StoreLoad 屏障</td>
<td>保证在该屏障之后的读操作，能够看到该屏障之前的写操作对应变量的最新值</td>
</tr>
<tr>
<td>LoadStore 屏障</td>
<td>保证在该屏障之后的写操作，不会被重排序到该屏障之前的读操作</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>volatile的插入屏障策略</strong></p>
</blockquote>
<ul>
<li>在每个 <code>volatile</code> <strong>写</strong>操作的前面插入一个 StoreStore 屏障</li>
<li>在每个 <code>volatile</code> <strong>写</strong>操作的后面插入一个 StoreLoad 屏障</li>
<li>在每个 <code>volatile</code> <strong>读</strong>操作的后面插入一个 LoadLoad 屏障</li>
<li>在每个 <code>volatile</code> <strong>读</strong>操作的后面插入一个 LoadStore 屏障</li>
</ul>
<p>即在每个volatile写操作前后分别插入内存屏障，在每个volatile读操作后插入两个内存屏障。</p>
<img src="/images/194.png" alt="image-20231017154024898" style="zoom:100%;" />
<p><strong><code>volatile</code> 为什么不能保证原子性？</strong></p>
<blockquote>
<p><code>volatile</code> 无法保证复合操作的原子性，但能保证单个操作的原子性。</p>
</blockquote>
<p><strong><code>volatile</code> 常见的应用场景？</strong></p>
<p>状态标志位:</p>
<blockquote>
<p>使用 <code>volatile</code> 修饰一个变量<strong>通过赋值不同的常数或值来标识不同的状态</strong>。</p>
</blockquote>
<pre><code class="language-java">/**
 * 可以通过布尔值来控制线程的启动和停止
 */
public class MyThread extends Thread &#123;
    
    // 状态标志变量
    private volatile boolean flag = true;
    
    // 根据状态标志位来执行
    public void run() &#123;
        while (flag) &#123;
            // do something
        &#125;
    &#125;
    // 根据状态标志位来停止
    public void stopThread() &#123;
        flag = false; // 改变状态标志变量
    &#125;
&#125;
</code></pre>
<p>双重检查DLC:</p>
<blockquote>
<p>单例模式的双重检查DLC可以通过 <code>volatile</code> 来修饰从存储单例模式对象的变量。</p>
</blockquote>
<h1>原子类</h1>
<h2 id="CAS">CAS</h2>
<blockquote>
<p><code>CAS（compareAndSwap）</code>比较交换，是一种无锁原子算法，映射到操作系统就是一条<code>cmpxchg</code>硬件汇编指令（<strong>保证原子性</strong>）。</p>
<p>其作用是让<code>CPU</code>将内存值更新为新值，但是有个条件，内存值必须与期望值相同，并且<code>CAS</code>操作无需用户态与内核态切换，直接在用户态对内存进行读写操作（<strong>意味着不会阻塞/线程上下文切换</strong>）。</p>
</blockquote>
<blockquote>
<p>它包含<code>3</code>个参数<code>CAS（V，E，N）</code>，<code>V</code>表示待更新的内存值，<code>E</code>表示预期值，<code>N</code>表示新值，当 <code>V</code>值等于<code>E</code>值时，才会将<code>V</code>值更新成<code>N</code>值，如果<code>V</code>值和<code>E</code>值不等，不做更新，这就是一次<code>CAS</code>的操作。</p>
</blockquote>
<img src="/images/195.png" alt="image-20231017135339775" style="zoom:80%;" />
<p><strong>CAS如何保证原子性</strong></p>
<p>总线锁定:</p>
<blockquote>
<p>指<code>CPU</code>使用了总线锁。</p>
<p>总线锁就是使用<code>CPU</code>提供的<code>LOCK#</code>信号，当<code>CPU</code>在总线上输出<code>LOCK#</code>信号时，其他<code>CPU</code>的总线请求将被阻塞。</p>
</blockquote>
<p>缓存锁定：</p>
<blockquote>
<p>总线锁定方式在锁定期间，会导致大量阻塞，增加系统的性能开销。</p>
<p>所谓<strong>缓存锁定</strong>是指<code>CPU</code>对<strong>缓存行</strong>进行锁定，当缓存行中的共享变量回写到内存时，其他<code>CPU</code>会通过总线嗅探机制感知该共享变量是否发生变化，如果发生变化，让自己对应的共享变量缓存行失效，重新从内存读取最新的数据，缓存锁定是基于缓存一致性机制来实现的，因为缓存一致性机制会阻止两个以上<code>CPU</code>同时修改同一个共享变量（<strong>现代<code>CPU</code>基本都支持和使用缓存锁定机制</strong>）。</p>
<ul>
<li>缓存行是<code>CPU</code>高速缓存存储的最小单位。</li>
</ul>
</blockquote>
<p><strong>CAS的问题</strong></p>
<p>只能保证一个共享变量原子操作:</p>
<blockquote>
<p><code>CAS</code>只能针对一个共享变量使用，如果多个共享变量就只能使用锁了，也可以把多个变量整成一个变量。</p>
<ul>
<li>也可以利用一个新的类，来整合一组共享变量，利用 AtomicReference 来把这个新对象整体进行 CAS 操作。</li>
</ul>
</blockquote>
<p>自旋时间太长：</p>
<blockquote>
<p>当一个线程获取锁时失败，不进行阻塞挂起，而是间隔一段时间再次尝试获取，直到成功为止，这种循环获取的机制被称为自旋。</p>
<p>自旋锁好处：持有锁的线程在短时间内释放锁，那些等待竞争锁的线程就不需进入阻塞状态（<strong>无需线程上下文切换/无需用户态与内核态切换</strong>），它们只需要等一等（<strong>自旋</strong>），等到持有锁的线程释放锁之后即可获取，这样就避免了用户态和内核态的切换消耗。</p>
<p>自旋锁坏处：线程在长时间内持有锁，等待竞争锁的线程一直自旋，即CPU一直空转，资源浪费在毫无意义的地方。</p>
</blockquote>
<p>ABA问题：</p>
<blockquote>
<p><code>CAS</code>需要检查待更新的内存值有没有被修改，如果没有则更新。</p>
<p>存在这样一种情况，如果一个值原来是<code>A</code>，变成了<code>B</code>，然后又变成了<code>A</code>，在<code>CAS</code>检查的时候会发现没有被修改。</p>
<ul>
<li>有两个线程，线程<code>1</code>读取到内存值<code>A</code>，线程<code>1</code>时间片用完，切换到线程<code>2</code>，线程<code>2</code>也读取到了内存值<code>A</code>，并把它修改为<code>B</code>值，然后再把<code>B</code>值还原到<code>A</code>值，修改次序是<code>A-&gt;B-&gt;A</code>，接着线程<code>1</code>恢复运行，它发现内存值还是<code>A</code>，然后执行<code>CAS</code>操作。</li>
</ul>
<p>要解决<code>ABA</code>问题只要追加版本号即可，每次改变时加<code>1</code>，即<code>A —&gt; B —&gt; A</code>，变成<code>1A —&gt; 2B —&gt; 3A</code>，在<code>Java</code>中提供了<code>AtomicStampedRdference</code>可以实现这个方案。</p>
</blockquote>
<h1>阻塞队列</h1>
<p>BlockingQueue 继承了 Queue 接口，是队列的一种。</p>
<p>BlockingQueue 是线程安全的，在很多场景下都可以利用线程安全的队列来优雅地<strong>解决业务自身的线程安全问题。</strong></p>
<p><strong>ArrayBlockingQueue</strong></p>
<p>内部是用数组存储元素，利用 ReentrantLock 实现线程安全。</p>
<p>基本特性：</p>
<blockquote>
<p>1、有界的阻塞数组，容量一旦创建，后续大小无法修改。</p>
<p>2、元素是有顺序的，按照先入先出进行排序，从队尾插入数据数据，从队头拿数据。</p>
<p>3、队列满时，往队列中 put 数据会被阻塞，队列空时，往队列中拿数据也会被阻塞。</p>
</blockquote>
<p>新增数据：</p>
<pre><code class="language-java">// 新增，如果队列满，无限阻塞
public void put(E e) throws InterruptedException &#123;
    // 元素不能为空
    checkNotNull(e);
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try &#123;
        // 队列如果是满的，就无限等待
        // 一直等待队列中有数据被拿走时，自己被唤醒
        while (count == items.length)
            notFull.await();
        enqueue(e);
    &#125; finally &#123;
        lock.unlock();
    &#125;
&#125;
 
private void enqueue(E x) &#123;
    // assert lock.getHoldCount() == 1; 同一时刻只能一个线程进行操作此方法
    // assert items[putIndex] == null;
    final Object[] items = this.items;
    // putIndex 为本次插入的位置
    items[putIndex] = x;
    // ++ putIndex 计算下次插入的位置
    // 如果下次插入的位置，正好等于队尾，下次插入就从 0 开始
    if (++putIndex == items.length)
        putIndex = 0;
    count++;
    // 唤醒因为队列空导致的等待线程
    notEmpty.signal();
&#125;
</code></pre>
<p>查询数据：</p>
<blockquote>
<p>每次拿数据的位置就是 takeIndex 的位置，在找到本次该拿的数据之后，会把 takeIndex 加 1，计算下次拿数据时的索引位置。</p>
<p>有个特殊情况是，如果本次拿数据的位置已经是队尾了，那么下次拿数据的位置就要从头开始，就是从 0 开始了。</p>
</blockquote>
<pre><code class="language-java">public E take() throws InterruptedException &#123;
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try &#123;
        // 如果队列为空，无限等待
        // 直到队列中有数据被 put 后，自己被唤醒
        while (count == 0)
            notEmpty.await();
        // 从队列中拿数据
        return dequeue();
    &#125; finally &#123;
        lock.unlock();
    &#125;
&#125;
 
private E dequeue() &#123;
    final Object[] items = this.items;
    // takeIndex 代表本次拿数据的位置，是上一次拿数据时计算好的
    E x = (E) items[takeIndex];
    // 帮助 gc
    items[takeIndex] = null;
    // ++ takeIndex 计算下次拿数据的位置
    // 如果正好等于队尾的话，下次就从 0 开始拿数据
    if (++takeIndex == items.length)
        takeIndex = 0;
    // 队列实际大小减 1
    count--;
    if (itrs != null)
        itrs.elementDequeued();
    // 唤醒被队列满所阻塞的线程
    notFull.signal();
    return x;
&#125;
</code></pre>
<p><strong>LinkedBlockingQueue</strong></p>
<p>内部用链表实现的BlockingQueue。</p>
<p>基本特性：</p>
<blockquote>
<p>1、它容量默认就为整型的最大值：<code>Integer.MAX_VALUE</code>。</p>
<p>2、基于链表的阻塞队列，其底层的数据结构是链表。</p>
<p>3、链表维护先入先出队列，新元素被放在队尾，获取元素从队头部拿。</p>
</blockquote>
<p>LinkedBlockingQueue 内部构成，分成三个部分：链表存储 + 锁 + 迭代器。</p>
<pre><code class="language-java">// 链表结构 begin
//链表的元素
static class Node&lt;E&gt; &#123;
    E item;
 
    //当前元素的下一个，为空表示当前节点是最后一个
    Node&lt;E&gt; next;
 
    Node(E x) &#123; item = x; &#125;
&#125;
 
//链表的容量，默认 Integer.MAX_VALUE
private final int capacity;
 
//链表已有元素大小，使用 AtomicInteger，所以是线程安全的
private final AtomicInteger count = new AtomicInteger();
 
//链表头
transient Node&lt;E&gt; head;
 
//链表尾
private transient Node&lt;E&gt; last;
// 链表结构 end
 
// 锁 begin
//take 时的锁
private final ReentrantLock takeLock = new ReentrantLock();
 
// take 的条件队列，condition 可以简单理解为基于 ASQ 同步机制建立的条件队列
private final Condition notEmpty = takeLock.newCondition();
 
// put 时的锁，设计两把锁的目的，主要为了 take 和 put 可以同时进行
private final ReentrantLock putLock = new ReentrantLock();
 
// put 的条件队列
private final Condition notFull = putLock.newCondition();
// 锁 end
 
// 迭代器 
// 实现了自己的迭代器
private class Itr implements Iterator&lt;E&gt; &#123;
………………
&#125;
</code></pre>
<blockquote>
<p>1、链表的作用是为了保存当前节点，节点中的数据可以是任意东西，是一个泛型，比如说队列被应用到线程池时，节点就是线程，比如队列被应用到消息队列中，节点就是消息。</p>
<p>2、锁有 take 锁和 put 锁，是为了保证队列操作时的线程安全。</p>
<ul>
<li>设计两种锁，是为了 take 和 put 两种操作可以同时进行，互不影响。</li>
</ul>
</blockquote>
<p>阻塞新增：</p>
<pre><code class="language-java">// 把e新增到队列的尾部。
// 如果有可以新增的空间的话，直接新增成功，否则当前线程陷入等待
public void put(E e) throws InterruptedException &#123;
    // e 为空，抛出异常
    if (e == null) throw new NullPointerException();
    // 预先设置 c 为 -1，约定负数为新增失败
    int c = -1;
    Node&lt;E&gt; node = new Node&lt;E&gt;(e);
    final ReentrantLock putLock = this.putLock;
    final AtomicInteger count = this.count;
    // 设置可中断锁
    putLock.lockInterruptibly();
    try &#123;
        // 队列满了
        // 当前线程阻塞，等待其他线程的唤醒(其他线程 take 成功后就会唤醒此处被阻塞的线程)
        while (count.get() == capacity) &#123;
            // await 无限等待
            notFull.await();
        &#125;
 
        // 队列没有满，直接新增到队列的尾部
        enqueue(node);
 
        // 新增计数赋值,注意这里 getAndIncrement 返回的是旧值
        // 这里的 c 是比真实的 count 小 1 的
        c = count.getAndIncrement();
 
        // 如果链表现在的大小 小于链表的容量，说明队列未满
        // 可以尝试唤醒一个 put 的等待线程
        if (c + 1 &lt; capacity)
            notFull.signal();
 
    &#125; finally &#123;
        // 释放锁
        putLock.unlock();
    &#125;
    // c==0，代表队列里面有一个元素
    // 会尝试唤醒一个take的等待线程
    if (c == 0)
        signalNotEmpty();
&#125;
// 入队，把新元素放到队尾
private void enqueue(Node&lt;E&gt; node) &#123;
    last = last.next = node;
&#125;
</code></pre>
<p><strong>SynchronousQueue</strong></p>
<p>它的容量为 0，没有一个地方来暂存元素，导致每次取数据都要先阻塞，直到有数据被放入。</p>
<p>每次放数据的时候也会阻塞，直到有消费者来取。</p>
<p>基本特性：</p>
<blockquote>
<p>在内部抽象出了两种算法实现，一种是先入先出的队列，一种是后入先出的堆栈，两种算法被两个内部类实现：</p>
<ul>
<li>队列不存储数据，所以没有大小，也无法迭代。</li>
<li>插入操作的返回必须等待另一个线程完成对应数据的删除操作，反之亦然。</li>
<li>队列由两种数据结构组成，分别是后入先出的堆栈和先入先出的队列，堆栈是非公平的，队列是公平的。</li>
</ul>
</blockquote>
<p><strong>PriorityBlockingQueue</strong></p>
<blockquote>
<p>支持优先级的无界阻塞队列，可以通过自定义类实现 compareTo() 方法来指定元素排序规则，或者初始化时通过构造器参数 Comparator 来指定排序规则。</p>
</blockquote>
<p><strong>DelayQueue</strong></p>
<p>底层使用了排序和超时阻塞实现了延迟队列，排序使用的是 PriorityQueue 排序能力，超时阻塞使用的是锁的等待能力，DelayQueue 其实就是为了满足延迟执行的场景，在已有 API 的基础上进行了封装。</p>
<blockquote>
<p>内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是 堆 的数据结构。</p>
</blockquote>
<p>基本特性：</p>
<blockquote>
<p>1、队列中元素将在过期时被执行，越靠近队头，越早过期。</p>
<p>2、未过期的元素不能够被 take。</p>
<p>3、不允许空元素。</p>
</blockquote>
<h1>内存模型</h1>
<p><code>JMM</code>抽象结构划分为线程本地缓存与主存，每个线程均有自己的本地缓存，本地缓存是线程<strong>私有</strong>的，主存则是计算机内存，它是<strong>共享</strong>的。</p>
<p><strong>为什么需要 JMM（Java Memory Model，Java 内存模型）</strong></p>
<blockquote>
<p>程序最终执行的效果会依赖于具体的处理器，而不同的处理器的规则又不一样，不同的处理器之间可能差异很大，因此同样的一段代码，可能在处理器 A 上运行正常，而在处理器 B 上运行的结果却不一致。</p>
<ul>
<li>在没有 JMM 之前，不同的 JVM 的实现，也会带来不一样的 翻译 结果。</li>
</ul>
<p>如果达成一致后，就可以很清楚的知道什么样的代码最终可以达到什么样的运行效果，让多线程运行结果可以预期。</p>
</blockquote>
<p><strong>主内存和工作内存的关系</strong></p>
<img src="/images/196.png" alt="image-20231017161900549" style="zoom:80%;" />
<p>JMM 有以下规定：</p>
<blockquote>
<p>所有的变量都存储在主内存中，同时每个线程拥有自己独立的工作内存，而工作内存中的变量的内容是主内存中该变量的拷贝。</p>
<p>线程不能直接读/写主内存中的变量，但可以操作自己工作内存中的变量，然后再同步到主内存中，这样，其他线程就可以看到本次修改。</p>
<p>主内存是由多个线程所共享的，但线程间不共享各自的工作内存，如果线程间需要通信，则必须借助主内存中转来完成。</p>
</blockquote>
<p><strong>可见性</strong></p>
<p>当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。</p>
<p>能够保证可见性的措施：</p>
<blockquote>
<p>volatile 关键字。</p>
<p>synchronized、Lock、并发集合等一系列工具。</p>
</blockquote>
<p><strong>原子性</strong></p>
<p>原子性是指一个或者多个操作在<code>CPU</code>执行的过程中不被中断的特性，要么执行，要不执行，不能执行到一半。</p>
<p>比如 i++ 这一行代码在 CPU 中执行时，可能会从一行代码变为以下的 3 个指令：</p>
<blockquote>
<p>第一个步骤是读取。</p>
<p>第二个步骤是增加。</p>
<p>第三个步骤是保存。</p>
</blockquote>
<p>所以 i++ 是不具备原子性的，也不是线程安全的。</p>
<p><strong>有序性</strong></p>
<p>有序性指<strong>禁止指令重排序，即保证程序执行代码的顺序与编写程序的顺序一致</strong>（程序执行顺序按照代码的先后顺序执行）。</p>
<p>重排序的3种情况:</p>
<blockquote>
<p>编译器优化：</p>
<ul>
<li>编译器（包括 JVM、JIT 编译器等）出于优化的目的，例如当前有了数据 a，把对 a 的操作放到一起效率会更高，避免读取 b 后又返回来重新读取 a 的时间开销，此时在编译的过程中会进行一定程度的重排。</li>
</ul>
<p>CPU重排序：</p>
<ul>
<li>CPU 同样会有优化行为，这里的优化和编译器优化类似，都是通过乱序执行的技术来提高整体的执行效率。</li>
</ul>
<p>内存的重排序：</p>
<ul>
<li>由于内存有缓存的存在，在 JMM 里表现为主存和本地内存，而主存和本地内存的内容可能不一致，所以这也会导致程序表现出乱序的行为。</li>
</ul>
</blockquote>
<p>重排需要遵循<code>as-if-serial</code>原则，编译器和处理器不会对<strong>存在数据依赖关系</strong>的操作做重排序，因为这种重排序会改变执行结果。</p>
<blockquote>
<p><strong>重排序的好处：提高处理速度。</strong></p>
</blockquote>
<pre><code class="language-java">int i = 10
int j = 10
//这就是数据依赖，int i 与 int j 不能排到 int c下面去
int c = i + j
</code></pre>
<p><strong>Happens Before规则</strong></p>
<p>Happens Before关系是用来描述和可见性相关问题的：</p>
<blockquote>
<p>如果第一个操作 happens before 第二个操作，那么我们就说第一个操作对于第二个操作一定是可见的，也就是第二个操作在执行时就一定能保证看见第一个操作执行的结果。</p>
</blockquote>
<p>不具备 happens before 关系的例子:</p>
<blockquote>
<p>如果有两个线程，分别执行 write 和 read 方法，那么由于这两个线程之间没有相互配合的机制，所以 write 和 read 方法内的代码不具备 happens-before 关系，其中的变量的可见性无法保证。</p>
</blockquote>
<pre><code class="language-java">public class Visibility &#123;
    int x = 0;
    public void write() &#123;
        x = 1;
    &#125;
    public void read() &#123;
        int y = x;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>单线程规则：</p>
<ul>
<li>在一个单独的线程中，按照程序代码的顺序，先执行的操作 happen before 后执行的操作。</li>
</ul>
<p>volatile 变量规则：</p>
<ul>
<li>对一个 volatile 变量的写操作 happen before 后面对该变量的读操作。</li>
</ul>
<p>线程启动规则：</p>
<ul>
<li>Thread 对象的 start 方法 happen before 此线程 run 方法中的每一个操作。</li>
</ul>
</blockquote>
<h1>线程池</h1>
<p><strong>为什么要使用线程池</strong></p>
<blockquote>
<p>线程池可以解决线程生命周期的系统开销问题，同时还可以加快响应速度：</p>
<ul>
<li>因为线程池中的线程是可以复用的，我们只用少量的线程去执行大量的任务，不用频繁创建线程。</li>
</ul>
<p>线程池可以管理内存和 CPU 的使用，避免资源使用不当：</p>
<ul>
<li>线程池会根据配置和任务数量灵活地控制线程数量。</li>
</ul>
<p>线程池可以统一管理资源：</p>
<ul>
<li>比如线程池可以统一管理任务队列和线程。</li>
</ul>
</blockquote>
<p><strong>线程池参数</strong></p>
<pre><code class="language-java">public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)
</code></pre>
<blockquote>
<p>corePoolSize：</p>
<ul>
<li>线程池的核心线程数量，即线程池中可以保持活动状态的最小线程数。</li>
<li>当提交的任务数超过核心线程数量时，线程池可以创建更多的线程来执行任务。</li>
</ul>
<p>maximumPoolSize：</p>
<ul>
<li>线程池中允许同时存在的最大线程数量，即当任务数超过核心线程数量时，线程池可以创建的最大线程数量。</li>
<li>当线程池中的线程数量已经达到最大值且任务队列已满时，可以采取拒绝策略处理过多的任务。</li>
<li>可以在创建线程池时指定最大线程数，也可以在运行时动态地修改。</li>
</ul>
<p>keepAliveTime：</p>
<ul>
<li>线程空闲后的存活时间。</li>
<li>当线程池中的线程数量超过核心线程数时，空闲的线程会在等待新任务到来的过程中等待一段时间。</li>
<li>如果等待时间超过了 <code>keepAliveTime</code>，则该线程会被销毁，以释放资源。</li>
</ul>
<p>unit：</p>
<ul>
<li>keepAliveTime 的单位，可以是毫秒、微秒、纳秒等等。</li>
</ul>
<p>workQueue：</p>
<ul>
<li>线程池中用于保存等待中任务的阻塞队列。</li>
</ul>
<p>threadFactory：</p>
<ul>
<li>线程工厂，用于创建线程的工厂，可以自定义实现。</li>
<li>可以选择使用默认的线程工厂，创建的线程都会在同一个线程组，并拥有一样的优先级，且都不是守护线程。</li>
<li>也可以选择自己定制线程工厂，以方便给线程自定义命名，不同的线程池内的线程通常会根据具体业务来定制不同的线程名。</li>
</ul>
<p>handler：</p>
<ul>
<li>当线程池已经关闭或已满时，新任务的处理策略。</li>
</ul>
</blockquote>
<img src="/images/197.png" alt="image-20231220132715694" style="zoom:50%;" />
<blockquote>
<p>在创建了线程池后，线程池中的线程数为零。</p>
<p>当调用 <code>execute()</code> 方法添加一个请求任务时，线程池会做出如下判断：</p>
<ul>
<li>
<p>如果正在运行的线程数量 小于 <code>corePoolSize</code>，那么马上创建线程运行这个任务。</p>
</li>
<li>
<p>如果正在运行的线程数量 大于或等于 <code>corePoolSize</code>，那么将这个任务放入队列。</p>
</li>
<li>
<p>如果这个时候队列满了且正在运行的线程数量还 小于 <code>maximumPoolSize</code>，那么还是要创建非核心线程立刻运行这个任务。</p>
</li>
<li>
<p>如果队列满了且正在运行的线程数量 大于或等于 <code>maximumPoolSize</code>，那么线程池会启动饱和拒绝策略来执行。</p>
</li>
<li>
<p>当一个线程完成任务时，它会从队列中取下一个任务来执行。</p>
</li>
</ul>
<p>当一个线程无事可做超过一定的时间（<code>keepAliveTime</code>）时，线程会判断：</p>
<ul>
<li>如果当前运行的线程数大于 <code>corePoolSize</code>，那么这个线程就被停掉。</li>
<li>所以线程池的所有任务完成后，它最终会收缩到<code>corePoolSize</code>的大小。</li>
</ul>
</blockquote>
<p><strong>拒绝策略</strong></p>
<p>线程池会在以下两种情况下会拒绝新提交的任务：</p>
<blockquote>
<p>当我们调用 shutdown 等方法关闭线程池后：</p>
<ul>
<li>即便此时可能线程池内部依然有没执行完的任务正在执行，但由于线程池已经关闭，此时如果再向线程池内提交任务，就会遭到拒绝。</li>
</ul>
<p>线程池没有能力继续处理新提交的任务，也就是工作已经非常饱和的时候。</p>
</blockquote>
<p>4种默认的拒绝策略：</p>
<blockquote>
<p>第一种拒绝策略是 <strong>AbortPolicy</strong>：</p>
<ul>
<li>在拒绝任务时，会直接抛出一个类型为 RejectedExecutionException 的 RuntimeException，让你感知到任务被拒绝了，可以根据业务逻辑选择重试或者放弃提交等策略。</li>
</ul>
<p>第二种拒绝策略是 <strong>DiscardPolicy</strong>：</p>
<ul>
<li>当新任务被提交后直接被丢弃掉，也不会给你任何的通知，存在一定的风险，因为我们提交的时候根本不知道这个任务会被丢弃，可能造成数据丢失。</li>
</ul>
<p>第三种拒绝策略是 <strong>DiscardOldestPolicy</strong>：</p>
<ul>
<li>如果线程池没被关闭且没有能力执行，会丢弃任务队列中的头结点，通常是存活时间最长的任务，这样可以腾出空间给新提交的任务。</li>
</ul>
<p>第四种拒绝策略是 <strong>CallerRunsPolicy</strong>：</p>
<ul>
<li>当有新任务提交后，如果线程池没被关闭且没有能力执行，则把这个任务交于提交任务的线程执行，也就是谁提交任务，谁就负责执行任务，这样做主要有两点好处：</li>
</ul>
<ul>
<li>第一点：新提交的任务不会被丢弃，这样也就不会造成业务损失。</li>
<li>第二点：由于谁提交任务谁就要负责执行任务，这样提交任务的线程就得负责执行任务，而执行任务又是比较耗时的，在这段期间，提交任务的线程被占用，也就不会再提交新的任务，减缓了任务提交的速度。</li>
</ul>
<p>以上内置的策略均<strong>实现了 RejectedExecutionHandler 接口</strong>。</p>
<p>可以自己扩展 <code>RejectedExecutionHandler</code> 接口，定义自己的拒绝策略。</p>
</blockquote>
<p><strong>使用CallerRunsPolicy顺序问题：</strong></p>
<blockquote>
<p>当<strong>线程数</strong>线程池的<strong>最大线程数</strong>并且<strong>阻塞队列已满</strong>的情况下，后到的数据会执行拒绝策略，让调用线程（提交任务的线程）直接执行此任务，导致数据处理顺序不一致。</p>
<p>当在多线程中数据处理时需要强关联数据时间顺序时，最好考虑一下其他的处理方式，避免踩坑。</p>
</blockquote>
<p><strong>设置线程数</strong></p>
<p>公式：</p>
<blockquote>
<p><code>最佳线程数目 = （（线程等待时间+线程CPU时间）/ 线程CPU时间 ）* CPU数目</code>。</p>
<p>举例：</p>
<p>服务器CPU核数为4核，一个任务线程CPU耗时为20ms，线程等待（网络IO、磁盘IO）耗时80ms</p>
<p><strong>最佳线程数目：( 80 + 20 )/20 * 4 = 20</strong></p>
<ul>
<li>线程的等待时间越大，线程数就要设置越大。</li>
</ul>
<p>线程数设置多大，是根据我们自身的业务的，需要自己去压力测试，设置一个合理的数值。</p>
</blockquote>
<blockquote>
<p><strong>CPU密集型：</strong></p>
<ul>
<li>操作内存处理的业务，一般线程数设置为：<code>CPU核数 + 1 或者 CPU核数*2</code>，核数为4的话，一般设置 5 或 8</li>
</ul>
<p><strong>IO密集型：</strong></p>
<ul>
<li>文件操作，网络操作，数据库操作，一般线程设置为：<code>CPU核数 / (1-0.9)</code>，核数为4的话，一般设置 40</li>
</ul>
</blockquote>
<p><strong>常见线程池</strong></p>
<p>FixedThreadPool：</p>
<blockquote>
<p>它的核心线程数和最大线程数是一样的，线程池中的线程数除了初始阶段需要从 0 开始增加外，之后的线程数量就是固定的，就算任务数超过线程数，线程池也不会再创建更多的线程来处理任务，而是会把超出线程处理能力的任务放到任务队列中进行等待。</p>
<p>而且就算任务队列满了，也无法再增加新的线程了。</p>
<p>BlockingQueue选取的是LinkedBlockingQueue。</p>
</blockquote>
<p>CachedThreadPool：</p>
<blockquote>
<p>它的特点在于线程数是几乎可以无限增加的（实际最大可以达到 <code>Integer.MAX_VALUE</code>，为 <code>2^31-1</code>）。</p>
<ul>
<li>当线程闲置时还可以对线程进行回收。</li>
</ul>
<p>它有一个用于存储提交任务的队列，但这个队列是 SynchronousQueue，队列的容量为0，实际不存储任何任务，它只负责对任务进行中转和传递，所以效率比较高。</p>
</blockquote>
<p>ScheduledThreadPool：</p>
<blockquote>
<p>ScheduledThreadPool，它支持定时或周期性执行任务。</p>
<p>BlockingQueue选取的是延迟队列DelayedWorkQueue。</p>
</blockquote>
<p>SingleThreadExecutor：</p>
<blockquote>
<p>它会使用唯一的一个线程去执行任务，如果线程在执行任务的过程中发生异常，线程池也会重新创建一个线程来执行后续的任务。</p>
<p>这种线程池由于只有一个线程，所以非常适合用于所有任务都需要按被提交的顺序依次执行的场景。</p>
<p>BlockingQueue选取的是LinkedBlockingQueue。</p>
</blockquote>
<p><strong>ForkJoinPool</strong></p>
<p>它非常适合执行可以产生子任务的任务。</p>
<blockquote>
<p>适合<strong>用于递归的场景，例如树的遍历、最优路径搜索等场景</strong>。</p>
</blockquote>
<p><strong>关闭线程池</strong></p>
<p>shutdown()：</p>
<blockquote>
<p>调用 <code>shutdown()</code> 方法之后线程池并不是立刻就被关闭，线程池会在执行完正在执行的任务和队列中等待的任务后才彻底关闭。</p>
<p>调用 <code>shutdown()</code> 方法后如果还有新的任务被提交，线程池则会根据拒绝策略直接拒绝后续新提交的任务。</p>
</blockquote>
<p>shutdownNow()：</p>
<blockquote>
<p>首先会给所有线程池中的线程发送 interrupt 中断信号，尝试中断这些任务的执行。</p>
<p>队列中正在等待的所有任务转移到一个 List 中并返回，可根据返回的任务 List 来进行一些补救的操作，例如记录在案并在后期重试。</p>
</blockquote>
<p><strong>线程复用原理</strong></p>
<blockquote>
<p>在线程池中，同一个线程可以从 BlockingQueue 中不断提取新任务来执行。</p>
<p>线程池对 Thread 进行了封装，并不是每次执行任务都会调用 <code>Thread.start()</code> 来创建新线程，而是让每个线程去执行一个 <strong>循环任务</strong>，在这个 <strong>循环任务</strong> 中，不停地检查是否还有任务等待被执行，如果有则直接去执行这个任务，也就是调用任务的 run 方法，把 run 方法当作和普通方法一样的地位去调用，相当于把每个任务的 run() 方法串联了起来，所以线程数量并不增加。</p>
</blockquote>
<blockquote>
<p><strong>实现线程复用的逻辑主要在一个不停循环的 while 循环体中</strong></p>
<ul>
<li>
<p>通过取 Worker 的 <strong>firstTask</strong> 或者通过 <strong>getTask</strong> 方法从 <strong>workQueue</strong> 中获取待执行的任务。</p>
</li>
<li>
<p>直接调用 task 的 run 方法来执行具体的任务（而不是新建线程）。</p>
</li>
</ul>
</blockquote>
<p><strong>ThreadPoolExecutor重要属性</strong></p>
<pre><code class="language-java">//ctl 线程池状态控制字段，由两部分组成：
//1:workerCount  wc 工作线程数，我们限制 workerCount 最大到(2^29)-1，大概 5 亿个线程
//2:runState rs 线程池的状态，提供了生命周期的控制，源码中有很多关于状态的校验，状态枚举如下：
//RUNNING（-536870912）：接受新任务或者处理队列里的任务。
//SHUTDOWN（0）：不接受新任务，但仍在处理已经在队列里面的任务。
//STOP（-536870912）：不接受新任务，也不处理队列中的任务，对正在执行的任务进行中断。
//TIDYING（1073741824）： 所以任务都被中断，workerCount 是 0，整理状态
//TERMINATED（1610612736）： terminated() 已经完成的时候
 
//runState 之间的转变过程：
//RUNNING -&gt; SHUTDOWN：调用 shudown(),finalize()
//(RUNNING or SHUTDOWN) -&gt; STOP：调用shutdownNow()
//SHUTDOWN -&gt; TIDYING -&gt; workerCount ==0
//STOP -&gt; TIDYING -&gt; workerCount ==0
//TIDYING -&gt; TERMINATED -&gt; terminated() 执行完成之后
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
private static final int COUNT_BITS = Integer.SIZE - 3;// 29
private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;// =(2^29)-1=536870911
 
// Packing and unpacking ctl
private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;
private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;
private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;
 
// runState is stored in the high-order bits
private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;//-536870912
private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;//0
private static final int STOP       =  1 &lt;&lt; COUNT_BITS;//-536870912
private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;//1073741824
private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;//1610612736
 
// 已完成任务的计数
volatile long completedTasks;
// 线程池最大容量
private int largestPoolSize;
// 已经完成的任务数
private long completedTaskCount;
// 用户可控制的参数都是 volatile 修饰的
// 可以使用 threadFactory 创建 thread
// 创建失败一般不抛出异常，只有在 OutOfMemoryError 时候才会
private volatile ThreadFactory threadFactory;
// 饱和或者运行中拒绝任务的 handler 处理类
private volatile RejectedExecutionHandler handler;
// 线程存活时间设置
private volatile long keepAliveTime;
// 设置 true 的话，核心线程空闲 keepAliveTime 时间后，也会被回收
private volatile boolean allowCoreThreadTimeOut;
// coreSize
private volatile int corePoolSize;
// maxSize 最大限制 (2^29)-1
private volatile int maximumPoolSize;
// 默认的拒绝策略
private static final RejectedExecutionHandler defaultHandler =
    new AbortPolicy();
 
// 队列会 hold 住任务，并且利用队列的阻塞的特性，来保持线程的存活周期
private final BlockingQueue&lt;Runnable&gt; workQueue;
 
// 大多数情况下是控制对 workers 的访问权限
private final ReentrantLock mainLock = new ReentrantLock();
private final Condition termination = mainLock.newCondition();
 
// 包含线程池中所有的工作线程
private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();
</code></pre>
<p>Worker可以理解成线程池中任务运行的最小单元：</p>
<pre><code class="language-java">// 线程池中任务执行的最小单元
// Worker 继承 AQS，具有锁功能
// Worker 实现 Runnable，本身是一个可执行的任务
private final class Worker
    extends AbstractQueuedSynchronizer
    implements Runnable
&#123;
    // 任务运行的线程
    final Thread thread;
 
    // 需要执行的任务
    Runnable firstTask;
 
    // 非常巧妙的设计,Worker本身是个 Runnable,把自己作为任务传递给 thread
    // 内部有个属性又设置了 Runnable
    Worker(Runnable firstTask) &#123;
        setState(-1); // inhibit interrupts until runWorker
        this.firstTask = firstTask;
        // 把 Worker 自己作为 thread 运行的任务
        this.thread = getThreadFactory().newThread(this);
    &#125;
 
   /** Worker 本身是 Runnable，run 方法是 Worker 执行的入口， runWorker 是外部的方法 */
    public void run() &#123;
        runWorker(this);
    &#125;
 
    private static final long serialVersionUID = 6138294804551838833L;
 
    // Lock methods
    // 0 代表没有锁住，1 代表锁住
    protected boolean isHeldExclusively() &#123;
        return getState() != 0;
    &#125;
    // 尝试加锁，CAS 赋值为 1，表示锁住
    protected boolean tryAcquire(int unused) &#123;
        if (compareAndSetState(0, 1)) &#123;
            setExclusiveOwnerThread(Thread.currentThread());
            return true;
        &#125;
        return false;
    &#125;
    // 尝试释放锁，释放锁没有 CAS 校验，可以任意的释放锁
    protected boolean tryRelease(int unused) &#123;
        setExclusiveOwnerThread(null);
        setState(0);
        return true;
    &#125;
 
    public void lock()        &#123; acquire(1); &#125;
    public boolean tryLock()  &#123; return tryAcquire(1); &#125;
    public void unlock()      &#123; release(1); &#125;
    public boolean isLocked() &#123; return isHeldExclusively(); &#125;
 
    void interruptIfStarted() &#123;
        Thread t;
        if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123;
            try &#123;
                t.interrupt();
            &#125; catch (SecurityException ignore) &#123;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>在线程池中，最小的执行单位就是 Worker，所以 Worker 实现了 Runnable 接口，实现了 run 方法。</p>
<p>Worker 本身也实现了 AQS，所以其本身也是一个锁，其在执行任务的时候，会锁住自己，任务执行完成之后，会释放自己。</p>
</blockquote>
<p><strong>线程池的任务提交</strong></p>
<p>线程池的任务提交从 submit 方法 开始，主要做了两件事情：</p>
<blockquote>
<p>把 Runnable 和 Callable 都转化成 FutureTask。</p>
<p>使用 execute 方法执行 FutureTask。</p>
</blockquote>
<blockquote>
<p>在 execute 方法中，多次调用 addWorker 方法把任务传入，Worker 内部有一个 Thread 对象，它正是最终真正执行任务的线程，所以一个 Worker 就对应线程池中的一个线程，addWorker 就代表增加线程。</p>
<p>线程复用的逻辑实现主要在 Worker 类中的 run 方法里执行的 runWorker 方法中。</p>
</blockquote>
<pre><code class="language-java">public void execute(Runnable command) &#123;
    if (command == null)
        throw new NullPointerException();
    int c = ctl.get();
    // 工作的线程小于核心线程数，创建新的线程，成功返回，失败不抛异常
    if (workerCountOf(c) &lt; corePoolSize) &#123;
        if (addWorker(command, true))
            return;
        // 线程池状态可能发生变化
        c = ctl.get();
    &#125;
    // 工作的线程大于等于核心线程数，或者新建线程失败
    // 线程池状态正常，并且可以入队的话，尝试入队列
    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;
        int recheck = ctl.get();
        // 如果线程池状态异常 尝试从队列中移除任务，可以移除的话就拒绝掉任务
        if (!isRunning(recheck) &amp;&amp; remove(command))
            reject(command);
        // 发现可运行的线程数是 0，就初始化一个线程，这里是个极限情况，入队的时候，突然发现
        // 可用线程都被回收了
        else if (workerCountOf(recheck) == 0)
            // Runnable是空的，不会影响新增线程，但是线程在 start 的时候不会运行
            // Thread.run() 里面有判断
            addWorker(null, false);
    &#125;
    // 队列满了，开启线程到 maxSize，如果失败直接拒绝,
    else if (!addWorker(command, false))
        reject(command);
&#125;
</code></pre>
<pre><code class="language-java">// 结合线程池的情况看是否可以添加新的 worker
// firstTask 不为空可以直接执行，为空执行不了，Thread.run()方法有判断，Runnable为空不执行
// core 为 true 表示线程最大新增个数是 coresize，false 表示最大新增个数是 maxsize
// 返回 true 代表成功，false 失败
// break retry 跳到retry处，且不再进入循环
// continue retry 跳到retry处，且再次进入循环
private boolean addWorker(Runnable firstTask, boolean core) &#123;
    retry:
    // 先是各种状态的校验
    for (;;) &#123;
        int c = ctl.get();
        int rs = runStateOf(c);
        // Check if queue empty only if necessary.
        // rs &gt;= SHUTDOWN 说明线程池状态不正常
        if (rs &gt;= SHUTDOWN &amp;&amp;
            ! (rs == SHUTDOWN &amp;&amp;
               firstTask == null &amp;&amp;
               ! workQueue.isEmpty()))
            return false;
 
        for (;;) &#123;
            int wc = workerCountOf(c);
            // 工作中的线程数大于等于容量，或者大于等于 coreSize or maxSize
            if (wc &gt;= CAPACITY ||
                wc &gt;= (core ? corePoolSize : maximumPoolSize))
                return false;
            if (compareAndIncrementWorkerCount(c))
                // break 结束 retry 的 for 循环
                break retry;
            c = ctl.get();  // Re-read ctl
            // 线程池状态被更改
            if (runStateOf(c) != rs)
                // 跳转到retry位置
                continue retry;
            // else CAS failed due to workerCount change; retry inner loop
        &#125;
    &#125;
 
    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try &#123;
        // 巧妙的设计，Worker 本身是个 Runnable.
        // 在初始化的过程中，会把 worker 丢给 thread 去初始化
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) &#123;
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try &#123;
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                int rs = runStateOf(ctl.get());
                if (rs &lt; SHUTDOWN ||
                    (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    workers.add(w);
                    int s = workers.size();
                    if (s &gt; largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                &#125;
            &#125; finally &#123;
                mainLock.unlock();
            &#125;
            if (workerAdded) &#123;
                // 启动线程，实际上去执行 Worker.run 方法
                t.start();
                workerStarted = true;
            &#125;
        &#125;
    &#125; finally &#123;
        if (! workerStarted)
            addWorkerFailed(w);
    &#125;
    return workerStarted;
&#125;
</code></pre>
<pre><code class="language-java">public void run() &#123;
    runWorker(this);
&#125;
</code></pre>
<pre><code class="language-java">final void runWorker(Worker w) &#123;
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    //帮助gc回收
    w.firstTask = null;
    w.unlock(); // allow interrupts
    boolean completedAbruptly = true;
    try &#123;
        // task 为空的情况：
        // 1：任务入队列了，极限情况下，发现没有运行的线程，于是新增一个线程；
        // 2：线程执行完任务执行，再次回到 while 循环。
        // 如果 task 为空，会使用 getTask 方法阻塞从队列中拿数据，如果拿不到数据，会阻塞住
        while (task != null || (task = getTask()) != null) &#123;
            //锁住 worker
            w.lock();
            // 线程池 stop 中,但是线程没有到达中断状态，帮助线程中断
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &amp;&amp;
                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;
                !wt.isInterrupted())
                wt.interrupt();
            try &#123;
                //执行 before 钩子函数
                beforeExecute(wt, task);
                Throwable thrown = null;
                try &#123;
                    //同步执行任务
                    task.run();
                &#125; catch (RuntimeException x) &#123;
                    thrown = x; throw x;
                &#125; catch (Error x) &#123;
                    thrown = x; throw x;
                &#125; catch (Throwable x) &#123;
                    thrown = x; throw new Error(x);
                &#125; finally &#123;
                    //执行 after 钩子函数,如果这里抛出异常，会覆盖 catch 的异常
                    //所以这里异常最好不要抛出来
                    afterExecute(task, thrown);
                &#125;
            &#125; finally &#123;
                //任务执行完成，计算解锁
                task = null;
                w.completedTasks++;
                w.unlock();
            &#125;
        &#125;
        completedAbruptly = false;
    &#125; finally &#123;
        //做一些抛出异常的善后工作
        processWorkerExit(w, completedAbruptly);
    &#125;
&#125;
</code></pre>
<pre><code class="language-java">/**
 * run 方法可以直接被调用
 * 也可以由线程池进行调用
 */
public void run() &#123;
    // 状态不是任务创建，或者当前任务已经有线程在执行了
    if (state != NEW ||
        !UNSAFE.compareAndSwapObject(this, runnerOffset,
                                     null, Thread.currentThread()))
        return;
    try &#123;
        Callable&lt;V&gt; c = callable;
        // Callable 不为空，并且已经初始化完成
        if (c != null &amp;&amp; state == NEW) &#123;
            V result;
            boolean ran;
            try &#123;
                // 调用执行
                result = c.call();
                ran = true;
            &#125; catch (Throwable ex) &#123;
                result = null;
                ran = false;
                setException(ex);
            &#125;
            // 给 outcome 赋值
            if (ran)
                set(result);
        &#125;
    &#125; finally &#123;
        // runner must be non-null until state is settled to
        // prevent concurrent calls to run()
        runner = null;
        // state must be re-read after nulling runner to prevent
        // leaked interrupts
        int s = state;
        if (s &gt;= INTERRUPTING)
            handlePossibleCancellationInterrupt(s);
    &#125;
&#125;
</code></pre>
<p><strong>线程执行完任务之后：</strong></p>
<pre><code class="language-java">// 从阻塞队列中拿任务
private Runnable getTask() &#123;
    boolean timedOut = false; // Did the last poll() time out?
 
    for (;;) &#123;
        int c = ctl.get();
        int rs = runStateOf(c);
 
        //线程池关闭 &amp;&amp; 队列为空，不需要在运行了，直接放回
        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;
            decrementWorkerCount();
            return null;
        &#125;
 
        int wc = workerCountOf(c);
 
        // Are workers subject to culling?
        // true  运行的线程数大于 coreSize || 核心线程也可以被灭亡
        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;
 
        // 队列以 LinkedBlockingQueue 为例，timedOut 为 true 的话说明下面 poll 方法执行返回的是 null
        // 说明在等待 keepAliveTime 时间后，队列中仍然没有数据
        // 说明此线程已经空闲了 keepAliveTime 了
        // 再加上 wc &gt; 1 || workQueue.isEmpty() 的判断
        // 所以使用 compareAndDecrementWorkerCount 方法使线程池数量减少 1
        // 并且直接 return，return 之后，此空闲的线程会自动被回收
        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))
            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        &#125;
 
        try &#123;
            // 从队列中阻塞拿 worker
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            // 设置已超时，说明此时队列没有数据
            timedOut = true;
        &#125; catch (InterruptedException retry) &#123;
            timedOut = false;
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>常见问题</strong></p>
<p>父子任务使用一个线程池:</p>
<blockquote>
<p>向线程池中提交了一个任务，然后在这个任务的内部实现中又往同一个线程池中再次提交了一个任务，相当于父子任务在同一个线程池中执行，出现线程死锁也就是循环等待的情况。</p>
<p>父任务全部处于执行状态，这时候子任务想要执行需要等父任务执行完成，但是父任务都执行不完，因为还有个子任务没完成，即父任务等待子任务执行完成，而子任务等待父任务释放线程池资源，这也就造成了死锁。</p>
</blockquote>
<h1>并发工具类</h1>
<p><strong>Semaphore信号量</strong></p>
<p>信号量来控制那些需要限制并发访问量的资源。</p>
<blockquote>
<p>信号量会维护 许可证 的计数，而线程去访问共享资源前，必须先拿到许可证。</p>
<p>线程可以从信号量中去获取一个许可证，一旦线程获取之后，信号量持有的许可证就转移过去了，所以信号量手中剩余的许可证要减一。</p>
</blockquote>
<pre><code class="language-java">public class SemaphoreDemo &#123;

    static Semaphore semaphore = new Semaphore(3);

    public static void main(String[] args) &#123;
        ExecutorService service = Executors.newFixedThreadPool(50);
        for (int i = 0; i &lt; 1000; i++) &#123;
            service.submit(new Task());
        &#125;
        service.shutdown();
    &#125;

    static class Task implements Runnable &#123;

        @Override
        public void run() &#123;
            try &#123;
                semaphore.acquire();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            System.out.println(Thread.currentThread().getName() + &quot;拿到了许可证，花费2秒执行慢服务&quot;);
            try &#123;
                Thread.sleep(2000);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            System.out.println(&quot;慢服务执行完毕，&quot; + Thread.currentThread().getName() + &quot;释放了许可证&quot;);
            semaphore.release();
        &#125;
    &#125;
&#125;
</code></pre>
<p>信号量能被 FixedThreadPool 替代吗？</p>
<blockquote>
<p>如果在应用程序中会有不同类型的任务，它们也是通过不同的线程池来调用慢服务的。</p>
<p>因为信号量具有跨线程、跨线程池的特性，所以即便请求来自于不同的线程池，我们也可以限制它们的访问。</p>
<p>如果用 FixedThreadPool 去限制，那就做不到跨线程池限制了。</p>
</blockquote>
<p><strong>CountDownLatch</strong></p>
<blockquote>
<p>在创建实例的时候，在构造函数中传入倒数次数，然后由需要等待的线程去调用 await 方法开始等待，而每一次其他线程调用了 countDown 方法之后，计数便会减 1，直到减为 0 时，之前等待的线程便会继续运行。</p>
</blockquote>
<p>场景1：一个线程等待其他多个线程都执行完毕，再继续自己的工作:</p>
<blockquote>
<p>比如在比赛跑步时有 5 个运动员参赛，终点有一个裁判员，什么时候比赛结束呢？</p>
<ul>
<li>当所有人都跑到终点之后，这相当于裁判员等待 5 个运动员都跑到终点，宣布比赛结束。</li>
</ul>
</blockquote>
<pre><code class="language-java">public class RunDemo &#123;

    public static void main(String[] args) throws InterruptedException &#123;
        CountDownLatch latch = new CountDownLatch(5);
        ExecutorService service = Executors.newFixedThreadPool(5);
        for (int i = 0; i &lt; 5; i++) &#123;
            final int no = i + 1;
            Runnable runnable = new Runnable() &#123;

                @Override
                public void run() &#123;
                    try &#123;
                        Thread.sleep((long) (Math.random() * 10000));
                        System.out.println(no + &quot;号运动员完成了比赛。&quot;);
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125; finally &#123;
                        latch.countDown();
                    &#125;
                &#125;
            &#125;;
            service.submit(runnable);
        &#125;
        System.out.println(&quot;等待5个运动员都跑完.....&quot;);
        latch.await();
        System.out.println(&quot;所有人都跑完了，比赛结束。&quot;);
    &#125;
&#125;
</code></pre>
<p>场景2：多个线程等待某一个线程的信号，同时开始执行。</p>
<blockquote>
<p>比如在运动会上，在运动员起跑之前都会等待裁判员发号施令，一声令下运动员统一起跑。</p>
</blockquote>
<pre><code class="language-java">public class RunDemo &#123;

    public static void main(String[] args) throws InterruptedException &#123;
        System.out.println(&quot;运动员有5秒的准备时间&quot;);
        CountDownLatch countDownLatch = new CountDownLatch(1);
        ExecutorService service = Executors.newFixedThreadPool(5);
        for (int i = 0; i &lt; 5; i++) &#123;
            final int no = i + 1;
            Runnable runnable = new Runnable() &#123;
                @Override
                public void run() &#123;
                    System.out.println(no + &quot;号运动员准备完毕，等待裁判员的发令枪&quot;);
                    try &#123;
                        countDownLatch.await();
                        System.out.println(no + &quot;号运动员开始跑步了&quot;);
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
            &#125;;
            service.submit(runnable);
        &#125;
        Thread.sleep(5000);
        System.out.println(&quot;5秒准备时间已过，发令枪响，比赛开始！&quot;);
        countDownLatch.countDown();
    &#125;
&#125;
</code></pre>
<p><strong>CyclicBarrier</strong></p>
<blockquote>
<p>CyclicBarrier 构造出一个集结点，当某一个线程执行 await() 的时候，它就会到这个集结点开始等待，等待这个栅栏被撤销。</p>
<p>直到预定数量的线程都到了这个集结点之后，这个栅栏就会被撤销，之前等待的线程就在此刻统一出发，继续去执行剩下的任务。</p>
</blockquote>
<blockquote>
<p>假设班级春游去公园里玩，并且会租借三人自行车，每个人都可以骑，但由于这辆自行车是三人的，所以要凑齐三个人才能骑一辆。</p>
</blockquote>
<pre><code class="language-java">public class CyclicBarrierDemo &#123;

    public static void main(String[] args) &#123;
        CyclicBarrier cyclicBarrier = new CyclicBarrier(3);
        for (int i = 0; i &lt; 6; i++) &#123;
            new Thread(new Task(i + 1, cyclicBarrier)).start();
        &#125;
    &#125;

    static class Task implements Runnable &#123;

        private int id;
        private CyclicBarrier cyclicBarrier;

        public Task(int id, CyclicBarrier cyclicBarrier) &#123;
            this.id = id;
            this.cyclicBarrier = cyclicBarrier;
        &#125;

        @Override
        public void run() &#123;
            System.out.println(&quot;同学&quot; + id + &quot;现在从大门出发，前往自行车驿站&quot;);
            try &#123;
                Thread.sleep((long) (Math.random() * 10000));
                System.out.println(&quot;同学&quot; + id + &quot;到了自行车驿站，开始等待其他人到达&quot;);
                cyclicBarrier.await();
                System.out.println(&quot;同学&quot; + id + &quot;开始骑车&quot;);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125; catch (BrokenBarrierException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>LockSupport</strong></p>
<p><code>AQS</code>内部控制线程阻塞和唤醒是通过<code>LockSupport</code>来实现的。</p>
<pre><code class="language-java">@IntrinsicCandidate
public native void park(boolean isAbsolute, long time);

@IntrinsicCandidate
public native void unpark(Object thread);
</code></pre>
<p><strong>CopyOnWriteArrayList</strong></p>
<p>具有以下特征：</p>
<blockquote>
<p>线程安全的，多线程环境下可以直接使用，无需加锁。</p>
<p>通过锁 + 数组拷贝 + volatile 关键字保证了线程安全。</p>
<ul>
<li>volatile：值被修改后，其它线程能够立马感知最新值。</li>
</ul>
<p>每次数组操作，都会把数组拷贝一份出来，在新数组上进行操作，操作成功之后再赋值回去。</p>
</blockquote>
<p>CopyOnWriteArrayList数据结构和ArrayList是一致的，底层是个数组，只不过CopyOnWriteArrayList在对数组进行操作的时候。</p>
<p>基本会分四步走:</p>
<blockquote>
<p>1、加锁。</p>
<p>2、从原数组中拷贝出新数组。</p>
<p>3、在新数组上进行操作，并把新数组复制给数组容器。</p>
<p>4、解锁。</p>
</blockquote>
<p>新增：</p>
<pre><code class="language-java">// 添加元素到数组尾部
public boolean add(E e) &#123;
    final ReentrantLock lock = this.lock;
    // 加锁
    lock.lock();
    try &#123;
        // 得到所有的原数组
        Object[] elements = getArray();
        int len = elements.length;
        // 拷贝到新数组里面，新数组的长度是 + 1 的，因为新增会多一个元素
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        // 在新数组中进行赋值，新元素直接放在数组的尾部
        newElements[len] = e;
        // 替换掉原来的数组
        setArray(newElements);
        return true;
    // finally 里面释放锁，保证即使 try 发生了异常，仍然能够释放锁   
    &#125; finally &#123;
        lock.unlock();
    &#125;
&#125;
</code></pre>
<p>适用场景：</p>
<blockquote>
<p>读多写少的场景很适合使用 CopyOnWrite 集合。</p>
</blockquote>
<p>缺点:</p>
<blockquote>
<p><strong>内存占用问题</strong></p>
<ul>
<li>因为 CopyOnWrite 的写时复制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，这一点会占用额外的内存空间。</li>
</ul>
<p><strong>在元素较多或者复杂的情况下，复制的开销很大</strong></p>
<ul>
<li>复制过程不仅会占用双倍内存，还要消耗 CPU 等资源，会降低整体性能。</li>
</ul>
<p><strong>数据一致性问题</strong></p>
<ul>
<li>CopyOnWrite 容器的修改是先修改副本，所以这次修改对于其他线程来说，并不是实时能看到的，只有在修改完后才能体现出来。</li>
</ul>
</blockquote>
<h2 id="AQS">AQS</h2>
<p><code>AQS</code>定义了一套多线程访问共享资源的同步模板，解决了实现同步器时涉及的大量细节问题，能够极大地减少实现工作。</p>
<blockquote>
<p>三部分组成：</p>
<ul>
<li><code>state</code>同步状态、<code>Node</code>组成的<code>CLH</code>队列、<code>ConditionObject</code>条件变量（<strong>包含<code>Node</code>组成的条件单向队列</strong>）</li>
</ul>
</blockquote>
<p><img src="/images/198.png" alt="image-20231018135610476"></p>
<p><strong>整体流程</strong></p>
<p><img src="/images/199.png" alt="image-20231018192938937"></p>
<p><strong>使用 AQS 来写一个自己的线程协作工具类</strong></p>
<blockquote>
<p>1、新建一个线程协作工具类，在内部写一个 Sync 类，该 Sync 类继承 AbstractQueuedSynchronizer，即 AQS。</p>
<p>2、在 Sync 类里，根据是否是独占，来重写对应的方法。</p>
<ul>
<li>如果是独占，则重写 tryAcquire 和 tryRelease 等方法。</li>
<li>如果是非独占，则重写 tryAcquireShared 和 tryReleaseShared 等方法。</li>
</ul>
<p>3、在自己的线程协作工具类中，实现获取/释放的相关方法，并在里面调用 AQS 对应的方法，如果是独占则调用 acquire 或 release 等方法，非独占则调用 acquireShared 或 <code>releaseShared</code> 或 <code>acquireSharedInterruptibly</code> 等方法。</p>
</blockquote>
<p><strong>同步状态</strong></p>
<blockquote>
<p>在<code>AQS</code>中维护了一个同步状态变量<code>state</code>，获取、释放资源是否成功都是由<code>state</code>决定的，比如<code>state&gt;0</code>代表可获取资源，否则无法获取。</p>
<p><code>state</code>的具体语义由实现者去定义，<code>ReentrantLock、ReentrantReadWriteLock、Semaphore、CountDownLatch</code>定义的<code>state</code>语义都不一样。</p>
<ul>
<li>
<p><code>ReentrantLock</code>的<code>state</code>用来表示是否有锁资源。</p>
</li>
<li>
<p><code>ReentrantReadWriteLock</code>的<code>state</code>高<code>16</code>位代表读锁状态，低<code>16</code>位代表写锁状态。</p>
</li>
<li>
<p><code>Semaphore</code>的<code>state</code>用来表示可用信号的个数。</p>
</li>
<li>
<p><code>CountDownLatch</code>的<code>state</code>用来表示计数器的值。</p>
</li>
</ul>
</blockquote>
<p><strong>CLH队列</strong></p>
<blockquote>
<p><code>CLH</code>是<code>AQS</code>内部维护的<code>FIFO</code>（<strong>先进先出</strong>）双端双向队列（<strong>方便尾部节点插入</strong>），基于链表数据结构，当一个线程竞争资源失败，就会将等待资源的线程封装成一个<code>Node</code>节点，通过<code>CAS</code>原子操作插入队列尾部，最终不同的<code>Node</code>节点连接组成了一个<code>CLH</code>队列。</p>
<ul>
<li>先进先出保证了公平性。</li>
<li>非阻塞的队列，通过自旋锁和<code>CAS</code>保证节点插入和移除的原子性，实现无锁快速插入。</li>
<li>采用了自旋锁思想，所以<code>CLH</code>也是一种基于链表的可扩展、高性能、公平的自旋锁。</li>
</ul>
</blockquote>
<p><strong>Node内部类</strong></p>
<blockquote>
<p><code>Node</code>是<code>AQS</code>的内部类，每个等待资源的线程都会封装成<code>Node</code>节点组成<code>CLH</code>队列、等待队列。</p>
<p>线程获取资源失败，封装成<code>Node</code>节点从<code>CLH</code>队列尾部入队并阻塞线程，某线程释放资源时会把<code>CLH</code>队列首部<code>Node</code>节点关联的线程唤醒，再次获取资源。</p>
</blockquote>
<p><img src="/images/200.png" alt="image-20231018142402280"></p>
<blockquote>
<p>在<code>AQS</code>中提供<code>addWaiter</code>函数完成<code>Node</code>节点的创建与入队。</p>
</blockquote>
<pre><code class="language-java">private Node addWaiter(Node mode) &#123;
        //根据当前线程创建节点，等待状态为0
        Node node = new Node(Thread.currentThread(), mode);
        // 获取尾节点
        Node pred = tail;
        if (pred != null) &#123;
            //如果尾节点不等于null，把当前节点的前驱节点指向尾节点
            node.prev = pred;
            //通过cas把尾节点指向当前节点
            if (compareAndSetTail(pred, node)) &#123;
                //之前尾节点的下个节点指向当前节点
                pred.next = node;
                return node;
            &#125;
        &#125;
        //如果添加失败或队列不存在，执行end函数
        enq(node);
        return node;
    &#125;
</code></pre>
<blockquote>
<p>添加节点的时候，如果从<code>CLH</code>队列已经存在，通过<code>CAS</code>快速将当前节点添加到队列尾部，如果添加失败或队列不存在，则指向<code>enq</code>函数自旋入队。</p>
<ul>
<li>通过自旋<code>CAS</code>尝试往队列尾部插入节点，直到成功，自旋过程如果发现<code>CLH</code>队列不存在时会初始化<code>CLH</code>队列。</li>
</ul>
</blockquote>
<pre><code class="language-java">    private Node enq(final Node node) &#123;
        for (;;) &#123; //循环
            //获取尾节点
            Node t = tail;
            if (t == null) &#123;
                //如果尾节点为空，创建哨兵节点，通过cas把头节点指向哨兵节点
                if (compareAndSetHead(new Node()))
                    //cas成功，尾节点指向哨兵节点
                    tail = head;
            &#125; else &#123;
                //当前节点的前驱节点设指向之前尾节点
                node.prev = t;
                //cas设置把尾节点指向当前节点
                if (compareAndSetTail(t, node)) &#123;
                    //cas成功，之前尾节点的下个节点指向当前节点
                    t.next = node;
                    return t;
                &#125;
            &#125;
        &#125;
    &#125;
</code></pre>
<p><strong>条件变量</strong></p>
<blockquote>
<p><code>Object</code>的<code>wait、notify</code>函数是配合<code>Synchronized</code>锁实现线程间同步协作的功能，<code>AQS</code>的<code>ConditionObject</code>条件变量，则通过<code>ConditionObject</code>的<code>await</code>和<code>signal</code>两类函数完成。</p>
<ul>
<li>不同于<code>Synchronized</code>锁，一个<code>AQS</code>可以对应多个条件变量，而<code>Synchronized</code>只有一个。</li>
</ul>
<p><code>ConditionObject</code>内部维护着一个单向条件队列，不同于<code>CLH</code>队列，条件队列只入队执行<code>await</code>的线程节点，并且加入条件队列的节点，不能在<code>CLH</code>队列， 条件队列出队的节点，会入队到<code>CLH</code>队列。</p>
<p>当某个线程执行了<code>ConditionObject</code>的<code>await</code>函数，阻塞当前线程，线程会被封装成<code>Node</code>节点添加到条件队列的末端，其他线程执行<code>ConditionObject</code>的<code>signal</code>函数，会将条件队列头部线程节点转移到<code>CLH</code>队列参与竞争资源。</p>
</blockquote>
<p><img src="/images/201.png" alt="image-20231018142940365"></p>
<p><img src="/images/202.png" alt="image-20231018192059833"></p>
<p><code>AQS</code>采用了模板方法设计模式，提供了两类模板，一类是独占式模板，另一类是共享形模式。</p>
<p><strong>独占式获取资源</strong></p>
<blockquote>
<p><code>acquire</code>模板函数，模板流程：</p>
<ul>
<li>线程获取共享资源，如果获取资源成功，线程直接返回，否则进入<code>CLH</code>队列，直到获取资源成功为止，且整个过程忽略中断的影响。</li>
</ul>
<p>执行<code>tryAcquire</code>函数，<code>tryAcquire</code>是由子类实现，代表获取资源是否成功，如果资源获取失败，执行下面的逻辑。</p>
<p>执行<code>addWaiter</code>函数，根据当前线程创建出独占式节点，并入队<code>CLH</code>队列。</p>
<p>执行<code>acquireQueued</code>函数，自旋阻塞等待获取资源。</p>
<p>如果<code>acquireQueued</code>函数中获取资源成功，根据线程是否被中断状态，来决定执行线程中断逻辑。</p>
</blockquote>
<p><img src="/images/203.png" alt="image-20231018192408391"></p>
<pre><code class="language-java">    final boolean acquireQueued(final Node node, int arg) &#123;
        //异常状态，默认是
        boolean failed = true;
        try &#123;
            //该线程是否中断过，默认否
            boolean interrupted = false;
            for (;;) &#123;//自旋
                //获取前驱节点
                final Node p = node.predecessor();
                //如果前驱节点是首节点，获取资源（子类实现）
                if (p == head &amp;&amp; tryAcquire(arg)) &#123;
                    //获取资源成功，设置当前节点为头节点，清空当前节点的信息，把当前节点变成哨兵节点
                    setHead(node);
                    //原来首节点下个节点指向为null
                    p.next = null; // help GC
                    //非异常状态，防止指向finally逻辑
                    failed = false;
                    //返回线程中断状态
                    return interrupted;
                &#125;
                /**
                 * 如果前驱节点不是首节点，先执行shouldParkAfterFailedAcquire函数，shouldParkAfterFailedAcquire做了三件事
                 * 1.如果前驱节点的等待状态是SIGNAL，返回true，执行parkAndCheckInterrupt函数，返回false
                 * 2.如果前驱节点的等大状态是CANCELLED，把CANCELLED节点全部移出队列（条件节点）
                 * 3.以上两者都不符合，更新前驱节点的等待状态为SIGNAL，返回false
                 */
                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    //使用LockSupport类的静态方法park挂起当前线程，直到被唤醒，唤醒后检查当前线程是否被中断，返回该线程中断状态并重置中断状态
                    parkAndCheckInterrupt())
                    //该线程被中断过
                    interrupted = true;
                &#125;
            &#125; finally &#123;
                // 尝试获取资源失败并执行异常，取消请求，将当前节点从队列中移除
                if (failed)
                    cancelAcquire(node);
            &#125;
    &#125;
</code></pre>
<p><strong>独占式释放资源</strong></p>
<blockquote>
<p><code>AQS</code>中提供了<code>release</code>模板函数来释放资源，模板流程就是线程释放资源成功，唤醒<code>CLH</code>队列的第二个线程节点（<strong>首节点的下个节点</strong>）。</p>
</blockquote>
<pre><code class="language-java">    public final boolean release(int arg) &#123;

        if (tryRelease(arg)) &#123;//释放资源成功，tryRelease子类实现
            //获取头部线程节点
            Node h = head;
            if (h != null &amp;&amp; h.waitStatus != 0) //头部线程节点不为null，并且等待状态不为0
                //唤醒CHL队列第二个线程节点
                unparkSuccessor(h);
            return true;
        &#125;
        return false;
    &#125;
    
    
    private void unparkSuccessor(Node node) &#123;
        //获取节点等待状态
        int ws = node.waitStatus;
        if (ws &lt; 0)
            //cas更新节点状态为0
            compareAndSetWaitStatus(node, ws, 0);
    
        //获取下个线程节点        
        Node s = node.next;
        if (s == null || s.waitStatus &gt; 0) &#123; //如果下个节点信息异常，从尾节点循环向前获取到正常的节点为止，正常情况不会执行
            s = null;
            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
                if (t.waitStatus &lt;= 0)
                    s = t;
        &#125;
        if (s != null)
            //唤醒线程节点
            LockSupport.unpark(s.thread);
        &#125;
    &#125;
</code></pre>
<p><strong>共享式获取资源</strong></p>
<blockquote>
<p><code>acquireShared</code>模板流程就是线程获取共享资源，如果获取到资源，线程直接返回，否则进入<code>CLH</code>队列，直到获取到资源为止，且整个过程忽略中断的影响。</p>
</blockquote>
<pre><code class="language-java">    public final void acquireShared(int arg) &#123;
        /**
         * 1.负数表示失败
         * 2.0表示成功，但没有剩余可用资源
         * 3.正数表示成功且有剩余资源
         */
        if (tryAcquireShared(arg) &lt; 0) //获取资源失败，tryAcquireShared子类实现
            //自旋阻塞等待获取资源
            doAcquireShared(arg);
    &#125;
</code></pre>
<p><strong>共享式释放资源</strong></p>
<blockquote>
<p><code>AQS</code>中提供了<code>releaseShared</code>模板函数来释放资源，模板流程就是线程释放资源成功，唤醒CHL队列的第二个线程节点（<strong>首节点的下个节点</strong>。</p>
</blockquote>
<pre><code class="language-java">    public final boolean releaseShared(int arg) &#123;
        if (tryReleaseShared(arg)) &#123;//释放资源成功，tryReleaseShared子类实现
            //唤醒后继节点
            doReleaseShared();
            return true;
        &#125;
        return false;
    &#125;
    
    private void doReleaseShared() &#123;
        for (;;) &#123;
            //获取头节点
            Node h = head;
            if (h != null &amp;&amp; h != tail) &#123;
                int ws = h.waitStatus;
    
                if (ws == Node.SIGNAL) &#123;//如果头节点等待状态为SIGNAL
                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))//更新头节点等待状态为0
                        continue;            // loop to recheck cases
                    //唤醒头节点下个线程节点
                    unparkSuccessor(h);
                &#125;
                //如果后继节点暂时不需要被唤醒，更新头节点等待状态为PROPAGATE
                else if (ws == 0 &amp;&amp;
                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                    continue;               
            &#125;
            if (h == head)              
                break;
        &#125;
    &#125;
</code></pre>
<h2 id="ReentrantLock">ReentrantLock</h2>
<p><code>ReentrantLock</code>是可重入的互斥锁。</p>
<p><code>ReentrantLock</code>底层基于<code>AbstractQueuedSynchronizer</code>实现。</p>
<p><strong>整体结构</strong></p>
<blockquote>
<p><code>ReentrantLock</code>内部定义了专门的组件<code>Sync</code>，<code>Sync</code>继承<code>AbstractQueuedSynchronizer</code>提供释放资源的实现，<code>NonfairSync</code>和<code>FairSync</code>是基于<code>Sync</code>扩展的子类，即<code>ReentrantLock</code>的非公平模式与公平模式，它们作为<code>Lock</code>接口功能的基本实现。</p>
</blockquote>
<p><img src="/images/204.png" alt="image-20231017180401150"></p>
<blockquote>
<p>在<code>ReentrantLock</code>中，它对<code>AbstractQueuedSynchronizer</code>的<code>state</code>状态值定义为线程获取该锁的重入次数，<code>state</code>状态值为<code>0</code>表示当前没有被任何线程持有，<code>state</code>状态值为<code>1</code>表示被其他线程持有，因为支持可重入，如果是持有锁的线程，再次获取同一把锁，直接成功，并且<code>state</code>状态值<code>+1</code>，线程释放锁<code>state</code>状态值<code>-1</code>，同理重入多次锁的线程，需要释放相应的次数。</p>
</blockquote>
<p><strong>Sync</strong></p>
<p><code>Sync</code>继承了<code>AbstractQueuedSynchronizer</code>，是<code>ReentrantLock</code>的核心，<code>NonfairSync</code>与<code>FairSync</code>都是基于<code>Sync</code>扩展出来的子类。</p>
<blockquote>
<p><code>Sync</code>实现了<code>AQS</code>类的释放资源（<code>tryRelease</code>），然后抽象了一个获取锁的函数（lock）让子类自行实现。</p>
</blockquote>
<pre><code class="language-java">
abstract static class Sync extends AbstractQueuedSynchronizer &#123;
        private static final long serialVersionUID = -5179523762034025860L;

        /**
         * 获取锁-子类实现
         */
        abstract void lock();

        /**
         * 非公平-获取资源
         */
        final boolean nonfairTryAcquire(int acquires) &#123;
            //获取当前线程
            final Thread current = Thread.currentThread();
            //获取当前状态
            int c = getState();
            if (c == 0) &#123; // state==0 代表资源可获取
                //cas设置state为acquires，acquires传入的是1
                if (compareAndSetState(0, acquires)) &#123;
                    //cas成功，设置当前持有锁的线程
                    setExclusiveOwnerThread(current);
                    //返回成功
                    return true;
                &#125;
            &#125;
            else if (current == getExclusiveOwnerThread()) &#123; //如果state!=0,但是当前线程是持有锁线程，直接重入
                //state状态+1
                int nextc = c + acquires;
                if (nextc &lt; 0) // overflow
                    throw new Error(&quot;Maximum lock count exceeded&quot;);
                //设置state状态，此处不需要cas，因为持有锁的线程只有一个    
                setState(nextc);
                //返回成功
                return true;
            &#125;
            //返回失败
            return false;
        &#125;
        
        /**
         * 释放资源
         */
        protected final boolean tryRelease(int releases) &#123;
            //state状态-releases，releases传入的是1
            int c = getState() - releases;
            if (Thread.currentThread() != getExclusiveOwnerThread()) //如果当前线程不是持有锁线程，抛出异常
                throw new IllegalMonitorStateException();
            //设置返回状态，默认为失败
            boolean free = false;
            if (c == 0) &#123;//state-1后，如果c==0代表释放资源成功
                //返回状态设置为true
                free = true;
                //清空持有锁线程
                setExclusiveOwnerThread(null);
            &#125;
            //如果state-1后，state还是&gt;0，代表当前线程有锁重入操作，需要做相应的释放次数，设置state值
            setState(c);
            return free;
        &#125;
&#125;        
</code></pre>
<p><code>tryRelease</code>流程：</p>
<img src="/images/205.png" alt="image-20231017181031803" style="zoom:100%;" />
<p><strong>NonfairSync</strong></p>
<blockquote>
<p>在<code>ReentrantLock</code>中支持两种获取锁的策略，分别是非公平策略与公平策略，<code>NonfairSync</code>就是非公平策略。</p>
</blockquote>
<blockquote>
<p><code>NonfairSync</code>继承<code>Sync</code>实现了<code>lock</code>函数，<code>CAS</code>设置状态值<code>state</code>为<code>1</code>代表获取锁成功，否则执行<code>AQS</code>的<code>acquire</code>函数（<strong>获取锁模板</strong>）。</p>
<p>另外<code>NonfairSync</code>还实现了<code>AQS</code>留给子类实现的<code>tryAcquire</code>函数（<strong>获取资源</strong>），直接使用<code>Sync</code>提供的<code>nonfairTryAcquire</code>函数来实现<code>tryAcquire</code>，最后子类实现的<code>tryAcquire</code>函数在<code>AQS</code>的<code>acquire</code>函数中被使用。</p>
</blockquote>
<pre><code class="language-java">    static final class NonfairSync extends Sync &#123;
        private static final long serialVersionUID = 7316153563782823691L;

        /**
         * 获取锁
         */
        final void lock() &#123;
            if (compareAndSetState(0, 1))//cas设置state为1成功，代表获取资源成功    
                //资源获取成功，设置当前线程为持有锁线程
                setExclusiveOwnerThread(Thread.currentThread());
            else
                //cas设置state为1失败，代表获取资源失败，执行AQS获取锁模板流程，否获取资源成功
                acquire(1);
        &#125;
        
        /**
         * 获取资源-使用的是Sync提供的nonfairTryAcquire函数
         */
        protected final boolean tryAcquire(int acquires) &#123;
            return nonfairTryAcquire(acquires);
        &#125;
    &#125;
    
    /**
     * AQS获取锁模板函数，这是AQS类中的函数
     */
    public final void acquire(int arg) &#123;
        /**
         * 我们只需要关注tryAcquire函数，后面的函数是AQS获取资源失败，线程节点进入CLH队列的细节流程，本文不关注
         */
        if (!tryAcquire(arg) &amp;&amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    &#125;
</code></pre>
<p>当前线程查看资源是否可获取：</p>
<blockquote>
<p>可获取，尝试使用<code>CAS</code>设置<code>state</code>为<code>1</code>，<code>CAS</code>成功代表获取资源成功，否则获取资源失败。</p>
<p>不可获取，判断当线程是不是持有锁的线程，如果是，<code>state</code>重入计数，获取资源成功，否则获取资源失败。</p>
</blockquote>
<p><img src="/images/206.png" alt="image-20231017181634485"></p>
<pre><code class="language-java">    /**
     * 非公平-获取资源
     */
    final boolean nonfairTryAcquire(int acquires) &#123;
        //获取当前线程
        final Thread current = Thread.currentThread();
        //获取当前状态
        int c = getState();
        if (c == 0) &#123; // state==0 代表资源可获取
            //cas设置state为acquires，acquires传入的是1
            if (compareAndSetState(0, acquires)) &#123;
                //cas成功，设置当前持有锁的线程
                setExclusiveOwnerThread(current);
                //返回成功
                return true;
            &#125;
        &#125;
        //如果state!=0,但是当前线程是持有锁线程，直接重入
        else if (current == getExclusiveOwnerThread()) &#123;
            //state状态+1
            int nextc = c + acquires;
            if (nextc &lt; 0) // overflow
                throw new Error(&quot;Maximum lock count exceeded&quot;);
            //设置state状态，此处不需要cas，因为持有锁的线程只有一个    
            setState(nextc);
            //返回成功
            return true;
        &#125;
        //返回失败
        return false;
    &#125;
</code></pre>
<p><strong>FairSync</strong></p>
<blockquote>
<p><code>FairSync</code>流程与<code>NonfairSync</code>基本一致，唯一的区别就是在<code>CAS</code>执行前，多了一步<code>hasQueuedPredecessors</code>函数，这一步就是判断当前线程是不是<code>CLH</code>队列被唤醒的线程，如果是就执行<code>CAS</code>，否则获取资源失败。</p>
</blockquote>
<p><img src="/images/207.png" alt="image-20231017181804586"></p>
<pre><code class="language-java">
static final class FairSync extends Sync &#123;
        private static final long serialVersionUID = -3000897897090466540L;
        
        /**
         * 获取锁
         */
        final void lock() &#123;
        //cas设置state为1失败，代表获取资源失败，执行AQS获取锁模板流程，否获取资源成功
            acquire(1);
        &#125;

        /**
         * 获取资源
         */
        protected final boolean tryAcquire(int acquires) &#123;
            //获取当前线程
            final Thread current = Thread.currentThread();
            //获取state状态
            int c = getState();
            if (c == 0) &#123; // state==0 代表资源可获取
                //1.hasQueuedPredecessors判断当前线程是不是CLH队列被唤醒的线程，如果是执行下一个步骤
               //2.cas设置state为acquires，acquires传入的是1
                if (!hasQueuedPredecessors() &amp;&amp;
                    compareAndSetState(0, acquires)) &#123;
                    //cas成功，设置当前持有锁的线程
                    setExclusiveOwnerThread(current);
                    //返回成功
                    return true;
                &#125;
            &#125;
            //如果state!=0,但是当前线程是持有锁线程，直接重入
            else if (current == getExclusiveOwnerThread()) &#123;
                //state状态+1
                int nextc = c + acquires;
                if (nextc &lt; 0)
                    throw new Error(&quot;Maximum lock count exceeded&quot;);
                //设置state状态，此处不需要cas，因为持有锁的线程只有一个 
                setState(nextc);
                //返回成功
                return true;
            &#125;
            return false;
        &#125;
    &#125;

    /**
     * AQS获取锁模板函数，这是AQS类中的函数
     */
    public final void acquire(int arg) &#123;
        /**
         * 我们只需要关注tryAcquire函数，后面的函数是AQS获取资源失败，线程节点进入CLH队列的细节流程，本文不关注
         */
        if (!tryAcquire(arg) &amp;&amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    &#125;
</code></pre>
<p><strong>Lock的实现</strong></p>
<pre><code class="language-java">    //同步器
    private final Sync sync;
    
    //默认使用非公平策略
    public ReentrantLock() &#123;
        sync = new NonfairSync();
    &#125;

    //true-公平策略 false非公平策略
    public ReentrantLock(boolean fair) &#123;
        sync = fair ? new FairSync() : new NonfairSync();
    &#125;
</code></pre>
<pre><code class="language-java">public class ReentrantLock implements Lock, java.io.Serializable &#123;
    private static final long serialVersionUID = 7373984872572414699L;
    //同步器
    private final Sync sync;

    //默认使用非公平策略
    public ReentrantLock() &#123;
        sync = new NonfairSync();
    &#125;

    //true-公平策略 false非公平策略
    public ReentrantLock(boolean fair) &#123;
        sync = fair ? new FairSync() : new NonfairSync();
    &#125;

    /**
     * 获取锁-阻塞
     */
    public void lock() &#123;
        //基于sync实现
        sync.lock();
    &#125;

    /**
     * 获取锁-阻塞，支持响应线程中断
     */
    public void lockInterruptibly() throws InterruptedException &#123;
        //基于sync实现
        sync.acquireInterruptibly(1);
    &#125;

    /**
     * 获取资源，返回是否成功状态-非阻塞
     */
    public boolean tryLock() &#123;
        //基于sync实现
        return sync.nonfairTryAcquire(1);
    &#125;

    /**
     * 获取锁-阻塞，支持超时 
     */
    public boolean tryLock(long timeout, TimeUnit unit)
            throws InterruptedException &#123;
        //基于sync实现    
        return sync.tryAcquireNanos(1, unit.toNanos(timeout));
    &#125;

    /**
     * 释放锁
     */
    public void unlock() &#123;
        //基于sync实现
        sync.release(1);
    &#125;

    /**
     * 创建条件变量
     */
    public Condition newCondition() &#123;
        //基于sync实现
        return sync.newCondition();
    &#125;

&#125;
</code></pre>
<h2 id="ConcurrentHashMap">ConcurrentHashMap</h2>
<p>ConcurrentHashMap 是一个存储 <code>key/value</code> 对的容器，并且是线程安全的。</p>
<p><img src="/images/208.png" alt="image-20231017182254278"></p>
<p><strong>ConcurrentHashMap和HashMap：</strong></p>
<p>相同之处：</p>
<blockquote>
<p>数组、链表结构几乎相同，所以底层对数据结构的操作思路是相同的（只是思路相同，底层实现不同）。</p>
<p>都实现了 Map 接口，继承了 AbstractMap 抽象类，所以大多数的方法也都是相同的，HashMap 有的方法，ConcurrentHashMap 几乎都有，所以当我们需要从 HashMap 切换到 ConcurrentHashMap 时，无需关心两者之间的兼容问题。</p>
</blockquote>
<p>不同之处：</p>
<blockquote>
<p>红黑树结构略有不同，HashMap 的红黑树中的节点叫做 TreeNode，TreeNode 不仅仅有属性，还维护着红黑树的结构，比如说查找，新增等等；ConcurrentHashMap 中红黑树被拆分成两块，TreeNode 仅仅维护的属性和查找功能，新增了 TreeBin，来维护红黑树结构，并负责根节点的加锁和解锁。</p>
<p>新增 ForwardingNode （转移）节点，扩容的时候会使用到，通过使用该节点，来保证扩容时的线程安全。</p>
</blockquote>
<p><strong>重要属性</strong></p>
<pre><code class="language-java">//这个Node数组就是ConcurrentHashMap用来存储数据的哈希表
transient volatile Node[] table
//这是默认的初始化哈希表数组大小
private static final int DEFAULT_CAPACITY = 16;
//转化为红黑树的链表长度阈值
static final int TREEIFY_THRESHOLD = 8
//这个标识位用于识别扩容时正在转移数据
static final int MOVED = -1
//计算哈希值时用到的参数，用来去除符号位
static final int HASH_BITS = 0x7fffffff;
//数据转移时，新的哈希表数组
private transient volatile Node[] nextTable;
</code></pre>
<p>Node:</p>
<blockquote>
<p>链表中的元素为Node对象。</p>
<p>链表上的一个节点，内部存储了key、value值，以及他的下一个节点的引用，这样一系列的Node就组成一个链表。</p>
</blockquote>
<p>ForwardingNode：</p>
<blockquote>
<p>当进行扩容时，要把链表迁移到新的哈希表，在做这个操作时，会在把数组中的头节点替换为ForwardingNode对象。</p>
<p>ForwardingNode中不保存key和value，只保存了扩容后哈希表（nextTable）的引用。</p>
<p>此时查找相应node时，需要去nextTable中查找。</p>
</blockquote>
<p>TreeBin</p>
<blockquote>
<p>当链表转为红黑树后，数组中保存的引用为 TreeBin，TreeBin 内部不保存 key/value，他保存了 TreeNode的list以及红黑树 root。</p>
</blockquote>
<p>TreeNode</p>
<blockquote>
<p>红黑树的节点。</p>
</blockquote>
<p><strong>Put方法</strong></p>
<blockquote>
<p>1、如果数组为空，初始化，初始化完成之后，走 2。</p>
<p>2、计算当前槽点有没有值，没有值的话，cas 创建，失败继续自旋（for 死循环），直到成功，槽点有值的话，走 3。</p>
<p>3、如果槽点是转移节点(正在扩容)，就会一直自旋等待扩容完成之后再新增，不是转移节点走 4。</p>
<p>4、槽点有值的，先锁定当前槽点，保证其余线程不能操作，如果是链表，新增值到链表的尾部，如果是红黑树，使用红黑树新增的方法新增；</p>
<p>5、新增完成之后 check 需不需要扩容，需要的话去扩容。</p>
</blockquote>
<pre><code class="language-java">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;
    if (key == null || value == null) throw new NullPointerException();
    //计算hash
    int hash = spread(key.hashCode());
    int binCount = 0;
    for (Node&lt;K,V&gt;[] tab = table;;) &#123;
        Node&lt;K,V&gt; f; int n, i, fh;
        //table是空的，进行初始化
        if (tab == null || (n = tab.length) == 0)
            tab = initTable();
        //如果当前索引位置没有值，直接创建
        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;
            //cas 在 i 位置创建新的元素，当 i 位置是空时，即能创建成功，结束for自循，否则继续自旋
            if (casTabAt(tab, i, null,
                         new Node&lt;K,V&gt;(hash, key, value, null)))
                break;                   // no lock when adding to empty bin
        &#125;
        //如果当前槽点是转移节点，表示该槽点正在扩容，就会一直等待扩容完成
        //转移节点的 hash 值是固定的，都是 MOVED
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        //槽点上有值的
        else &#123;
            V oldVal = null;
            //锁定当前槽点，其余线程不能操作，保证了安全
            synchronized (f) &#123;
                //这里再次判断 i 索引位置的数据没有被修改
                //binCount 被赋值的话，说明走到了修改表的过程里面
                if (tabAt(tab, i) == f) &#123;
                    //链表
                    if (fh &gt;= 0) &#123;
                        binCount = 1;
                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;
                            K ek;
                            //值有的话，直接返回
                            if (e.hash == hash &amp;&amp;
                                ((ek = e.key) == key ||
                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            &#125;
                            Node&lt;K,V&gt; pred = e;
                            //把新增的元素赋值到链表的最后，退出自旋
                            if ((e = e.next) == null) &#123;
                                pred.next = new Node&lt;K,V&gt;(hash, key,
                                                          value, null);
                                break;
                            &#125;
                        &#125;
                    &#125;
                    //红黑树，这里没有使用 TreeNode,使用的是 TreeBin，TreeNode 只是红黑树的一个节点
                    //TreeBin 持有红黑树的引用，并且会对其加锁，保证其操作的线程安全
                    else if (f instanceof TreeBin) &#123;
                        Node&lt;K,V&gt; p;
                        binCount = 2;
                        //满足if的话，把老的值给oldVal
                        //在putTreeVal方法里面，在给红黑树重新着色旋转的时候
                        //会锁住红黑树的根节点
                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                       value)) != null) &#123;
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        &#125;
                    &#125;
                &#125;
            &#125;
            //binCount不为空，并且 oldVal 有值的情况，说明已经新增成功了
            if (binCount != 0) &#123;
                // 链表是否需要转化成红黑树
                if (binCount &gt;= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                //这一步几乎走不到。槽点已经上锁，只有在红黑树或者链表新增失败的时候
                //才会走到这里，这两者新增都是自旋的，几乎不会失败
                break;
            &#125;
        &#125;
    &#125;
    //check 容器是否需要扩容，如果需要去扩容，调用 transfer 方法去扩容
    //如果已经在扩容中了，check有无完成
    addCount(1L, binCount);
    return null;
&#125;
</code></pre>
<p><strong>Get方法</strong></p>
<blockquote>
<p>先获取数组的下标，然后通过判断数组下标的 key 是否和我们的 key 相等，相等的话直接返回，如果下标的槽点是链表或红黑树的话，分别调用相应的查找数据的方法，整体思路和 HashMap 很像。</p>
</blockquote>
<pre><code class="language-java">public V get(Object key) &#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;
    //计算hashcode
    int h = spread(key.hashCode());
    //不是空的数组 &amp;&amp; 并且当前索引的槽点数据不是空的
    //否则该key对应的值不存在，返回null
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;
        //槽点第一个值和key相等，直接返回
        if ((eh = e.hash) == h) &#123;
            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))
                return e.val;
        &#125;
        //如果是红黑树或者转移节点，使用对应的find方法
        else if (eh &lt; 0)
            return (p = e.find(h, key)) != null ? p.val : null;
        //如果是链表，遍历查找
        while ((e = e.next) != null) &#123;
            if (e.hash == h &amp;&amp;
                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))
                return e.val;
        &#125;
    &#125;
    return null;
&#125;
</code></pre>
<p><strong>扩容</strong></p>
<blockquote>
<p>扩容的方法叫做 transfer，transfer 方法的主要思路是：</p>
<ul>
<li>
<p>首先需要把老数组的值全部拷贝到扩容之后的新数组上，先从数组的队尾开始拷贝。</p>
</li>
<li>
<p>拷贝数组的槽点时，先把原数组槽点锁住，保证原数组槽点不能操作，成功拷贝到新数组时，把原数组槽点赋值为转移节点。</p>
</li>
<li>
<p>这时如果有新数据正好需要 put 到此槽点时，发现槽点为转移节点，就会一直等待，所以在扩容完成之前，该槽点对应的数据是不会发生变化的。</p>
</li>
<li>
<p>从数组的尾部拷贝到头部，每拷贝成功一次，就把原数组中的节点设置成转移节点。</p>
</li>
<li>
<p>直到所有数组数据都拷贝到新数组时，直接把新数组整个赋值给数组容器，拷贝完成。</p>
</li>
</ul>
<p>扩容方法主要是通过在原数组上设置转移节点，put 时碰到转移节点时会等待扩容成功之后才能 put 的策略，来保证了整个扩容过程中肯定是线程安全的，因为数组的槽点一旦被设置成转移节点，在没有扩容完成之前，是无法进行操作的。</p>
</blockquote>
<pre><code class="language-java">// 扩容主要分 2 步，第一新建新的空数组，第二移动拷贝每个元素到新数组中去
// tab：原数组，nextTab：新数组
private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;
    // 老数组的长度
    int n = tab.length, stride;
    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)
        stride = MIN_TRANSFER_STRIDE; // subdivide range
    // 如果新数组为空，初始化，大小为原数组的两倍，n &lt;&lt; 1
    if (nextTab == null) &#123;            // initiating
        try &#123;
            @SuppressWarnings(&quot;unchecked&quot;)
            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];
            nextTab = nt;
        &#125; catch (Throwable ex) &#123;      // try to cope with OOME
            sizeCtl = Integer.MAX_VALUE;
            return;
        &#125;
        nextTable = nextTab;
        transferIndex = n;
    &#125;
    // 新数组的长度
    int nextn = nextTab.length;
    // 代表转移节点，如果原数组上是转移节点，说明该节点正在被扩容
    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);
    boolean advance = true;
    boolean finishing = false; // to ensure sweep before committing nextTab
    // 无限自旋，i 的值会从原数组的最大值开始，慢慢递减到 0
    for (int i = 0, bound = 0;;) &#123;
        Node&lt;K,V&gt; f; int fh;
        while (advance) &#123;
            int nextIndex, nextBound;
            // 结束循环的标志
            if (--i &gt;= bound || finishing)
                advance = false;
            // 已经拷贝完成
            else if ((nextIndex = transferIndex) &lt;= 0) &#123;
                i = -1;
                advance = false;
            &#125;
            // 每次减少 i 的值
            else if (U.compareAndSwapInt
                     (this, TRANSFERINDEX, nextIndex,
                      nextBound = (nextIndex &gt; stride ?
                                   nextIndex - stride : 0))) &#123;
                bound = nextBound;
                i = nextIndex - 1;
                advance = false;
            &#125;
        &#125;
        // if 任意条件满足说明拷贝结束了
        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123;
            int sc;
            // 拷贝结束，直接赋值，因为每次拷贝完一个节点，都在原数组上放转移节点，所以拷贝完成的节点的数据一定不会再发生变化。
            // 原数组发现是转移节点，是不会操作的，会一直等待转移节点消失之后在进行操作。
            // 也就是说数组节点一旦被标记为转移节点，是不会再发生任何变动的，所以不会有任何线程安全的问题
            // 所以此处直接赋值，没有任何问题。
            if (finishing) &#123;
                nextTable = null;
                table = nextTab;
                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);
                return;
            &#125;
            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;
                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)
                    return;
                finishing = advance = true;
                i = n; // recheck before commit
            &#125;
        &#125;
        else if ((f = tabAt(tab, i)) == null)
            advance = casTabAt(tab, i, null, fwd);
        else if ((fh = f.hash) == MOVED)
            advance = true; // already processed
        else &#123;
            synchronized (f) &#123;
                // 进行节点的拷贝
                if (tabAt(tab, i) == f) &#123;
                    Node&lt;K,V&gt; ln, hn;
                    if (fh &gt;= 0) &#123;
                        int runBit = fh &amp; n;
                        Node&lt;K,V&gt; lastRun = f;
                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;
                            int b = p.hash &amp; n;
                            if (b != runBit) &#123;
                                runBit = b;
                                lastRun = p;
                            &#125;
                        &#125;
                        if (runBit == 0) &#123;
                            ln = lastRun;
                            hn = null;
                        &#125;
                        else &#123;
                            hn = lastRun;
                            ln = null;
                        &#125;
                        // 如果节点只有单个数据，直接拷贝，如果是链表，循环多次组成链表拷贝
                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;
                            int ph = p.hash; K pk = p.key; V pv = p.val;
                            if ((ph &amp; n) == 0)
                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);
                            else
                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);
                        &#125;
                        // 在新数组位置上放置拷贝的值
                        setTabAt(nextTab, i, ln);
                        setTabAt(nextTab, i + n, hn);
                        // 在老数组位置上放上 ForwardingNode 节点
                        // put 时，发现是 ForwardingNode 节点，就不会再动这个节点的数据了
                        setTabAt(tab, i, fwd);
                        advance = true;
                    &#125;
                    // 红黑树的拷贝
                    else if (f instanceof TreeBin) &#123;
                        // 红黑树的拷贝工作，同 HashMap 的内容，代码忽略
                        …………
                        // 在老数组位置上放上 ForwardingNode 节点
                        setTabAt(tab, i, fwd);
                        advance = true;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>如何保证线程安全</strong></p>
<p>数组初始化时的线程安全:</p>
<blockquote>
<p>数组初始化时，首先通过自旋来保证一定可以初始化成功，然后通过 CAS 设置 SIZECTL 变量的值，来保证同一时刻只能有一个线程对数组进行初始化，CAS 成功之后，还会再次判断当前数组是否已经初始化完成，如果已经初始化完成，就不会再次初始化，通过自旋 + CAS + 双重 check 等手段保证了数组初始化时的线程安全。</p>
</blockquote>
<pre><code class="language-java">//初始化 table，通过对 sizeCtl 的变量赋值来保证数组只能被初始化一次
private final Node&lt;K,V&gt;[] initTable() &#123;
    Node&lt;K,V&gt;[] tab; int sc;
    //通过自旋保证初始化成功
    while ((tab = table) == null || tab.length == 0) &#123;
        // 小于 0 代表有线程正在初始化，释放当前 CPU 的调度权，重新发起锁的竞争
        if ((sc = sizeCtl) &lt; 0)
            Thread.yield(); // lost initialization race; just spin
        // CAS 赋值保证当前只有一个线程在初始化，-1 代表当前只有一个线程能初始化
        // 保证了数组的初始化的安全性
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;
            try &#123;
                // 很有可能执行到这里的时候，table 已经不为空了，这里是双重 check
                if ((tab = table) == null || tab.length == 0) &#123;
                    // 进行初始化
                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;
                    @SuppressWarnings(&quot;unchecked&quot;)
                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];
                    table = tab = nt;
                    sc = n - (n &gt;&gt;&gt; 2);
                &#125;
            &#125; finally &#123;
                sizeCtl = sc;
            &#125;
            break;
        &#125;
    &#125;
    return tab;
&#125;
</code></pre>
<p>新增槽点值时的线程安全:</p>
<blockquote>
<p>通过自旋死循环保证一定可以新增成功。</p>
<p>当前槽点为空时，通过 CAS 新增。</p>
<p>当前槽点有值，锁住当前槽点。</p>
<ul>
<li>put 时，如果当前槽点有值，就是 key 的 hash 冲突的情况，此时槽点上可能是链表或红黑树，我们通过锁住槽点，来保证同一时刻只会有一个线程能对槽点进行修改。</li>
</ul>
</blockquote>
<p><strong>ConcurrentHashMap在JDK1.7和JDK1.8的不同</strong></p>
<blockquote>
<p>数据结构:</p>
<ul>
<li>Java 7：采用 Segment 分段锁来实现。</li>
<li>Java 8：使用数组 + 链表 + 红黑树。</li>
</ul>
<p>并发度:</p>
<ul>
<li>Java 7：每个 Segment 独立加锁，最大并发个数就是 Segment 的个数，默认是 16。</li>
<li>Java 8 中：锁粒度更细，理想情况下 table 数组元素的个数(数组长度)就是其支持并发的最大个数，并发度比之前有提高。</li>
</ul>
<p>保证并发安全的原理：</p>
<ul>
<li>Java 7：采用 Segment 分段锁来保证安全，Segment 是继承自 ReentrantLock。</li>
<li>Java 8：采用 Node + CAS + Synchronized 保证线程安全。</li>
</ul>
<p>遇到 Hash 碰撞：</p>
<ul>
<li>
<p>Java 7：在 Hash 冲突时，会使用拉链法。</p>
</li>
<li>
<p>Java 8：先使用拉链法，在链表长度超过一定阈值时，将链表转换为红黑树，来提高查找效率。</p>
</li>
</ul>
<p>查询时间复杂度：</p>
<ul>
<li>
<p>Java 7：遍历链表的时间复杂度是 <code>O(n)</code>，n 为链表长度。</p>
</li>
<li>
<p>Java 8：如果变成遍历红黑树，那么时间复杂度降低为 <code>O(log(n))</code>，n 为树的节点个数。</p>
</li>
</ul>
</blockquote>
<h1>锁机制</h1>
<p><strong>锁分类</strong></p>
<p>偏向锁/轻量级锁/重量级锁：</p>
<blockquote>
<p>偏向锁:</p>
<ul>
<li>一个对象被初始化后，还没有任何线程来获取它的锁时，那么它就是可偏向的，当有第一个线程来访问它并尝试获取锁的时候，它就将这个线程记录下来，以后如果尝试获取锁的线程正是偏向锁的拥有者，就可以直接获得锁，开销很小，性能最好。</li>
</ul>
<p>轻量级锁:</p>
<ul>
<li>当锁原来是偏向锁的时候，被另一个线程访问，说明存在竞争，那么偏向锁就会升级为轻量级锁，线程会通过自旋的形式尝试获取锁，而不会陷入阻塞。</li>
</ul>
<p>重量级锁：</p>
<ul>
<li>重量级锁是互斥锁，它是利用操作系统的同步机制实现的，所以开销相对比较大。</li>
</ul>
<p><strong>当多个线程直接有实际竞争，且锁竞争时间长的时候，轻量级锁不能满足需求，锁就会膨胀为重量级锁。</strong></p>
<p><strong>重量级锁会让其他申请却拿不到锁的线程进入阻塞状态。</strong></p>
<p>性能对比：</p>
<ul>
<li>
<p>偏向锁性能最好，可以避免执行 CAS 操作。</p>
</li>
<li>
<p>轻量级锁利用自旋和 CAS 避免了重量级锁带来的线程阻塞和唤醒，性能中等。</p>
</li>
<li>
<p>重量级锁则会把获取不到锁的线程阻塞，性能最差。</p>
</li>
</ul>
</blockquote>
<p>可重入锁/非可重入锁：</p>
<blockquote>
<p>可重入锁：线程当前已经持有这把锁了，能在不释放这把锁的情况下，再次获取这把锁。</p>
<p>不可重入锁：虽然线程当前持有了这把锁，但是如果想再次获取这把锁，也必须要先释放锁后才能再次尝试获取。</p>
</blockquote>
<p>共享锁/独占锁：</p>
<blockquote>
<p>共享锁：同一把锁可以被多个线程同时获得。</p>
<p>独占锁：这把锁只能同时被一个线程获得。</p>
</blockquote>
<p>公平锁/非公平锁：</p>
<blockquote>
<p>公平锁：如果线程现在拿不到这把锁，那么线程就都会进入等待，开始排队，在等待队列里等待时间长的线程会优先拿到这把锁。</p>
<p>非公平锁：它会在一定情况下，忽略掉已经在排队的线程，发生插队现象。</p>
<ul>
<li>整体执行速度更快，吞吐量更大，但同时也可能产生线程饥饿问题。</li>
</ul>
</blockquote>
<p>悲观锁/乐观锁:</p>
<blockquote>
<p>悲观锁：在获取资源之前，必须先拿到锁，以便达到 独占 的状态，当前线程在操作资源的时候，其他线程由于不能拿到锁。</p>
<ul>
<li>适合用于<strong>并发写入多、临界区代码复杂、竞争激烈</strong>等场景，这种场景下悲观锁可以避免大量的无用的反复尝试等消耗。</li>
</ul>
<p>乐观锁：它并不要求在获取资源前拿到锁，也不会锁住资源。</p>
<ul>
<li>乐观锁利用 CAS 理念，在不独占资源的情况下，完成了对资源的修改。</li>
<li>适用于<strong>大部分是读取，少部分是修改</strong>的场景，也适合<strong>虽然读写都很多，但是并发并不激烈</strong>的场景。</li>
</ul>
</blockquote>
<p>自旋锁/非自旋锁：</p>
<blockquote>
<p>自旋锁：如果线程现在拿不到锁，并不直接陷入阻塞或者释放 CPU 资源，而是开始利用循环，不停地尝试获取锁。</p>
<ul>
<li>优点是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</li>
</ul>
<p>非自旋锁：如果拿不到锁就直接放弃，或者进行其他的处理逻辑，例如去排队、陷入阻塞等。</p>
</blockquote>
<p>可中断锁/不可中断锁：</p>
<blockquote>
<p>不可中断锁：一旦线程申请了锁，只能等到拿到锁以后才能进行其他的逻辑处理。</p>
<p>可中断锁：在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需要一直等到获取到锁才离开。</p>
</blockquote>
<p><strong>锁优化</strong></p>
<p>自适应的自旋锁：</p>
<blockquote>
<p>自旋的时间不再固定，而是会根据最近自旋尝试的成功率、失败率，以及当前锁的拥有者的状态等多种因素来共同决定。</p>
<ul>
<li>
<p>如果最近尝试自旋获取某一把锁成功了，那么下一次可能还会继续使用自旋，并且允许自旋更长的时间。</p>
</li>
<li>
<p>但是如果最近自旋获取某一把锁失败了，那么可能会省略掉自旋的过程，以便减少无用的自旋，提高效率。</p>
</li>
</ul>
</blockquote>
<p>锁消除：</p>
<pre><code class="language-java">@Override
public synchronized StringBuffer append(Object obj) &#123;
    toStringCache = null;
    super.append(String.valueOf(obj));
    return this;
&#125;
</code></pre>
<blockquote>
<p>如果编译器能确定这个 StringBuffer 对象只会在一个线程内被使用，就代表肯定是线程安全的，那么我们的编译器便会做出优化，把对应的 Synchronized 给消除，省去加锁和解锁的操作，以便增加整体的效率。</p>
</blockquote>
<p>锁粗化：</p>
<pre><code class="language-java">public void lockCoarsening() &#123;
    synchronized (this) &#123;
        //do something
    &#125;
    synchronized (this) &#123;
        //do something
    &#125;
    synchronized (this) &#123;
        //do something
    &#125;
&#125;
</code></pre>
<blockquote>
<p>把同步区域扩大，也就是只在最开始加一次锁，并且在最后直接解锁，那么就可以把中间这些无意义的解锁和加锁的过程消除。</p>
<ul>
<li>锁粗化不适用于循环的场景，仅适用于非循环的场景。</li>
</ul>
</blockquote>
<h2 id="死锁">死锁</h2>
<blockquote>
<p>死锁就是<strong>两个或多个线程（或进程）被无限期地阻塞，相互等待对方手中资源的一种状态。</strong></p>
</blockquote>
<pre><code class="language-java">/**
 * 描述：     必定死锁的情况
 */
public class MustDeadLock implements Runnable &#123;

    public int flag;
    static Object o1 = new Object();
    static Object o2 = new Object();

    public void run() &#123;
        System.out.println(&quot;线程&quot;+Thread.currentThread().getName() + &quot;的flag为&quot; + flag);
        if (flag == 1) &#123;
            synchronized (o1) &#123;
                try &#123;
                    Thread.sleep(500);
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125;
                synchronized (o2) &#123;
                    System.out.println(&quot;线程1获得了两把锁&quot;);
                &#125;
            &#125;
        &#125;
        if (flag == 2) &#123;
            synchronized (o2) &#123;
                try &#123;
                    Thread.sleep(500);
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125;
                synchronized (o1) &#123;
                    System.out.println(&quot;线程2获得了两把锁&quot;);
                &#125;
            &#125;
        &#125;
    &#125;

    public static void main(String[] argv) &#123;
        MustDeadLock r1 = new MustDeadLock();
        MustDeadLock r2 = new MustDeadLock();
        r1.flag = 1;
        r2.flag = 2;
        Thread t1 = new Thread(r1, &quot;t1&quot;);
        Thread t2 = new Thread(r2, &quot;t2&quot;);
        t1.start();
        t2.start();
    &#125;
&#125;
</code></pre>
<p><strong>排查死锁：</strong></p>
<p>通过jdk工具jps、jstack排查死锁问题。</p>
<blockquote>
<p>jps：jdk提供的一个工具，可以查看到正在运行的java进程。</p>
<p>jstack：jdk提供的一个工具，可以查看java进程中线程堆栈信息。</p>
<p>堆栈信息中我们可以发现这个内容：Found one Java-level deadlock，表示程序中发现了一个死锁。</p>
</blockquote>
<p>通过jdk提供的工具jconsole排查死锁问题。</p>
<blockquote>
<p>jconsole：jdk提供的一个可视化的工具，方便排查程序的一些问题，如：程序内存溢出、死锁问题等等。</p>
</blockquote>
<p>通过jdk提供的工具VisualVM排查死锁问题。</p>
<blockquote>
<p>VisualVM：jdk提供的一个排查java程序问题的一个工具，可以监控程序的性能、查看jvm配置信息、堆快照、线程堆栈信息。</p>
</blockquote>
<p><strong>如何避免死锁</strong></p>
<blockquote>
<p>正确的顺序获得锁。</p>
<ul>
<li>死锁的根本原因就是获取锁的顺序是乱序的。</li>
</ul>
<p>超时放弃。</p>
<ul>
<li>当线程获取锁超时了则放弃。</li>
</ul>
</blockquote>
<h2 id="Synchronized">Synchronized</h2>
<p>Synchronized可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块。</p>
<p><strong>两类锁：</strong></p>
<blockquote>
<p>对象锁：</p>
<ul>
<li>方法锁（默认锁对象为this当前实例对象）和同步代码块锁（自己指定锁对象）。</li>
</ul>
<p>类锁：</p>
<ul>
<li>修饰静态的方法或指定锁为Class对象。</li>
</ul>
</blockquote>
<p><strong>底层实现</strong></p>
<p>修饰方法：</p>
<blockquote>
<p>在字节码上给方法加了一个 flag：<code>ACC_SYNCHRONIZED</code>。</p>
</blockquote>
<p>代码块:</p>
<blockquote>
<p>通过 monitorenter 和monitorexit 两个指令进行控制的。</p>
<ul>
<li>本质上是通过 monitor 来实现的。</li>
</ul>
</blockquote>
<p>在Java虚拟机（HotSpot）中，Monitor是由ObjectMonitor实现的，其主要数据结构如下：</p>
<pre><code class="language-c">ObjectMonitor() &#123;
    _header       = NULL; //markOop对象头
    _count        = 0; //记录个数
    _waiters      = 0, //等待线程数
    _recursions   = 0; //重入次数
    _object       = NULL; //监视器锁寄生的对象。锁不是平白出现的，而是寄托存储于对象中。
    _owner        = NULL;  //指向获得ObjectMonitor对象的线程或基础锁
    _WaitSet      = NULL; //处于wait状态的线程，会被加入到_WaitSet
    _WaitSetLock  = 0 ; 
    _Responsible  = NULL;
    _succ         = NULL;
    _cxq          = NULL;
    FreeNext      = NULL;
    _EntryList    = NULL; //处于等待锁block状态的线程，会被加入到该列表
    _SpinFreq     = 0 ;
    _SpinClock    = 0 ;
    OwnerIsThread = 0 ; // _owner is (Thread *) vs SP/BasicLock
    _previous_owner_tid = 0; // 监视器前一个拥有者线程的ID
&#125;
</code></pre>
<blockquote>
<p>每个 Java 对象在 JVM 的对等对象的头中保存锁状态，指向 ObjectMonitor。</p>
<ul>
<li>ObjectMonitor 保存了当前持有锁的线程引用，EntryList 中保存目前等待获取锁的线程，WaitSet 保存 wait 的线程。</li>
</ul>
<p>计数器count：</p>
<ul>
<li>每当线程获得 monitor 锁，计数器 +1，当线程重入此锁时，计数器还会 +1。</li>
<li>当计数器不为 0 时，其它尝试获取 monitor 锁的线程将会被保存到EntryList中，并被阻塞。</li>
<li>当持有锁的线程释放了monitor 锁后，计数器 -1。</li>
<li>当计数器归位为 0 时，所有 EntryList 中的线程会尝试去获取锁，但只会有一个线程会成功，没有成功的线程仍旧保存在 EntryList 中。</li>
</ul>
</blockquote>
<img src="/images/209.png" alt="image-20231017173210058" style="zoom:90%;" />
<blockquote>
<p>加锁时，即遇到Synchronized关键字时，线程会先进入monitor的<code>_EntryList</code>队列阻塞等待。</p>
<p>如果monitor的<code>_owner</code>为空，则从队列中移出并赋值与<code>_owner</code>。</p>
<p>如果在程序里调用了wait()方法，wait方法会释放monitor锁，将<code>_owner</code>赋值为null，并进入<code>_WaitSet</code>队列阻塞等待。</p>
<ul>
<li>这时其他在<code>_EntryList</code>中的线程就可以获取锁了。</li>
</ul>
<p>当程序里其他线程调用了notify/notifyAll方法时，就会唤醒<code>_WaitSet</code>中的某个线程，这个线程就会再次尝试获取monitor锁。</p>
<ul>
<li>如果成功，则就会成为monitor的owner。</li>
</ul>
<p>当程序里遇到Synchronized关键字的作用范围结束时，就会将monitor的owner设为null，退出。</p>
</blockquote>
<p><strong>Synchronized和Lock的区别：</strong></p>
<blockquote>
<p>Synchronized属于JVM层面，Lock是API层面的东西，JUC提供的具体类。</p>
<p>Synchronized不需要用户手动释放锁，当代码执行完毕之后会自动让线程释放持有的锁，Lock需要去手动释放锁。</p>
<p>Synchronized是不可中断的，除非抛出异常或者程序正常退出，Lock可中断。</p>
<p>Synchronized是非公平锁，Lock默认是非公平锁，但是可以通过构造函数传入boolean类型值更改是否为公平锁。</p>
<p>Synchronized要么唤醒所有线程，要么随机唤醒一个线程，Lock可以使用condition实现分组唤醒需要唤醒的线程。</p>
<p>Synchronized只能同时被一个线程拥有，但是 Lock 锁没有这个限制，例如在读写锁中的读锁，是可以同时被多个线程持有的。</p>
</blockquote>

	</div>
</div>


    <div class="post-guide">
        <div class="item left">
            
              <a href="/2022/12/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  网络基础
              </a>
            
        </div>
        <div class="item right">
            
              <a href="/2022/12/02/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">
                MySQL
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>




<script>

    //document.oncontextmenu=new Function("event.returnValue=false");
	//document.onselectstart=new Function("event.returnValue=false");

	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "https://hm.baidu.com/hm.js?7eeb54583579fabc0878be210d6ad60a";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();

	

	$(function () {
		const btw = new BTWPlugin();
	    btw.init({
	        id: 'container',
	        blogId: '22377-1706525467336-300',
	        name: '月伴飞鱼',
	        qrcode: '/小程序码.jpg',
	        keyword: '验证码',
	        btnText: '为防止机器刷接口，需要完成人机检测',
        	cookieAge: 1
	    });

	    var contents = document.getElementsByClassName("content999");
	    //监听文章内容的copy事件
	    contents[0].addEventListener('copy',function(e){
	        setClipboardText(e);
	    });

	    function setClipboardText(event){
	        // clipboardData 对象是为通过编辑菜单、快捷菜单和快捷键执行的编辑操作所保留的，也就是你复制或者剪切内容
	        let clipboardData = event.clipboardData || window.clipboardData;

	        // 如果未复制或者未剪切，则return出去
	        if (!clipboardData) { return; }

	        event.preventDefault();

	        // Selection 对象，表示用户选择的文本范围或光标的当前位置。
	        // 声明一个变量接收 -- 用户输入的剪切或者复制的文本转化为字符串
	        let text = window.getSelection().toString();
	    
	        if (text) {
	            // 如果文本存在则先取消文本默认事件
	            event.preventDefault();
	            // 通过调用常clipboardData对象的 setData(format, data) 方法；来设置相关文本
	            // format: 一个DOMString 表示要添加到 drag object的拖动数据的类型。
	            // data: 一个 DOMString表示要添加到 drag object的数据。
	            var copyright = '\n\n'
	            + '\n著作权归作者所有。'
	            + '\n商业转载请联系作者获得授权，非商业转载请注明出处。'
	            + '\n作者: 月伴飞鱼'
	            + '\n原文地址: http://hardyfish.top/2022/12/10/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/'
	    
	            clipboardData.setData('text/plain', text + copyright);
	    
	        }
	    };
	});

	
</script>

<script>
    const btw = new BTWPlugin();
    btw.init({
        id: 'container',
        blogId: '22377-1706525467336-300',
        name: '月伴飞鱼',
        qrcode: '/小程序码.jpg',
        keyword: '验证码',
        btnText: '为防止机器刷接口，需要完成人机检测',
        cookieAge: 1
    });

	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "https://hm.baidu.com/hm.js?7eeb54583579fabc0878be210d6ad60a";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
</script>
	</div>
	<div id="footer">
	<p>
	©2019-<span id="footerYear"></span> 
	<a href="/">月伴飞鱼</a> 
	
	
		|
		<span id="busuanzi_container_site_pv">
			PV 180986
		</span>
		|
		<span id="busuanzi_container_site_uv"> 
			UV 10079
		</span>
	
	<br>
	微信搜索 <a href="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/个人公众号.jpg" target="_blank">月伴飞鱼</a> 关注我
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>
	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>