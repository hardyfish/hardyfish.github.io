<!DOCTYPE html>
<html lang="en" oncontextmenu="return false;">

<head oncontextmenu="return false;">
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta name="baidu-site-verification" content="codeva-QodU0Nk5F7" />
	<meta name="google-site-verification" content="DbSTw8OJwtH5Qei7n8Jnew0YyQ5naPzdLAPiscu7zQE" />
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">

	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "https://hm.baidu.com/hm.js?7eeb54583579fabc0878be210d6ad60a";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>

	
	<!-- title -->
	
	<title>
	
		LeetCode | 
	 
	月伴飞鱼
	</title>
	
	<!-- keywords,description -->
	 

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/%E5%A4%B4%E5%83%8F.jpg">
	
  
  	
<link rel="stylesheet" href="/css/main.css">

  	
<link rel="stylesheet" href="/css/reward.css">

	
<link rel="stylesheet" href="/css/jquery.fancybox.min.css">

	
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="/lib/highlight/darcula.css">

	
<link rel="stylesheet" href="/css/clipboard-use.css">


	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">


	
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>


	
<script src="/lib/highlight/highlight.min.js"></script>


	
<script src="https://readmore.openwrite.cn/js/readmore-2.0.js"></script>

	
<script src="/lib/jquery-3.4.1.min.js"></script>

	
<script src="/lib/jquery.pjax.js"></script>


	
<script src="/js/main.js"></script>

	
<script src="/js/jquery.fancybox.min.js"></script>

	
		
<script src="/lib/valine/av-3.0.4-min.js"></script>

		
<script src="/lib/valine/Valine-1.3.10-min.js"></script>

	
	
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
	
<script src="/js/clipboard.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body oncontextmenu="return false;">
	<header id="header" oncontextmenu="return false;">
    <a id="title" href="/" class="logo">公众号月伴飞鱼</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">关于我</a>
		</li>

		<li class="menu-item">
			<a href="/个人微信.jpeg" class="menu-item-link">联系作者</a>
		</li>

	    <li class="menu-item">
			<a href="/site" class="menu-item-link">关于网站</a>
		</li>

		<li class="menu-item">
			<a href="/个人公众号.jpg" class="menu-item-link" target="_blank">我的公众号</a>
		</li>
		
		<li class="menu-item">
			<a href="https://tech.meituan.com/" class="menu-item-link" target="_blank">
				美团技术团队
			</a>
		</li>
		<li class="menu-item">
			<a href="https://tech.youzan.com/" class="menu-item-link" target="_blank">
				有赞技术团队
			</a>
		</li>
		<!--<li class="menu-item">
			<select class="menu-item-link menu-item-select">
				<option class="menu-item-link"  value="volvo">Volvo</option>
				<option class="menu-item-link"  value="saab">Saab</option>
				<option class="menu-item-link"  value="fiat">Fiat</option>
				<option class="menu-item-link"  value="audi">Audi</option>
			</select>
		</li>-->
	</ul>
</header>

	<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="text" placeholder="按目录搜索一下">
		<div id="tree">
			

			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										AI相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2024/01/14/AI%E7%9B%B8%E5%85%B3/AIGC/">
										AIGC
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/03/07/AI%E7%9B%B8%E5%85%B3/Sora/">
										Sora
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/03/01/AI%E7%9B%B8%E5%85%B3/%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%B7%A5%E7%A8%8B/">
										提示词工程
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										中间件
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/30/%E4%B8%AD%E9%97%B4%E4%BB%B6/Dubbo/">
										Dubbo
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/12/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/Elasticsearch/">
										Elasticsearch
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/30/%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty/">
										Netty
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/12/25/%E4%B8%AD%E9%97%B4%E4%BB%B6/Solr/">
										Solr
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/ZooKeeper/">
										ZooKeeper
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										产品相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2024/02/18/%E4%BA%A7%E5%93%81%E7%9B%B8%E5%85%B3/%E5%B9%BF%E5%91%8A%E4%B8%9A%E5%8A%A1/">
										广告业务
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/18/%E4%BA%A7%E5%93%81%E7%9B%B8%E5%85%B3/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/">
										推荐系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/06/%E4%BA%A7%E5%93%81%E7%9B%B8%E5%85%B3/%E7%94%A8%E6%88%B7%E5%A2%9E%E9%95%BF/">
										用户增长
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										代码思想
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/12/15/%E4%BB%A3%E7%A0%81%E6%80%9D%E6%83%B3/CodeReview/">
										CodeReview
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/02/%E4%BB%A3%E7%A0%81%E6%80%9D%E6%83%B3/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/">
										代码重构
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										前端相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/CSS/">
										CSS
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/26/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/React/">
										React
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/26/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/Vue/">
										Vue
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/12/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">
										小程序
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										基础知识
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/11/27/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM/">
										JVM
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F/">
										分布式
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/12/10/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">
										并发编程
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
										设计模式
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										大数据相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2024/02/21/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3/DataX/">
										DataX
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/25/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3/Doris/">
										Doris
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3/Flink/">
										Flink
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/21/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3/Hadoop/">
										Hadoop
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/07/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3/Hive/">
										Hive
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/23/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3/SQOOP/">
										SQOOP
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3/Spark/">
										Spark
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										学习专栏
									</a>
									
							<ul>
								<li class="file">
									<a href="/2024/02/16/%E5%AD%A6%E4%B9%A0%E4%B8%93%E6%A0%8F/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/">
										从0开始学架构
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/31/%E5%AD%A6%E4%B9%A0%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%91/">
										代码之丑
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/26/%E5%AD%A6%E4%B9%A0%E4%B8%93%E6%A0%8F/%E5%A4%A7%E5%8E%82%E6%99%8B%E5%8D%87%E6%8C%87%E5%8D%97/">
										大厂晋升指南
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/19/%E5%AD%A6%E4%B9%A0%E4%B8%93%E6%A0%8F/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E5%AD%A6%E4%B9%A0%E9%AB%98%E6%89%8B/">
										如何成为学习高手
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										学习书籍
									</a>
									
							<ul>
								<li class="file">
									<a href="/2024/02/05/%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D/HBase%E4%B8%8D%E7%9D%A1%E8%A7%89%E4%B9%A6/">
										HBase不睡觉书
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/02/%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/">
										Java并发编程实战
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/02/%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/">
										Java并发编程的艺术
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/16/%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/">
										Java开发手册
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/03/11/%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/">
										亿级流量网站架构核心技术
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/05/%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/">
										代码整洁之道
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/03/03/%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/">
										大型网站技术架构
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/07/%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F/">
										大型网站系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/06/%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/">
										深入理解Java虚拟机
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/08/%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D/%E8%8B%B1%E8%AF%AD%E9%AD%94%E6%B3%95%E5%B8%88%E4%B9%8B%E8%AF%AD%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8/">
										英语魔法师之语法俱乐部
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										工具相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/11/09/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Arthas/">
										Arthas
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/12/24/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/ChatGPT/">
										ChatGPT
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/21/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/GIT/">
										GIT
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/21/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Hexo/">
										Hexo
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/21/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/MAC/">
										MAC
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/01/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Maven/">
										Maven
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/09/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/PlantUML/">
										PlantUML
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/12/22/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/UTools/">
										UTools
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/">
										实用工具
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										成长相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/31/%E6%88%90%E9%95%BF%E7%9B%B8%E5%85%B3/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">
										技术学习
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/07/%E6%88%90%E9%95%BF%E7%9B%B8%E5%85%B3/%E8%AF%BB%E4%B9%A6%E8%AE%A1%E5%88%92/">
										读书计划
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/09/%E6%88%90%E9%95%BF%E7%9B%B8%E5%85%B3/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/">
										面试相关
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										数据库
									</a>
									
							<ul>
								<li class="file">
									<a href="/2024/02/06/%E6%95%B0%E6%8D%AE%E5%BA%93/ClickHouse/">
										ClickHouse
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/27/%E6%95%B0%E6%8D%AE%E5%BA%93/HBase/">
										HBase
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/09/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/">
										MongoDB
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/12/02/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">
										MySQL
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/">
										Redis
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										文章速读
									</a>
									
							<ul>
								<li class="file">
									<a href="/2024/03/18/%E6%96%87%E7%AB%A0%E9%80%9F%E8%AF%BB/%E5%A4%A7%E5%8E%82%E6%96%87%E7%AB%A0/">
										大厂文章
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										服务器
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E6%9C%8D%E5%8A%A1%E5%99%A8/Docker/">
										Docker
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/09/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/">
										Nginx
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/03/%E6%9C%8D%E5%8A%A1%E5%99%A8/Tomcat/">
										Tomcat
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/09/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E8%BF%90%E7%BB%B4%E7%9F%A5%E8%AF%86/">
										运维知识
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										架构相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/21/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/DDD/">
										DDD
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/02/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/%E6%9E%B6%E6%9E%84%E5%9B%BE/">
										架构图
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/02/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0/">
										架构学习
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/26/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/%E7%B3%BB%E7%BB%9F%E4%BF%9D%E9%9A%9C/">
										系统保障
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/31/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD/">
										系统性能
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/26/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">
										系统设计
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										框架相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2024/01/07/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/Caffeine/">
										Caffeine
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/06/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/Guava/">
										Guava
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/15/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/JWT/">
										JWT
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/08/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/MyBatis/">
										MyBatis
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/14/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/RPC%E6%A1%86%E6%9E%B6/">
										RPC框架
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/26/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/Seata/">
										Seata
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/03/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/ShardingSphere/">
										ShardingSphere
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/14/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/Spring/">
										Spring
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/03/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/Thrift/">
										Thrift
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/29/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/XXLJOB/">
										XXLJOB
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/10/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/">
										开源框架
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										消息队列
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/KAFKA/">
										KAFKA
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/12/20/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/">
										RabbitMQ
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/">
										RocketMQ
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										源码相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/12/13/%E6%BA%90%E7%A0%81%E7%9B%B8%E5%85%B3/RocketMQ/">
										RocketMQ
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										生活相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/27/%E7%94%9F%E6%B4%BB%E7%9B%B8%E5%85%B3/%E4%B9%A6%E7%B1%8D/">
										书籍
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/12/17/%E7%94%9F%E6%B4%BB%E7%9B%B8%E5%85%B3/%E5%81%9A%E8%8F%9C/">
										做菜
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/24/%E7%94%9F%E6%B4%BB%E7%9B%B8%E5%85%B3/%E6%B3%95%E5%BE%8B/">
										法律
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/10/%E7%94%9F%E6%B4%BB%E7%9B%B8%E5%85%B3/%E7%94%B5%E5%BD%B1/">
										电影
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/10/%E7%94%9F%E6%B4%BB%E7%9B%B8%E5%85%B3/%E7%94%B5%E8%A7%86%E5%89%A7/">
										电视剧
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/11/%E7%94%9F%E6%B4%BB%E7%9B%B8%E5%85%B3/%E7%BA%AA%E5%BD%95%E7%89%87/">
										纪录片
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/09/%E7%94%9F%E6%B4%BB%E7%9B%B8%E5%85%B3/%E9%9F%B3%E4%B9%90/">
										音乐
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										算法相关
									</a>
									
							<ul>
								<li class="file active">
									<a href="/2022/11/26/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/LeetCode/">
										LeetCode
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/11/26/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E5%89%91%E6%8C%87OFFER/">
										剑指OFFER
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/11/25/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/">
										面试算法
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										编程语言
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/11/11/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go%E5%9F%BA%E7%A1%80/">
										Go基础
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Go语言
									</a>
									
							<ul>
								<li class="file">
									<a href="/2024/03/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go%E8%AF%AD%E8%A8%80/%E5%87%BD%E6%95%B0/">
										函数
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/03/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go%E8%AF%AD%E8%A8%80/%E5%B9%B6%E5%8F%91/">
										并发
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/03/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go%E8%AF%AD%E8%A8%80/%E6%95%B0%E7%BB%84/">
										数组
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/11/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java%E5%9F%BA%E7%A1%80/">
										Java基础
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/29/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python%E5%9F%BA%E7%A1%80/">
										Python基础
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										英语相关
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										摩登家庭
									</a>
									
							<ul>
								<li class="file">
									<a href="/2024/03/05/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E6%91%A9%E7%99%BB%E5%AE%B6%E5%BA%AD/%E7%AC%AC%E4%B8%80%E5%AD%A3/">
										第一季
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										老友记
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/08/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E8%80%81%E5%8F%8B%E8%AE%B0/%E7%AC%AC%E4%B8%80%E5%AD%A3/">
										第一季
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/08/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E8%80%81%E5%8F%8B%E8%AE%B0/%E7%AC%AC%E4%B8%89%E5%AD%A3/">
										第三季
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/23/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E8%80%81%E5%8F%8B%E8%AE%B0/%E7%AC%AC%E4%BA%94%E5%AD%A3/">
										第五季
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										雅思
									</a>
									
							<ul>
								<li class="file">
									<a href="/2024/01/25/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E9%9B%85%E6%80%9D/%E5%89%91%E6%A1%A5%E9%9B%85%E6%80%9D%E5%90%AC%E5%8A%9B%E7%9C%9F%E9%A2%9815/">
										剑桥雅思听力真题15
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/12/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E9%9B%85%E6%80%9D/%E5%89%91%E6%A1%A5%E9%9B%85%E6%80%9D%E5%90%AC%E5%8A%9B%E7%9C%9F%E9%A2%984/">
										剑桥雅思听力真题4
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/02/08/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E9%98%85%E8%AF%BB538%E8%80%83%E7%82%B9%E8%AF%8D/">
										雅思阅读538考点词
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										计算机基础
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
										操作系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
										数据结构
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/">
										算法知识
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/12/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">
										网络基础
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title" oncontextmenu="return false;">

	LeetCode
</h1>
<div class="article-meta" oncontextmenu="return false;">
	<span>月伴飞鱼</span>
	<span>2022-11-26 17:24:37</span>
    
		<div id="article-categories">
            
                
                    <span>
                        <i class="fa fa-folder" aria-hidden="true"></i>
                        <a href="/categories/算法相关/">算法相关</a>
						
                    </span>
                
            
		</div>
    
</div>

<div id="container" class = "content999" oncontextmenu="return false;">
<!--打赏-->
        <div class="reward">
       <div class="reward-button">赏 <span class="reward-code">
        <span class="alipay-code"> <img class="alipay-img wdp-appear" src="/alipay.png"><b>支付宝打赏</b> </span> 
        <span class="wechat-code"> <img class="wechat-img wdp-appear" src="/weipay.jpeg"><b>微信打赏</b> </span> 
       </div>
      <p class="reward-notice">如果文章对你有帮助，欢迎点击上方按钮打赏作者！</p>
      </div>
      <!--打赏-->
	<div id="article-content">
		<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">1两数之和</a></h1>
<pre><code class="language-java">class Solution &#123;
    public int[] twoSum(int[] nums, int target) &#123;
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();
        for (int i = 0; i &lt; nums.length; ++i) &#123;
            if (map.containsKey(target - nums[i])) &#123;
                return new int[]&#123;map.get(target - nums[i]), i&#125;;
            &#125;
            map.put(nums[i], i);
        &#125;
        return new int[0];
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-two-numbers/description/">2两数相加</a></h1>
<pre><code class="language-java">/**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode(int x) &#123; val = x; &#125;
 * &#125;
 */
class Solution &#123;
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;
        ListNode pre = new ListNode(0);
        ListNode cur = pre;
        int carry = 0;
        while(l1 != null || l2 != null) &#123;
            int x = l1 == null ? 0 : l1.val;
            int y = l2 == null ? 0 : l2.val;
            int sum = x + y + carry;
            
            carry = sum / 10;
            sum = sum % 10;
            cur.next = new ListNode(sum);

            cur = cur.next;
            if(l1 != null) &#123;
                l1 = l1.next;
            &#125;
            if(l2 != null) &#123;
                l2 = l2.next;
            &#125;
        &#125;
        if(carry == 1) &#123;
            cur.next = new ListNode(carry);
        &#125;
        return pre.next;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">3无重复字符的最长子串</a></h1>
<blockquote>
<p>定义一个 map 数据结构存储 (k, v)，其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复。</p>
<ul>
<li>定义不重复子串的开始位置为 start，结束位置为 end。</li>
</ul>
<p>随着 end 不断遍历向后，会遇到与 [start, end] 区间内字符相同的情况，此时将字符作为 key 值，获取其 value 值，并更新 start，此时 [start, end] 区间内不存在重复字符。</p>
</blockquote>
<pre><code class="language-java">class Solution &#123;
    public int lengthOfLongestSubstring(String s) &#123;
        int n = s.length(), result = 0;
        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();
        for (int end = 0, start = 0; end &lt; n; end++) &#123;
            char c = s.charAt(end);
            if (map.containsKey(c)) &#123;
                start = Math.max(map.get(c), start);
            &#125;
            result = Math.max(result, end - start + 1);
            map.put(s.charAt(end), end + 1);
        &#125;
        return result;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/description/">5最长回文子串</a></h1>
<pre><code class="language-java">class Solution &#123;
    public String longestPalindrome(String s) &#123;
        if (s == null || s.length() &lt; 1) &#123;
            return &quot;&quot;;
        &#125;

        //定义最长回文子串的长度
        int maxLength = 1;
        //定义最长回文子串的起始位置
        int start = 0;
        
        //遍历可能的回文子串的中心位置
        for (int i = 0; i &lt; s.length() - 1; i++) &#123;
            //最长回文子串的长度为奇数时，中心位置为一个字符
            int oddLength = expandAroundCenter(s, i, i);
            //最长回文子串的长度为偶数时，中心位置为两个字符
            int evenLength = expandAroundCenter(s, i, i + 1);
            int length = Math.max(oddLength, evenLength);

            //找出最大长度
            if (maxLength &lt; length) &#123;
                maxLength = length;
                //计算start位置
                start = i - (maxLength - 1) / 2;
                
            &#125;
        &#125;
        //截取字符串
        return s.substring(start, start + maxLength);
    &#125;

    //返回最长回文子串的长度
    public int expandAroundCenter(String s, int left, int right) &#123;
        while (left &gt;= 0 &amp;&amp; right &lt; s.length()) &#123;
            if (s.charAt(left) == s.charAt(right)) &#123;
                //边界向外扩展
                left--;
                right++;
            &#125; else &#123;
                break;
            &#125;
        &#125;
        //最后一次向外扩展不满足条件，还原该次扩展
        left++;
        right--;
        return right - left + 1;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-number/description/">9回文数</a></h1>
<pre><code class="language-java">class Solution &#123;
    public boolean isPalindrome(int x) &#123;
        // 特殊情况：
        // 当 x &lt; 0 时，x 不是回文数
        // 同样地，如果数字的最后一位是 0，为了使该数字为回文
        // 则其第一位数字也应该是0
        // 只有 0 满足这一属性
        if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) &#123;
            return false;
        &#125;

        int revertedNumber = 0;
        while (x &gt; revertedNumber) &#123;
            revertedNumber = revertedNumber * 10 + x % 10;
            x /= 10;
        &#125;

        // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数
        // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，
        // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除
        return x == revertedNumber || x == revertedNumber / 10;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-prefix/description/">14最长公共前缀</a></h1>
<pre><code class="language-java">class Solution &#123;
    public String longestCommonPrefix(String[] strs) &#123;
        if(strs.length == 0) &#123;
            return &quot;&quot;;
        &#125;

        String result = strs[0];
        for(int i =1;i&lt;strs.length;i++) &#123;
            int j=0;
            for(;j&lt;result.length() &amp;&amp; j &lt; strs[i].length();j++) &#123;
                if(result.charAt(j) != strs[i].charAt(j))
                    break;
            &#125;
            result = result.substring(0, j);
            if(result.equals(&quot;&quot;)) &#123;
                return result;
            &#125;
        &#125;
        return result;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/description/">15三数之和</a></h1>
<pre><code class="language-java">class Solution &#123;
    public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList();
        int len = nums.length;

        if(nums == null || len &lt; 3) &#123;
            return result;
        &#125;

        Arrays.sort(nums); // 排序

        for (int i = 0; i &lt; len ; i++) &#123;
            if(nums[i] &gt; 0) &#123;
                break; // 如果当前数字大于0，则三数之和一定大于0，所以结束循环
            &#125;

            if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) &#123;
                continue; // 去重
            &#125;

            int L = i+1;
            int R = len-1;
            while(L &lt; R)&#123;
                int sum = nums[i] + nums[L] + nums[R];
                if(sum == 0)&#123;
                    result.add(Arrays.asList(nums[i],nums[L],nums[R]));
                    while (L&lt;R &amp;&amp; nums[L] == nums[L+1]) &#123;
                        L++; // 去重
                    &#125;
                    while (L&lt;R &amp;&amp; nums[R] == nums[R-1]) &#123;
                        R--; // 去重
                    &#125;
                    L++;
                    R--;
                &#125; else if (sum &lt; 0) &#123;
                    L++;
                &#125; else if (sum &gt; 0) &#123;
                    R--;
                &#125;
            &#125;
        &#125;        
        return result;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum-closest/description/">16最接近的三数之和</a></h1>
<pre><code class="language-java">class Solution &#123;
    public int threeSumClosest(int[] nums, int target) &#123;
        Arrays.sort(nums);
        int result = nums[0] + nums[1] + nums[2];

        for(int i=0;i&lt;nums.length;i++) &#123;
            int start = i+1, end = nums.length - 1;
            while(start &lt; end) &#123;
                int sum = nums[start] + nums[end] + nums[i];
                if(Math.abs(target - sum) &lt; Math.abs(target - result)) &#123;
                    result = sum;
                &#125;
                if(sum &gt; target) &#123;
                    end--;
                &#125; else if(sum &lt; target) &#123;
                    start++;
                &#125; else &#123;
                    return result;
                &#125;
            &#125;
        &#125;
        return result;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/description/">18四数之和</a></h1>
<pre><code class="language-java">class Solution &#123;
    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;
        Arrays.sort(nums);
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        int length = nums.length;
        for (int i = 0; i &lt; length - 3; i++) &#123;
            // 跳过重复值
            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;
                continue;
            &#125;
            // 最小合都大于目标值，说明无解
            if ((long) nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target) &#123;
                break;
            &#125;
            // 最大合小于目标值，说明i太小了，继续后移
            if ((long) nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] &lt; target) &#123;
                continue;
            &#125;
            for (int j = i + 1; j &lt; length - 2; j++) &#123;
                // 跳过重复的数字
                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123;
                    continue;
                &#125;
                // 最小合都大于目标值，说明无解
                if ((long) nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &gt; target) &#123;
                    break;
                &#125;
                // 最大合小于目标值，说明i太小了，继续后移
                if ((long) nums[i] + nums[j] + nums[length - 2] + nums[length - 1] &lt; target) &#123;
                    continue;
                &#125;
                int left = j + 1, right = length - 1;
                while (left &lt; right) &#123;
                    int x = nums[left], y = nums[right];
                    int sum = nums[i] + nums[j] + x + y;
                    if (sum == target) &#123;
                        res.add(Arrays.asList(nums[i], nums[j], x, y));
                        // 将两个指针都往中间推移，遇到重复的数字就跳过
                        left++;
                        while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) &#123;
                            left++;
                        &#125;
                        right--;
                        while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) &#123;
                            right--;
                        &#125;
                    &#125; else if (sum &lt; target) &#123;
                        // 和小于目标值，因为是排序过的，要想结果变大，左标就要往右移动，数字更大
                        left++;
                    &#125; else &#123;
                        // 同理，和大于目标值，右标就要往左移动，数字更小
                        right--;
                    &#125;
                &#125;
            &#125;
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19删除链表的倒数第N个节点</a></h1>
<pre><code class="language-java">class Solution &#123;
    public ListNode removeNthFromEnd(ListNode head, int n) &#123;
        ListNode pre = new ListNode(-1);
        pre.next = head;
        ListNode start = pre, end = pre;
        while (n &gt; 0 &amp;&amp; start != null) &#123;
            start = start.next;
            n--;
        &#125;
        while (start.next != null) &#123;
            start = start.next;
            end = end.next;
        &#125;
        end.next = end.next.next;
        return pre.next;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-parentheses/">20有效的括号</a></h1>
<pre><code class="language-java">class Solution &#123;
    public boolean isValid(String s) &#123;
        if (s == null || s.length() == 0) &#123;
            return true;
        &#125;
        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();
        for (char c : s.toCharArray()) &#123;
            if (c == '(') &#123;
                stack.push(')');
            &#125; else if (c == '&#123;') &#123;
                stack.push('&#125;');
            &#125; else if (c == '[') &#123;
                stack.push(']');
            &#125; else if (stack.isEmpty() || stack.pop() != c) &#123;
                return false;
            &#125;
        &#125;
        return stack.isEmpty();
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21合并两个有序链表</a></h1>
<p><strong>迭代</strong></p>
<pre><code class="language-java">class Solution &#123;
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;
        ListNode pre = new ListNode(-1);
        ListNode cur = pre;
        while(l1!=null &amp;&amp; l2!=null) &#123;
            if (l1.val&lt;=l2.val) &#123;
                cur.next=l1;
                l1=l1.next;
            &#125; else &#123;
                cur.next=l2;
                l2=l2.next;
            &#125;
            cur=cur.next;
        &#125;
        //合并后l1和l2最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
        cur.next=(l1==null?l2:l1);
        return pre.next;
    &#125;
&#125;
</code></pre>
<p><strong>递归</strong></p>
<pre><code class="language-java">class Solution &#123;
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;
        if (l1 == null) &#123;
            return l2;
        &#125; else if (l2 == null) &#123;
            return l1;
        &#125; else if (l1.val &lt;= l2.val) &#123;
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        &#125; else &#123;
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        &#125;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24两两交换链表中的节点</a></h1>
<blockquote>
<p>令 cur 表示当前到达的节点，初始时 cur = pre。</p>
<ul>
<li>
<p>每次需要交换 cur 后面的两个节点。</p>
</li>
<li>
<p>如果 cur 的后面没有节点或者只有一个节点，则没有更多的节点需要交换，结束交换。</p>
</li>
<li>
<p>否则，获得 cur 后面的两个节点 node1 和 node2，通过更新节点的指针关系实现两两交换节点。</p>
</li>
</ul>
<p>交换之前的节点关系是 <code>cur -&gt; node1 -&gt; node2</code>，交换之后的节点关系要变成 <code>cur -&gt; node2 -&gt; node1</code>。</p>
<ul>
<li>
<p>完成上述操作之后，节点关系即变成 <code>cur -&gt; node2 -&gt; node1</code>。</p>
</li>
<li>
<p>再令 <code>cur = node1</code>，对链表中的其余节点进行两两交换，直到全部节点都被两两交换。</p>
</li>
<li>
<p>两两交换链表中的节点之后，新的链表的头节点是 <code>pre.next</code>，返回新的链表的头节点即可。</p>
</li>
</ul>
</blockquote>
<pre><code class="language-java">node1.next = node2.next
cur.next = node2
node2.next = node1
</code></pre>
<pre><code class="language-java">/**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode() &#123;&#125;
 *     ListNode(int val) &#123; this.val = val; &#125;
 *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;
 * &#125;
 */
class Solution &#123;
    public ListNode swapPairs(ListNode head) &#123;
        if (head == null) &#123;
            return null;
        &#125;

        ListNode pre = new ListNode(-1);
        pre.next = head;
        ListNode cur = pre;

        while(cur.next != null &amp;&amp; cur.next.next != null) &#123;
            ListNode node1 = cur.next;
            ListNode node2 = cur.next.next;
            node1.next = node2.next;
            cur.next = node2;
            node2.next = node1;
            cur = node1;
        &#125;
        return pre.next;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25K个一组翻转链表</a></h1>
<pre><code class="language-java">/**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode() &#123;&#125;
 *     ListNode(int val) &#123; this.val = val; &#125;
 *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;
 * &#125;
 */
class Solution &#123;
        public ListNode reverseKGroup(ListNode head, int k) &#123;
        if (head == null || head.next == null) &#123;
            return head;
        &#125;
        ListNode tail = head;
        for (int i = 0; i &lt; k; i++) &#123;
            //剩余数量小于k的话，则不需要反转。
            if (tail == null) &#123;
                return head;
            &#125;
            tail = tail.next;
        &#125;
        // 反转前 k 个元素
        ListNode newHead = reverse(head, tail);
        //下一轮的开始的地方就是tail
        head.next = reverseKGroup(tail, k);

        return newHead;
    &#125;

    /*
    	左闭又开区间
     */
    private ListNode reverse(ListNode head, ListNode tail) &#123;
        ListNode pre = null;
        ListNode next = null;
        while (head != tail) &#123;
            next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        &#125;
        return pre;

    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26删除排序数组中的重复项</a></h1>
<pre><code class="language-java">class Solution &#123;
    public int removeDuplicates(int[] nums) &#123;
        if (nums.length == 0) &#123;
            return 0;
        &#125;
        int i = 0;
        for (int j = 1; j&lt;nums.length; j++) &#123;
            if (nums[i] != nums[j]) &#123;
                i++;
                nums[i] = nums[j];
            &#125;
        &#125;
        return i+1;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-element/">27移除元素</a></h1>
<pre><code class="language-java">class Solution &#123;
    public int removeElement(int[] nums, int val) &#123;
        int i = 0;
        for (int j = 0; j &lt; nums.length; j++) &#123;
            if (nums[j] != val) &#123;
                nums[i] = nums[j];
                i++;
            &#125;
        &#125;
        return i;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">33搜索旋转排序数组</a></h1>
<pre><code class="language-java">class Solution &#123;
    public int search(int[] nums, int target) &#123;
        if (nums == null || nums.length == 0) &#123;
            return -1;
        &#125;

        int start = 0;
        int end = nums.length - 1;
        int mid;

        while (start &lt;= end) &#123;
            mid = start + (end - start) / 2;
            if (nums[mid] == target) &#123;
                return mid;
            &#125;

            //前半部分有序,注意此处用小于等于
            if (nums[start] &lt;= nums[mid]) &#123;
                //target在前半部分
                if (target &gt;= nums[start] &amp;&amp; target &lt; nums[mid]) &#123;
                    end = mid - 1;
                &#125; else &#123;
                    start = mid + 1;
                &#125;
            &#125; else &#123;
                if (target &lt;= nums[end] &amp;&amp; target &gt; nums[mid]) &#123;
                    start = mid + 1;
                &#125; else &#123;
                    end = mid - 1;
                &#125;
            &#125;

        &#125;
        return -1;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34在排序数组中查找元素的第一个和最后一个位置</a></h1>
<pre><code class="language-java">public class Solution &#123;
    public int[] searchRange(int[] nums, int target) &#123;
        int len = nums.length;
        if (len == 0) &#123;
            return new int[]&#123;-1, -1&#125;;
        &#125;

        int firstPosition = findFirstPosition(nums, target);
        if (firstPosition == -1) &#123;
            return new int[]&#123;-1, -1&#125;;
        &#125;

        int lastPosition = findLastPosition(nums, target);
        return new int[]&#123;firstPosition, lastPosition&#125;;
    &#125;

    private int findFirstPosition(int[] nums, int target) &#123;
        int left = 0;
        int right = nums.length - 1;
        while (left &lt; right) &#123;
            int mid = left + (right - left) / 2;
            // 小于一定不是解
            if (nums[mid] &lt; target) &#123;
                // 下一轮搜索区间是 [mid + 1..right]
                left = mid + 1;
            &#125; else &#123;
                // nums[mid] &gt;= target，下一轮搜索区间是 [left..mid]
                right = mid;
            &#125;
        &#125;

        // 退出循环以后不能确定 nums[left] 是否等于 target，因此需要再判断一次
        if (nums[left] == target) &#123;
            return left;
        &#125;
        return -1;
    &#125;

    private int findLastPosition(int[] nums, int target) &#123;
        int left = 0;
        int right = nums.length - 1;
        while (left &lt; right) &#123;
            int mid = left + (right - left + 1) / 2;
            if (nums[mid] &gt; target) &#123;
                // 下一轮搜索区间是 [left..mid - 1]
                right = mid - 1;
            &#125; else &#123;
                // 下一轮搜索区间是 [mid..right]
                left = mid;
            &#125; 
        &#125;
        // 主程序先执行 findFirstPosition，能执行到 findLastPosition 说明数组中一定存在等于 target 的元素，因此这里不用判断 nums[left] 是否等于 target
        return left;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/description/">46全排列</a></h1>
<pre><code class="language-java">class Solution &#123;
    private List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;&gt;();
    private List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
    private boolean[] flag;

    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;
        flag = new boolean[nums.length];
        backTracking(nums);
        return resList;
    &#125;
 
    public void backTracking(int[] nums) &#123;
        if (list.size() == nums.length) &#123;
            resList.add(new ArrayList&lt;&gt;(list));
            return;
        &#125;
 
        for (int i = 0; i &lt; nums.length; i++) &#123;
            if (flag[i]) &#123;
                continue;
            &#125;

            flag[i] = true;
            list.add(nums[i]);

            backTracking(nums);
            
            list.remove(list.size() - 1);
            flag[i] = false;
        &#125;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/description/">53最大子数组和</a></h1>
<pre><code class="language-java">class Solution &#123;
    public int maxSubArray(int[] nums) &#123;
        int pre = 0, maxAns = nums[0];
        for (int x : nums) &#123;
            pre = Math.max(pre + x, x);
            maxAns = Math.max(maxAns, pre);
        &#125;
        return maxAns;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/spiral-matrix/">54螺旋矩阵</a></h1>
<pre><code class="language-java">class Solution &#123;
    public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;
        int col = 0, cols = matrix[0].length - 1, row = 0, rows = matrix.length - 1;
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        int total = matrix.length * matrix[0].length;
        int num = 1;
        while (num &lt;= total) &#123;
            for (int i = col; i &lt;= cols &amp;&amp; num &lt;= total ; i++) &#123; //从左到右
                list.add(matrix[row][i]);
                num++;
            &#125;
            row++;
            for (int i = row; i &lt;= rows &amp;&amp; num &lt;= total ; i++) &#123; //从上到下
                list.add(matrix[i][cols]);
                num++;
            &#125;
            cols--;
            for (int i = cols; i &gt;= col &amp;&amp; num &lt;= total ; i--) &#123; //从右到左
                list.add(matrix[rows][i]);
                num++;
            &#125;
            rows--;
            for (int i = rows; i &gt;= row &amp;&amp; num &lt;= total ; i--) &#123; //从下到上
                list.add(matrix[i][col]);
                num++;
            &#125;
            col++;
        &#125;
        return list;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-interval/">57插入区间</a></h1>
<pre><code class="language-java">class Main &#123;
    public int[][] merge(int[][] s, int[] k) &#123;
        int[][] result = new int[s.length + 1][2];
        int index = 0,int i = 0;

        //1.没有相交的情况
        while(i &lt; s.length &amp;&amp; k[0] &gt; s[i][1]) &#123;
            result[index++] = s[i++];
        &#125;

        //2.有相交的情况
        while(i &lt; s.length &amp;&amp; s[i][0] &lt;= k[1])&#123;
            k[0] = Math.min(k[0], s[i][0]);
            k[1] = Math.max(k[1], s[i++][1]);
        &#125;

        //3.插入数组区间
        result[index++] = k;
        
        //4.剩下的也要放到数组中
        while(i &lt; s.length) &#123;
            result[index++] = s[i++];
        &#125;

        //5.数组拷贝扩容
        return Arrays.copyOf(result, index);
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-list/">61旋转链表</a></h1>
<pre><code class="language-java">/**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode() &#123;&#125;
 *     ListNode(int val) &#123; this.val = val; &#125;
 *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;
 * &#125;
 */
class Solution &#123;
    public ListNode rotateRight(ListNode head, int k) &#123;
        if (head == null) &#123;
            return head;
        &#125;

        // 计算链表中节点个数
        int len = calculateLen(head);
        k = k%len;

        // 慢指针初始指向头节点
        ListNode slow = head;
        // 快指针初始指向头节点
        ListNode fast = head;

        // 快指针先向前移动k步
        for(int i = 0; i &lt; k; i++) &#123;
            fast= fast.next;
        &#125;

        // 快慢指针同时向前移动，直到快指针指向的节点的
        // 下一个节点为null
        while (fast.next != null) &#123;
            fast = fast.next;
            slow = slow.next;
        &#125;

        // 快指针此时在链表末尾
        // 然后其指向的节点的后继指针指向头节点
        // 这时链表首尾相连成环
        fast.next = head;
        // 新的头节点是慢指针所指节点的下一个节点
        head = slow.next;
        // 慢指针所指节点的的后继指针指向null
        // 断开环
        slow.next = null;
        return head;
    &#125;

    private int calculateLen(ListNode head)&#123;
        int len = 0;
        while (head!=null) &#123;
            head = head.next;
            len++;
        &#125;
        return len;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-path-sum/description/">64最小路径和</a></h1>
<pre><code class="language-java">class Solution &#123;
    public int minPathSum(int[][] grid) &#123;
        for(int i = 0; i &lt; grid.length; i++) &#123;
            for(int j = 0; j &lt; grid[0].length; j++) &#123;
                if(i == 0 &amp;&amp; j == 0) &#123;
                    continue;
                &#125; else if(i == 0) &#123;
                    grid[i][j] = grid[i][j - 1] + grid[i][j];
                &#125; else if(j == 0)  &#123;
                    grid[i][j] = grid[i - 1][j] + grid[i][j];
                &#125; else &#123;
                    grid[i][j] = Math.min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j];
                &#125;
            &#125;
        &#125;
        return grid[grid.length - 1][grid[0].length - 1];
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/plus-one/">66加一</a></h1>
<pre><code class="language-java">class Solution &#123;
    public int[] plusOne(int[] digits) &#123;
        int n = digits.length;
        for (int i = n - 1; i &gt;= 0; --i) &#123;
            if (digits[i] != 9) &#123;
                ++digits[i];
                for (int j = i + 1; j &lt; n; ++j) &#123;
                    digits[j] = 0;
                &#125;
                return digits;
            &#125;
        &#125;

        // digits 中所有的元素均为 9
        int[] ans = new int[n + 1];
        ans[0] = 1;
        return ans;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">68I二叉搜索树的最近公共祖先</a></h1>
<pre><code class="language-java">class Solution &#123;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;
        if (root == null || p == null || q == null) &#123;
            return null;
        &#125;
        if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val &amp;&amp; root.right != null) &#123;
            return lowestCommonAncestor(root.right, p, q);
        &#125;
        if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val &amp;&amp; root.left != null) &#123;
            return lowestCommonAncestor(root.left, p, q);
        &#125;
        return root;
    &#125;
&#125;
</code></pre>
<pre><code class="language-java">class Solution &#123;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;
        while(root != null) &#123;
            if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;// p,q 都在 root 的右子树中
                root = root.right; // 遍历至右子节点
            &#125; else if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123; // p,q 都在 root 的左子树中
                root = root.left; // 遍历至左子节点
            &#125; else &#123;
              break;
            &#125;
        &#125;
        return root;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">68II二叉树的最近公共祖先</a></h1>
<pre><code class="language-java">class Solution &#123;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;
        if (root == null || root == p || root == q) &#123;
            return root;
        &#125;
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if (left == null) &#123;
            return right;
        &#125;
        if (right == null) &#123;
            return left;
        &#125;
        return root;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-colors/">75颜色分类</a></h1>
<pre><code class="language-java">class Solution &#123;
    public void sortColors(int[] nums) &#123;
        if (nums == null || nums.length == 0) &#123;
            return;
        &#125;
        int p0 = 0, p2 = nums.length - 1;
        for (int i = 0; i&lt;= p2;i++) &#123;
            //当我们将nums[i]与nums[p2]进行交换之后，新的nums[i]可能仍然是2
            while (i &lt;= p2 &amp;&amp; nums[i] == 2) &#123;
                swap(nums, i, p2);
                p2--;
            &#125;
            if (nums[i] == 0) &#123;
                swap(nums, i, p0);
                p0++;
            &#125;
        &#125;
    &#125;
    private void swap(int[] nums, int a, int b) &#123;
        int temp = nums[a];
        nums[a] = nums[b];
        nums[b] = temp;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">78子集</a></h1>
<pre><code class="language-java">class Solution &#123;
    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        backtrack(0, nums, res, new ArrayList&lt;Integer&gt;());
        return res;

    &#125;

    private void backtrack(int i, int[] nums, List&lt;List&lt;Integer&gt;&gt; res, ArrayList&lt;Integer&gt; tmp) &#123;
        res.add(new ArrayList&lt;&gt;(tmp));
        for (int j = i; j &lt; nums.length; j++) &#123;
            tmp.add(nums[j]);
            backtrack(j + 1, nums, res, tmp);
            tmp.remove(tmp.size() - 1);
        &#125;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">82删除排序链表中的重复元素II</a></h1>
<pre><code class="language-java">class Solution &#123;
    public ListNode deleteDuplicates(ListNode head) &#123;
        if (head == null) &#123;
            return head;
        &#125;
        
        ListNode dummy = new ListNode(0, head);

        ListNode cur = dummy;
        while (cur.next != null &amp;&amp; cur.next.next != null) &#123;
            if (cur.next.val == cur.next.next.val) &#123;
                int x = cur.next.val;
                while (cur.next != null &amp;&amp; cur.next.val == x) &#123;
                    cur.next = cur.next.next;
                &#125;
            &#125; else &#123;
                cur = cur.next;
            &#125;
        &#125;

        return dummy.next;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83删除排序链表中的重复元素</a></h1>
<pre><code class="language-java">class Solution &#123;
    public ListNode deleteDuplicates(ListNode head) &#123;
        ListNode cur = head;
        while (cur != null &amp;&amp; cur.next != null) &#123;
            if (cur.val == cur.next.val) &#123;
                cur.next = cur.next.next;
            &#125; else &#123;
                cur = cur.next;
            &#125;
        &#125;
        return head;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-sorted-array/">88合并两个有序数组</a></h1>
<pre><code class="language-java">class Solution &#123;
    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;
        int p1 = m - 1;
        int p2 = n - 1;
        int p = n + m - 1;
        while (p1 &gt;= 0 &amp;&amp; p2 &gt;= 0) &#123;
            nums1[p--] = (nums1[p1] &lt; nums2[p2] ? nums2[p2--] : nums1[p1--]);
        &#125;
        while (p2 &gt;= 0) &#123;
            nums1[p--] = nums2[p2--];
        &#125;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list-ii/description/">92反转链表II</a></h1>
<blockquote>
<p>第一步：</p>
<ul>
<li>找到待反转节点的前一个节点。</li>
</ul>
<p>第二步：</p>
<ul>
<li>反转 m 到 n 这部分。</li>
</ul>
<p>第三步：</p>
<ul>
<li>将反转的起点的 next 指向反转的后面一部分。</li>
</ul>
<p>第四步：</p>
<ul>
<li>将第一步找到的节点指向反转以后的头节点。</li>
</ul>
</blockquote>
<p><img src="/images/362.png" alt="img"></p>
<pre><code class="language-java">/**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode() &#123;&#125;
 *     ListNode(int val) &#123; this.val = val; &#125;
 *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;
 * &#125;
 */
class Solution &#123;
    public ListNode reverseBetween(ListNode head, int m, int n) &#123;
        ListNode res = new ListNode(0);
        res.next = head;
        ListNode node = res;

        //找到需要反转的那一段的上一个节点。
        for (int i = 1; i &lt; m; i++) &#123;
            node = node.next;
        &#125;

        //node.next就是需要反转的这段的起点
        ListNode nextHead = node.next;
        ListNode next = null;
        ListNode pre = null;

        //反转m到n这一段
        for (int i = m; i &lt;= n; i++) &#123;
            next = nextHead.next;
            nextHead.next = pre;
            pre = nextHead;
            nextHead = next;
        &#125;

        //将反转的起点的next指向next
        node.next.next = next;
        //需要反转的那一段的上一个节点的next节点指向反转后链表的头结点
        node.next = pre;
        return res.next;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94二叉树的中序遍历</a></h1>
<p><strong>递归</strong></p>
<pre><code class="language-java">class Solution &#123;
    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        inorder(root, result);
        return result;
    &#125;
    private void inorder(TreeNode root, List&lt;Integer&gt; result) &#123;
        if (root == null) &#123;
            return;
        &#125;
        inorder(root.left, result);
        result.add(root.val);
        inorder(root.right, result);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>时间复杂度：<code>O(n)</code>，其中 n 为二叉树节点的个数，二叉树的遍历中每个节点会被访问一次且只会被访问一次。</p>
<p>空间复杂度：<code>O(n)</code>，空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 <code>O(n)</code> 的级别。</p>
</blockquote>
<p><strong>栈</strong></p>
<pre><code class="language-java">class Solution &#123;
    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
        while(root != null || !stack.isEmpty()) &#123;
            while(root!=null) &#123;
                stack.push(root);
                root = root.left;
            &#125;
            root = stack.pop();
            result.add(root.val);
            root = root.right;
        &#125;
        return result;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/description/">98验证二叉搜索树</a></h1>
<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val = val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     &#125;
 * &#125;
 */
class Solution &#123;
    long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) &#123;
        if (root == null) &#123;
            return true;
        &#125;
        // 访问左子树
        if (!isValidBST(root.left)) &#123;
            return false;
        &#125;
        // 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回 false；否则继续遍历
        if (root.val &lt;= pre) &#123;
            return false;
        &#125;
        pre = root.val;
        // 访问右子树
        return isValidBST(root.right);
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/same-tree/">100相同的树</a></h1>
<pre><code class="language-java">class Solution &#123;
    public boolean isSameTree(TreeNode p, TreeNode q) &#123;
        if(p == null &amp;&amp; q == null) &#123;
            return true;
        &#125;
        if(p == null || q == null) &#123;
            return false;
        &#125;
        if(p.val != q.val) &#123;
            return false;
        &#125;
        return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>时间复杂度：<code>O(min(m,n))</code>，其中 m 和 n 分别是两个二叉树的节点数。</p>
<ul>
<li>对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会访问到该节点，因此被访问到的节点数不会超过较小的二叉树的节点数。</li>
</ul>
<p>空间复杂度：<code>O(min(m,n))</code>，其中 m 和 n 分别是两个二叉树的节点数。</p>
<ul>
<li>空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。</li>
</ul>
</blockquote>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">101对称二叉树</a></h1>
<pre><code class="language-java">class Solution &#123;
    public boolean isSymmetric(TreeNode root) &#123;
        return check(root, root);
    &#125;

    public boolean check(TreeNode p, TreeNode q) &#123;
        if (p == null &amp;&amp; q == null) &#123;
            return true;
        &#125;
        if (p == null || q == null) &#123;
            return false;
        &#125;
        return p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>时间复杂度：</p>
<ul>
<li>遍历了这棵树，渐进时间复杂度为 <code>O(n)</code>。</li>
</ul>
<p>空间复杂度：</p>
<ul>
<li>空间复杂度和递归使用的栈空间有关，这里递归层数不超过 n，故渐进空间复杂度为<code>O(n)</code>。</li>
</ul>
</blockquote>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102二叉树的层序遍历</a></h1>
<pre><code class="language-java">import java.util.*;
class Solution &#123;

    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;
        if (root == null) &#123;
            return new ArrayList&lt;List&lt;Integer&gt;&gt;();
        &#125;

        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.add(root);

        while (queue.size() &gt; 0) &#123;
            int size = queue.size();
            List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();
            for (int i = 0; i &lt; size; ++i) &#123;
                TreeNode node = queue.poll();
                tmp.add(node.val);
                if (node.left != null) &#123;
                    queue.add(node.left);
                &#125;
                if (node.right != null) &#123;
                    queue.add(node.right);
                &#125;
            &#125;
            res.add(tmp);
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103二叉树的锯齿形层序遍历</a></h1>
<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val = val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     &#125;
 * &#125;
 */
class Solution &#123;
    public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        if (root == null) &#123;
            return res;
        &#125;

        //创建队列，保存节点
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.add(root);//先把节点加入到队列中

        boolean leftToRight = true;//第一步先从左边开始打印
        while (!queue.isEmpty()) &#123;
            //记录每层节点的值
            List&lt;Integer&gt; level = new ArrayList&lt;&gt;();

            //统计这一层有多少个节点
            int count = queue.size();

            //遍历这一层的所有节点，把他们全部从队列中移出来，顺便
            //把他们的值加入到集合level中，接着再把他们的子节点（如果有）
            //加入到队列中
            for (int i = 0; i &lt; count; i++) &#123;
                //poll移除队列头部元素（队列在头部移除，尾部添加）
                TreeNode node = queue.poll();

                //判断是从左往右打印还是从右往左打印
                if (leftToRight) &#123;
                    //如果从左边打印，直接把访问的节点值加入到列表level的末尾即可
                    level.add(node.val);
                &#125; else &#123;
                    //如果是从右边开始打印，每次要把访问的节点值
                    //加入到列表的最前面
                    level.add(0, node.val);
                &#125;
                //左右子节点如果不为空会被加入到队列中
                if (node.left != null) &#123;
                    queue.add(node.left);
                &#125;
                if (node.right != null) &#123;
                    queue.add(node.right);
                &#125;
            &#125;
            //把这一层的节点值加入到集合res中
            res.add(level);
            //改变下次访问的方向
            leftToRight = !leftToRight;
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104二叉树的最大深度</a></h1>
<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val = val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     &#125;
 * &#125;
 */
class Solution &#123;
    public int maxDepth(TreeNode root) &#123;
        if (root == null) &#123;
            return 0;
        &#125;
        int leftHeight = maxDepth(root.left);
        int rightHeight = maxDepth(root.right);
        return Math.max(leftHeight, rightHeight) + 1;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>时间复杂度：O(n)，</p>
<ul>
<li>其中 n 为二叉树节点的个数，每个节点在递归中只被遍历一次。</li>
</ul>
<p>空间复杂度：</p>
<ul>
<li>O(height)，其中height 表示二叉树的高度。</li>
<li>递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。</li>
</ul>
</blockquote>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108将有序数组转换为二叉搜索树</a></h1>
<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val = val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     &#125;
 * &#125;
 */
class Solution &#123;
    public TreeNode sortedArrayToBST(int[] nums) &#123;
        return dfs(nums, 0, nums.length - 1);
    &#125;

    private TreeNode dfs(int[] nums, int lo, int hi) &#123;
        if (lo &gt; hi) &#123;
            return null;
        &#125; 
        // 以升序数组的中间元素作为根节点 root。
        int mid = lo + (hi - lo) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        // 递归的构建 root 的左子树与右子树。
        root.left = dfs(nums, lo, mid - 1);
        root.right = dfs(nums, mid + 1, hi); 
        return root;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/">110平衡二叉树</a></h1>
<pre><code class="language-java">class Solution &#123;
    public boolean isBalanced(TreeNode root) &#123;
        return height(root) != -1;
    &#125;
    
    private int height(TreeNode root) &#123;
        if (root == null) &#123;
            return 0;
        &#125;
        int leftHeight = height(root.left);
        int rightHeight = height(root.right);
        if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) &gt; 1) &#123;
            return -1;
        &#125; else &#123;
            return Math.max(leftHeight, rightHeight) + 1;
        &#125;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>时间复杂度：</p>
<ul>
<li>O(n)，其中 n 是二叉树中的节点个数，使用自底向上的递归，每个节点的计算高度和判断是否平衡都只需要处理一次，最坏情况下需要遍历二叉树中的所有节点，因此时间复杂度是 O(n)。</li>
</ul>
<p>空间复杂度：</p>
<ul>
<li>O(n)，其中 n 是二叉树中的节点个数，空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n。</li>
</ul>
</blockquote>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum/">112路径总和</a></h1>
<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) &#123; val = x; &#125;
 * &#125;
 */
class Solution &#123;
      public boolean hasPathSum(TreeNode root, int sum) &#123;
        if(root==null) &#123;
            return false;
        &#125;
        if(root.left==null&amp;&amp;root.right==null) &#123;
            return sum-root.val == 0;
        &#125; 
        return hasPathSum(root.left,sum-root.val)||hasPathSum(root.right,sum-root.val);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>时间复杂度：O(N)，其中 N 是树的节点数，对每个节点访问一次。</p>
</blockquote>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-ii/">113路径总和II</a></h1>
<blockquote>
<p>采用深度优先搜索的方式，遍历每一条从根节点到叶子节点的路径。</p>
<p>当我们遍历到叶子节点，且此时路径和恰为目标和时，就找到了一条满足条件的路径。</p>
</blockquote>
<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) &#123; val = x; &#125;
 * &#125;
 */
class Solution &#123;
    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123;
        dfs(root, sum);
        return result;
    &#125;

    public void dfs(TreeNode root, int sum) &#123;
        if (root == null) &#123;
            return;
        &#125;
        list.add(root.val);
        sum = sum - root.val;

        if (root.left == null &amp;&amp; root.right == null &amp;&amp; sum == 0) &#123;
            result.add(new ArrayList&lt;&gt;(list));
        &#125;

        dfs(root.left, sum);
        dfs(root.right, sum);

        list.remove(list.size() - 1);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>时间复杂度：<code>O(N^2)</code>，其中 N 是树的节点数。</p>
<p>空间复杂度：<code>O(N)</code>，其中 N 是树的节点数，空间复杂度主要取决于栈空间的开销，栈中的元素个数不会超过树的节点数。</p>
</blockquote>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121买卖股票的最佳时机</a></h1>
<pre><code class="language-java">public class Solution &#123;
    public int maxProfit(int prices[]) &#123;
        int minPrice = Integer.MAX_VALUE;
        int maxProfit = 0;
        for (int i = 0; i &lt; prices.length; i++) &#123;
            if (prices[i] &lt; minPrice) &#123;
                minPrice = prices[i];
            &#125; else if (prices[i] - minPrice &gt; maxProfit) &#123;
                maxProfit = prices[i] - minPrice;
            &#125;
        &#125;
        return maxProfit;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122买卖股票的最佳时机II</a></h1>
<pre><code class="language-java">class Solution &#123;
    public int maxProfit(int[] prices) &#123;
        int profit = 0;
        for (int i = 1; i &lt; prices.length; i++) &#123;
            int temp = prices[i] - prices[i - 1];
            if (temp &gt; 0) &#123;
                profit += temp;
            &#125;
        &#125;
        return profit;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-palindrome/">125验证回文串</a></h1>
<pre><code class="language-java">class Solution &#123;
    public boolean isPalindrome(String s) &#123;
        int left = 0, right = s.length() -1;
        while(left&lt;right) &#123;
            while(left&lt;right&amp;&amp;!Character.isLetterOrDigit(s.charAt(left))) &#123;
                left++;
            &#125;
            while(left&lt;right&amp;&amp;!Character.isLetterOrDigit(s.charAt(right))) &#123;
                right--;
            &#125;
            if (left&lt;right&amp;&amp;Character.toLowerCase(s.charAt(left))!=Character.toLowerCase(s.charAt(right))) &#123;
                return false;
            &#125;
            left++;
            right--;
        &#125;
        return true;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">129求根节点到叶节点数字之和</a></h1>
<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val = val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     &#125;
 * &#125;
 */
class Solution &#123;
    public int sumNumbers(TreeNode root) &#123;
        return dfs(root, 0);
    &#125;

    public int dfs(TreeNode root, int prevSum) &#123;
        if (root == null) &#123;
            return 0;
        &#125;
        int sum = prevSum * 10 + root.val;
        if (root.left == null &amp;&amp; root.right == null) &#123;
            return sum;
        &#125; else &#123;
            return dfs(root.left, sum) + dfs(root.right, sum);
        &#125;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>时间复杂度：</p>
<ul>
<li>O(n)，其中 n 是二叉树的节点个数，对每个节点访问一次。</li>
</ul>
<p>空间复杂度：</p>
<ul>
<li>O(n)，其中 n 是二叉树的节点个数。空间复杂度主要取决于递归调用的栈空间，递归栈的深度等于二叉树的高度，最坏情况下，二叉树的高度等于节点个数，空间复杂度为 <code>O(n)</code>。</li>
</ul>
</blockquote>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number/">136只出现一次的数字</a></h1>
<pre><code class="language-java">class Solution &#123;
    public int singleNumber(int[] nums) &#123;
        int result = 0;
        for(int num : nums) &#123;
            result = result ^ num;
        &#125;
        return result;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle/">141环形链表</a></h1>
<pre><code class="language-java">public class Solution &#123;
    public boolean hasCycle(ListNode head) &#123;
        if (head == null || head.next == null) &#123;
            return false;
        &#125;
        ListNode slow = head;
        ListNode fast = head.next;
        while (slow != fast) &#123;
            if (fast == null || fast.next == null) &#123;
                return false;
            &#125;
            slow = slow.next;
            fast = fast.next.next;
        &#125;
        return true;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142环形链表II</a></h1>
<pre><code class="language-java">public class Solution &#123;
    public ListNode detectCycle(ListNode head) &#123;
        if (head == null || head.next == null) &#123;
            return null;
        &#125;
        ListNode slow = head, fast = head;
        while(true) &#123;
            if (fast == null || fast.next == null) &#123;
                return null;
            &#125;
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) &#123;
                break;
            &#125;
        &#125;
        fast = head;
        while(slow != fast) &#123;
            slow = slow.next;
            fast = fast.next;
        &#125;
        return fast;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reorder-list/">143重排链表</a></h1>
<blockquote>
<p>目标链表即为：将原链表的左半端和反转后的右半端合并后的结果。</p>
<ul>
<li>
<p>找到原链表的中点</p>
</li>
<li>
<p>我们可以使用快慢指针来 <code>O(N)</code>找到链表的中间节点</p>
</li>
<li>
<p>将原链表的右半端反转</p>
</li>
<li>
<p>将原链表的两端合并</p>
</li>
</ul>
</blockquote>
<pre><code class="language-java">/**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode() &#123;&#125;
 *     ListNode(int val) &#123; this.val = val; &#125;
 *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;
 * &#125;
 */
class Solution &#123;
    public void reorderList(ListNode head) &#123;
        if (head == null) &#123;
            return;
        &#125;
        //1.找到链表中间节点
        ListNode mid = middleNode(head);
        ListNode l1 = head;
        ListNode l2 = mid.next;
        mid.next = null;
        //2.反转右端链表节点
        l2 = reverseList(l2);
        //3.链表两端合并
        mergeList(l1, l2);
    &#125;

    public ListNode middleNode(ListNode head) &#123;
        ListNode slow = head;
        ListNode fast = head;
        while (fast.next != null &amp;&amp; fast.next.next != null) &#123;
            slow = slow.next;
            fast = fast.next.next;
        &#125;
        return slow;
    &#125;

    public ListNode reverseList(ListNode head) &#123;
        ListNode pre = null;
        ListNode cur = head;
        while (cur != null) &#123;
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        &#125;
        return pre;
    &#125;

    public void mergeList(ListNode l1, ListNode l2) &#123;
        ListNode tempL1;
        ListNode tempL2;
        while (l1 != null &amp;&amp; l2 != null) &#123;
            tempL1 = l1.next;
            tempL2 = l2.next;

            l1.next = l2;
            l1 = tempL1;

            l2.next = l1;
            l2 = tempL2;
        &#125;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144二叉树的前序遍历</a></h1>
<p><strong>递归</strong></p>
<pre><code class="language-java">class Solution &#123;
    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;
        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
        preorder(root, result);
        return result;
    &#125;

    public void preorder(TreeNode root, List&lt;Integer&gt; result) &#123;
        if (root == null) &#123;
            return;
        &#125;
        result.add(root.val);
        preorder(root.left, result);
        preorder(root.right, result);
    &#125;
&#125;
</code></pre>
<p><strong>栈</strong></p>
<pre><code class="language-java">class Solution &#123;
    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;
        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
        while (root != null || !stack.isEmpty()) &#123;
            while(root!=null) &#123;
                result.add(root.val);
                stack.push(root);
                root = root.left;
            &#125;
            root = stack.pop();
            root = root.right;
        &#125;
        return result;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145二叉树的后序遍历</a></h1>
<p><strong>递归</strong></p>
<pre><code class="language-java">class Solution &#123;
    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;
        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
        postorder(root, result);
        return result;
    &#125;

    public void postorder(TreeNode root, List&lt;Integer&gt; result) &#123;
        if (root == null) &#123;
            return;
        &#125;
        postorder(root.left, result);
        postorder(root.right, result);
        result.add(root.val);
    &#125;
&#125;
</code></pre>
<p><strong>栈</strong></p>
<pre><code class="language-java">class Solution &#123;
    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;
        //左，右，根
        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
        while (root!=null || !stack.isEmpty()) &#123;
            while(root!=null) &#123;
                result.add(root.val);
                stack.push(root);
                root = root.right;
            &#125;
            root = stack.pop();
            root = root.left;
        &#125;
        Collections.reverse(result);
        return result;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lru-cache/">146LRU缓存机制</a></h1>
<pre><code class="language-java">class DLinkedNode &#123;
    int key;
    int value;
    DLinkedNode prev;
    DLinkedNode next;
    public DLinkedNode() &#123;&#125;
    public DLinkedNode(int key, int value) &#123;
        this.key = key; 
        this.value = value;
    &#125;
&#125;

public class LRUCache &#123;

    private Map&lt;Integer, DLinkedNode&gt; cache = new HashMap&lt;Integer, DLinkedNode&gt;();
    private int size;
    private int capacity;
    private DLinkedNode head, tail;

    public LRUCache(int capacity) &#123;
        this.size = 0;
        this.capacity = capacity;
        // 使用伪头部和伪尾部节点
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head.next = tail;
        tail.prev = head;
    &#125;

    public int get(int key) &#123;
        DLinkedNode node = cache.get(key);
        if (node == null) &#123;
            return -1;
        &#125;
        // 如果 key 存在，先通过哈希表定位，再移到头部
        moveToHead(node);
        return node.value;
    &#125;

    public void put(int key, int value) &#123;
        DLinkedNode node = cache.get(key);
        if (node == null) &#123;
            // 如果 key 不存在，创建一个新的节点
            DLinkedNode newNode = new DLinkedNode(key, value);
            // 添加进哈希表
            cache.put(key, newNode);
            // 添加至双向链表的头部
            addToHead(newNode);
            ++size;
            if (size &gt; capacity) &#123;
                // 如果超出容量，删除双向链表的尾部节点
                DLinkedNode tail = removeTail();
                // 删除哈希表中对应的项
                cache.remove(tail.key);
                --size;
            &#125;
        &#125; else &#123;
            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            node.value = value;
            moveToHead(node);
        &#125;
    &#125;

    private void addToHead(DLinkedNode node) &#123;
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    &#125;

    private void removeNode(DLinkedNode node) &#123;
        node.prev.next = node.next;
        node.next.prev = node.prev;
    &#125;

    private void moveToHead(DLinkedNode node) &#123;
        removeNode(node);
        addToHead(node);
    &#125;

    private DLinkedNode removeTail() &#123;
        DLinkedNode res = tail.prev;
        removeNode(res);
        return res;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-list/">148排序链表</a></h1>
<pre><code class="language-java">import java.util.*;
public class Solution &#123;
    public ListNode sortList (ListNode head) &#123;
        if(head == null || head.next == null) &#123;
            return head;
        &#125;
        
        //使用快慢指针找到中点
        ListNode slow = head, fast = head.next;
        while(fast!=null &amp;&amp; fast.next !=null)&#123;
            slow = slow.next;
            fast = fast.next.next;
        &#125;
        
        //分割为两个链表
        ListNode newList = slow.next;
        slow.next = null;
        
        //将两个链表继续分割
        ListNode left = sortList(head);
        ListNode right = sortList(newList);

        ListNode leftHead = new ListNode(-1);
        ListNode result = leftHead;
        
        //归并排序
        while(left != null &amp;&amp; right != null)&#123;
            if(left.val &lt; right.val)&#123;
                leftHead.next = left;
                left = left.next;
            &#125; else&#123;
                leftHead.next = right;
                right = right.next;
            &#125;
            leftHead = leftHead.next;
        &#125;
        
        //判断左右链表是否为空
        leftHead.next = (left != null ? left : right);
        return result.next;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>时间复杂度：<code>O(nlogn)</code>，其中 n 是链表的长度。</p>
</blockquote>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-subarray/">152乘积最大子数组</a></h1>
<blockquote>
<p>遍历数组时计算当前最大值，不断更新。</p>
<p>令imax为当前最大值，则当前最大值为<code> imax = max(imax * nums[i], nums[i])。</code></p>
<p>由于存在负数，那么会导致最大的变最小的，最小的变最大的。</p>
<p>因此还需要维护当前最小值imin，<code>imin = min(imin * nums[i], nums[i])。</code></p>
<p>当负数出现时则imax与imin进行交换再进行下一步计算。</p>
</blockquote>
<pre><code class="language-java">class Solution &#123;
    public int maxProduct(int[] nums) &#123;
        int max = Integer.MIN_VALUE, imax = 1, imin = 1;
        for(int i=0; i&lt;nums.length; i++)&#123;
            if(nums[i] &lt; 0)&#123; 
              int tmp = imax;
              imax = imin;
              imin = tmp;
            &#125;
            imax = Math.max(imax*nums[i], nums[i]);
            imin = Math.min(imin*nums[i], nums[i]);
            
            max = Math.max(max, imax);
        &#125;
        return max;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-stack/">155最小栈</a></h1>
<pre><code class="language-java">class MinStack &#123;
    private Stack&lt;Integer&gt; stack;
    private Stack&lt;Integer&gt; minStack;
    public MinStack() &#123;
        stack = new Stack&lt;&gt;();
        minStack = new Stack&lt;&gt;();
    &#125;
    public void push(int x) &#123;
        stack.push(x);
        if(minStack.isEmpty() || x &lt;= minStack.peek()) &#123;
            minStack.push(x);
        &#125;
    &#125;
    public void pop() &#123;
        if(stack.pop().equals(minStack.peek())) &#123;
            minStack.pop();
        &#125;
    &#125;
    public int top() &#123;
        return stack.peek();
    &#125;
    public int getMin() &#123;
        return minStack.peek();
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160相交链表</a></h1>
<p><strong>双指针</strong></p>
<blockquote>
<p>创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点。然后让它们向后逐结点遍历。</p>
<p>当 pA到达链表的尾部时，将它重定位到链表 B 的头结点，类似的，当 pB到达链表的尾部时，将它重定位到链表 A 的头结点。</p>
<p>若在某一时刻 pA和 pB 相遇，则 pA/pB为相交结点。</p>
<p>考虑以下两个链表: A={1,3,5,7,9,11} 和 B={2,4,9,11}，相交于结点 9。</p>
<ul>
<li>
<p>由于 <code>B.length (=4) &lt; A.length (=6</code>)，pB比 pA少经过 2个结点，会先到达尾部。</p>
</li>
<li>
<p>将 pB重定向到 A 的头结点，pA重定向到 B 的头结点后，pB要比 pA多走 2 个结点。</p>
</li>
<li>
<p>因此，它们会同时到达交点。</p>
</li>
</ul>
</blockquote>
<pre><code class="language-java">/**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode(int x) &#123;
 *         val = x;
 *         next = null;
 *     &#125;
 * &#125;
 */
public class Solution &#123;

    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;
        if (headA == null || headB == null) &#123;
            return null;
        &#125;

        ListNode head1 = headA;
        ListNode head2 = headB;

        while (head1 != head2) &#123;
            if (head1 != null) &#123;
                head1 = head1.next;
            &#125; else &#123;
                head1 = headB;
            &#125;

            if (head2 != null) &#123;
                head2 = head2.next;
            &#125; else &#123;
                head2 = headA;
            &#125;
        &#125;
        return head1;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>时间复杂度 : O(m+n)。</p>
<p>空间复杂度 : O(1)。</p>
</blockquote>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-peak-element/">162寻找峰值</a></h1>
<p><strong>二分查找</strong></p>
<blockquote>
<p>查找时，左指针 l，右指针 r，以其保持左右顺序为循环条件。</p>
<p>根据左右指针计算中间位置 m，并比较 m 与 m+1 的值，如果 m 较大，则左侧存在峰值，r = m。</p>
<p>如果 m + 1 较大，则右侧存在峰值，l = m + 1。</p>
</blockquote>
<pre><code class="language-java">public class Solution &#123;
    public int findPeakElement(int[] nums) &#123;
        int l = 0, r = nums.length - 1;
        while (l &lt; r) &#123;
            int mid = (l + r) / 2;
            if (nums[mid] &gt; nums[mid + 1]) &#123;
                r = mid;
            &#125; else &#123;
                l = mid + 1;
            &#125;
        &#125;
        return l;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element/">169多数元素</a></h1>
<p><strong>摩尔投票法</strong></p>
<blockquote>
<p>投票法是遇到相同的则票数 + 1，遇到不同的则票数 - 1。</p>
<p>且 多数元素 的个数<code>&gt; n/2</code>，其余元素的个数总和<code>&lt; n/2 </code>。</p>
<p>因此<code>多数元素的个数 - 其余元素的个数总和</code> 的结果 肯定 &gt;= 1。</p>
<p>这就相当于每个多数元素和其他元素 两两相互抵消，抵消到最后肯定还剩余至少1个多数元素。</p>
<p>无论数组是1 2 1 2 1，亦或是1 2 2 1 1，总能得到正确的候选人。</p>
</blockquote>
<pre><code class="language-java">class Solution &#123;
    public int majorityElement(int[] nums) &#123;
        int result = nums[0], count = 1;
        for (int i = 1;i&lt;nums.length;i++) &#123;
            if (result == nums[i]) &#123;
                count++;
            &#125; else &#123;
                count--;
            &#125;
            if (count == 0) &#123;
                result = nums[i];
                count=1;
            &#125;
        &#125;
        return result;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">199二叉树的右视图</a></h1>
<p><strong>DFS</strong></p>
<pre><code class="language-java">class Solution &#123;
    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;
        dfs(root, 0);
        return result;
    &#125;
    private void dfs(TreeNode root, int depth) &#123;
        if (root == null) &#123;
            return;
        &#125;
        //如果当前节点所在深度还没有出现在result里，说明在该深度下当前节点是第一个被访问的节点，因此将当前节点加入result中
        if (depth == result.size()) &#123;
            result.add(root.val);
        &#125;
        depth++;
        dfs(root.right, depth);
        dfs(root.left, depth);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>时间复杂度： O(N)，每个节点都访问了 1 次。</p>
<p>空间复杂度： O(N)，因为这不是一棵平衡二叉树，二叉树的深度最少是 logN, 最坏的情况下会退化成一条链表，深度就是 N。</p>
</blockquote>
<p><strong>BFS</strong></p>
<pre><code class="language-java">class Solution &#123;
    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        if (root == null) &#123;
            return result;
        &#125;
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);
        while(!queue.isEmpty()) &#123;
            int size = queue.size();
            for (int i = 0;i&lt;size;i++) &#123;
                TreeNode node = queue.poll();
                if (node.left != null) &#123;
                    queue.offer(node.left);
                &#125;
                if (node.right != null) &#123;
                    queue.offer(node.right);
                &#125;
                if (i == size - 1) &#123;
                    result.add(node.val);
                &#125;
            &#125;
        &#125;
        return result;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>时间复杂度： O(N)，每个节点都入队出队了 1 次。</p>
<p>空间复杂度： O(N)，使用了额外的队列空间。</p>
</blockquote>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/">206反转链表</a></h1>
<p><strong>迭代</strong></p>
<pre><code class="language-java">class Solution &#123;
    public ListNode reverseList(ListNode head) &#123;
        //申请节点，pre和 cur，pre指向null
        ListNode pre = null;
        ListNode cur = head;
        ListNode next = null;
        while(cur!=null) &#123;
            //记录当前节点的下一个节点
            next = cur.next;
            //然后将当前节点指向pre
            cur.next = pre;
            //pre和cur节点都前进一位
            pre = cur;
            cur = next;
        &#125;
        return pre;
    &#125;
&#125;
</code></pre>
<p><strong>递归</strong></p>
<pre><code class="language-java">class Solution &#123;
    public ListNode reverseList(ListNode head) &#123;
        //递归终止条件是当前为空，或者下一个节点为空
        if(head==null || head.next==null) &#123;
            return head;
        &#125;
        //这里的cur就是最后一个节点
    //如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5
        ListNode cur = reverseList(head.next);
        //而head是4，head的下一个是5，意思是5的下一个节点指向4，5-&gt;4
        head.next.next = head;
        //防止链表循环指向，需要将head.next设置为空
        head.next = null;
        //每层递归函数都返回cur，也就是最后一个节点
        return cur;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>时间复杂度：O(n)，假设 n 是列表的长度。</p>
<p>空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间，递归深度可能会达到 n 层。</p>
</blockquote>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215数组中的第K个最大元素</a></h1>
<pre><code class="language-java">class Solution &#123;
    public int findKthLargest(int[] nums, int k) &#123;
        return quickSort(nums, 0, nums.length - 1, nums.length - k);
    &#125;

    public int partition(int[] nums, int left, int right)&#123;
        int pivot = nums[left];

        while(left &lt; right)&#123;
            while(left &lt; right &amp;&amp; nums[right] &gt;= pivot)&#123;
                right--;
            &#125;
            nums[left] = nums[right];

            while(left &lt; right &amp;&amp; nums[left] &lt;= pivot)&#123;
                left++;
            &#125;
            nums[right] = nums[left];
        &#125;
        nums[left] = pivot;
        return left;
    &#125;

    public int quickSort(int[] nums, int left, int right, int k)&#123;
        // 如果经过一轮快排分区后pivot位置刚好是k，那么可以直接退出了
        int mid = partition(nums, left, right);
        if(mid == k)&#123;
            return nums[k];
        &#125;else if(mid &gt; k)&#123;
            return quickSort(nums, left, mid - 1, k);
        &#125;else&#123;
            return quickSort(nums, mid + 1, right, k);
        &#125;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>时间复杂度 O(N)，空间复杂度 O(1)。</p>
</blockquote>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">222完全二叉树的节点个数</a></h1>
<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val = val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     &#125;
 * &#125;
 */
class Solution &#123;
    public int countNodes(TreeNode root) &#123;
        if (root == null) return 0;
        int lh = 0, rh = 0;
        TreeNode left = root, right = root;
        // 求左高
        while (left != null) &#123;
            left = left.left;
            lh++;
        &#125;
        // 求右高
        while (right != null) &#123;
            right = right.right;
            rh++;
        &#125;
        // 以 root 为根节点的树是「满二叉树」
        if (lh == rh) &#123;
          return (int) Math.pow(2, lh) - 1;
        &#125;
        // 否则，按照正常方式遍历
        return countNodes(root.left) + countNodes(root.right) + 1;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/">226翻转二叉树</a></h1>
<p><strong>递归</strong></p>
<pre><code class="language-java">class Solution &#123;
    public TreeNode invertTree(TreeNode root) &#123;
        if(root==null) &#123;
            return null;
        &#125;
        TreeNode tmp = root.right;
        root.right = root.left;
        root.left = tmp;
        //递归交换当前节点的 左子树
        invertTree(root.left);
        //递归交换当前节点的 右子树
        invertTree(root.right);
        return root;
    &#125;
&#125;
</code></pre>
<p><strong>迭代</strong></p>
<pre><code class="language-java">class Solution &#123;
	public TreeNode invertTree(TreeNode root) &#123;
		if(root==null) &#123;
			return null;
		&#125;
		LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();
		queue.add(root);
		while(!queue.isEmpty()) &#123;
			//每次都从队列中拿一个节点，并交换这个节点的左右子树
			TreeNode tmp = queue.poll();
			TreeNode left = tmp.left;
			tmp.left = tmp.right;
			tmp.right = left;
			//如果当前节点的左子树不为空，则放入队列等待后续处理
			if(tmp.left!=null) &#123;
				queue.add(tmp.left);
			&#125;
			//如果当前节点的右子树不为空，则放入队列等待后续处理
			if(tmp.right!=null) &#123;
				queue.add(tmp.right);
			&#125;
		&#125;
		return root;
	&#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element-ii/">229求众数II</a></h1>
<pre><code class="language-java">class Solution &#123;
    public List&lt;Integer&gt; majorityElement(int[] nums) &#123;
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        if (nums == null || nums.length == 0) &#123;
            return res;
        &#125;
        // 初始化两个候选人candidate，和他们的计票
        int cand1 = nums[0], count1 = 0;
        int cand2 = nums[0], count2 = 0;

        // 摩尔投票法，分为两个阶段：配对阶段和计数阶段
        // 配对阶段
        for (int num : nums) &#123;
            // 投票
            if (cand1 == num) &#123;
                count1++;
                continue;
            &#125;
            if (cand2 == num) &#123;
                count2++;
                continue;
            &#125;

            // 第1个候选人配对
            if (count1 == 0) &#123;
                cand1 = num;
                count1++;
                continue;
            &#125;
            // 第2个候选人配对
            if (count2 == 0) &#123;
                cand2 = num;
                count2++;
                continue;
            &#125;

            count1--;
            count2--;
        &#125;

        // 计数阶段
        // 找到了两个候选人之后，需要确定票数是否满足大于 N/3
        count1 = 0;
        count2 = 0;
        for (int num : nums) &#123;
            if (cand1 == num) &#123;
                count1++;
            &#125; else if (cand2 == num) &#123;
                count2++;
            &#125;
        &#125;

        if (count1 &gt; nums.length / 3) &#123;
            res.add(cand1);
        &#125;
        if (count2 &gt; nums.length / 3) &#123;
            res.add(cand2);
        &#125;

        return res;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230二叉搜索树中第K小的元素</a></h1>
<p><strong>中序遍历</strong></p>
<blockquote>
<p>二叉搜索树的中序遍历是有序的，因此只需要对二叉搜索树执行中序遍历，并返回第 k 小的值即可。</p>
</blockquote>
<pre><code class="language-java">class Solution &#123;
    public int kthSmallest(TreeNode root, int k) &#123;
        Deque&lt;TreeNode&gt; d = new ArrayDeque&lt;&gt;();
        while (root != null || !d.isEmpty()) &#123;
            while (root != null) &#123;
                d.addLast(root);
                root = root.left;
            &#125;
            root = d.pollLast();
            if (--k == 0) &#123;
                return root.val;
            &#125;
            root = root.right;
        &#125;
        return -1;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>时间复杂度：</p>
<ul>
<li>
<p>令 h 为树高，先到达叶子位置（最小节点位置），复杂度为 O(h)，然后找到第 k 小的元素，复杂度为 O(k)。</p>
</li>
<li>
<p>整体复杂度为 O(h + k)。</p>
</li>
</ul>
<p>空间复杂度：</p>
<ul>
<li>令 h 为树高，复杂度为 O(h)。</li>
</ul>
</blockquote>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-linked-list/">234回文链表</a></h1>
<p><strong>整个流程可以分为以下步骤：</strong></p>
<blockquote>
<p>找到前半部分链表的尾节点。</p>
<p>反转后半部分链表。</p>
<p>判断是否回文。</p>
<p>恢复链表。</p>
<p>返回结果。</p>
</blockquote>
<pre><code class="language-java">class Solution &#123;
    public boolean isPalindrome(ListNode head) &#123;
        if (head == null) &#123;
            return true;
        &#125;

        // 找到前半部分链表的尾节点并反转后半部分链表
        ListNode firstHalfEnd = endOfFirstHalf(head);
        ListNode secondHalfStart = reverseList(firstHalfEnd.next);

        // 判断是否回文
        ListNode p1 = head;
        ListNode p2 = secondHalfStart;
        boolean result = true;
        while (result &amp;&amp; p2 != null) &#123;
            if (p1.val != p2.val) &#123;
                result = false;
            &#125;
            p1 = p1.next;
            p2 = p2.next;
        &#125;        

        // 还原链表并返回结果
        firstHalfEnd.next = reverseList(secondHalfStart);
        return result;
    &#125;

    private ListNode reverseList(ListNode head) &#123;
        ListNode prev = null;
        ListNode curr = head;
        while (curr != null) &#123;
            ListNode nextTemp = curr.next;
            curr.next = prev;
            prev = curr;
            curr = nextTemp;
        &#125;
        return prev;
    &#125;

    private ListNode endOfFirstHalf(ListNode head) &#123;
        ListNode fast = head;
        ListNode slow = head;
        while (fast.next != null &amp;&amp; fast.next.next != null) &#123;
            fast = fast.next.next;
            slow = slow.next;
        &#125;
        return slow;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">237删除链表中的节点</a></h1>
<pre><code class="language-java">class Solution &#123;
    public void deleteNode(ListNode node) &#123;
        node.val = node.next.val;
        node.next = node.next.next;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">240搜索二维矩阵II</a></h1>
<blockquote>
<p>因为每一行递增，每一列递增。</p>
<p>从右上角往左下角找或者从左下角往右上角找。</p>
<p>每次比较可以排除一行或者一列，时间复杂度为O(m+n)。</p>
</blockquote>
<pre><code class="language-java">class Solution &#123;
    public boolean searchMatrix(int[][] matrix, int target) &#123;
        if (matrix == null || matrix.length == 0) &#123;
            return false;
        &#125;
        int row = matrix.length;
        int col = matrix[0].length;
        int x = 0, y = col - 1;
        while(x &lt; row &amp;&amp; y &gt;= 0) &#123;
            if (matrix[x][y] == target) &#123;
                return true;
            &#125; else if (matrix[x][y] &gt; target) &#123;
                y--;
            &#125; else &#123;
                x++;
            &#125;
        &#125;
        return false;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-paths/">257二叉树的所有路径</a></h1>
<pre><code class="language-java">class Solution &#123;
    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;
        List&lt;String&gt; paths = new ArrayList&lt;String&gt;();
        constructPaths(root, &quot;&quot;, paths);
        return paths;
    &#125;

    public void constructPaths(TreeNode root, String path, List&lt;String&gt; paths) &#123;
        if (root == null) &#123;
            return;
        &#125;
        StringBuffer pathBuilder = new StringBuffer(path);
        pathBuilder.append(String.valueOf(root.val));
        if (root.left == null &amp;&amp; root.right == null) &#123;
            paths.add(pathBuilder.toString());
        &#125; else &#123;
            pathBuilder.append(&quot;-&gt;&quot;);
            constructPaths(root.left, pathBuilder.toString(), paths);
            constructPaths(root.right, pathBuilder.toString(), paths);
        &#125;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>时间复杂度：<code>O(N^2)</code>，其中 N表示节点数目。</p>
<p>空间复杂度：<code>O(N^2)</code>，其中 N表示节点数目。</p>
</blockquote>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300最长上升子序列</a></h1>
<pre><code class="language-java">class Solution &#123;
    public int lengthOfLIS(int[] nums) &#123;
        if (nums == null || nums.length == 0) &#123;
            return 0;
        &#125;
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1);
        int result = 0;
        for (int i = 0;i&lt;nums.length;i++) &#123;
            for (int j = 0;j&lt;i;j++) &#123;
                if (nums[j] &lt; nums[i]) &#123;
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                &#125;
            &#125;
            result = Math.max(result, dp[i]);
        &#125;
        return result;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/description/">344反转字符串</a></h1>
<pre><code class="language-java">class Solution &#123;
    public void reverseString(char[] s) &#123;
        int left = 0, right = s.length - 1;
        while (left &lt; right) &#123;
            char temp = s[left];
            s[left] = s[right];
            s[right] = temp;
            left++;
            right--;
        &#125;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-two-integers/">371两整数之和</a></h1>
<pre><code class="language-java">class Solution &#123;
    public int getSum(int a, int b) &#123;
        while (b != 0) &#123;
            int carry = (a &amp; b) &lt;&lt; 1;
            a = a ^ b;
            b = carry;
        &#125;
        return a;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/">378有序矩阵中第K小的元素</a></h1>
<pre><code class="language-java">class Solution &#123;
    public int kthSmallest(int[][] matrix, int k) &#123;
        int row = matrix.length;
        int col = matrix[0].length;
        int left = matrix[0][0];
        int right = matrix[row - 1][col - 1];
        while (left &lt; right) &#123;
            // 每次循环都保证第K小的数在start~end之间，当start==end，第k小的数就是start
            // 防溢出,也可以写做mid = (right +left) &gt;&gt; 1;
            int mid = left + (right - left) / 2;
            // 找二维矩阵中&lt;=mid的元素总个数
            int count = findLessThanMid(matrix, mid, row, col);
            if (count &lt; k) &#123;
                // 第k小的数在右半部分，且不包含mid
                left = mid + 1;
            &#125; else &#123;
                // 第k小的数在左半部分，可能包含mid
                right = mid;
            &#125;
        &#125;
        return right;
    &#125;

    private int findLessThanMid(int[][] matrix, int mid, int row, int col) &#123;
        // 以列为单位找，找到每一列最后一个&lt;=mid的数即知道每一列有多少个数&lt;=mid
        int i = row - 1;
        int j = 0;
        int count = 0;
        while (i &gt;= 0 &amp;&amp; j &lt; col) &#123;
            if (matrix[i][j] &lt;= mid) &#123;
                // 第j列有i+1个元素&lt;=mid
                count += i + 1;
                j++;
            &#125; else &#123;
                // 第j列目前的数大于mid，需要继续在当前列往上找
                i--;
            &#125;
        &#125;
        return count;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>时间复杂度：<code>O(nlog(r−l))</code>，二分查找进行次数为 <code>O(log⁡(r−l))</code>，每次操作时间复杂度为<code>O(n)</code>。</p>
<p>空间复杂度：<code>O(1)</code>。</p>
</blockquote>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-strings/description/">415字符串相加</a></h1>
<pre><code class="language-java">class Solution &#123;
    public String addStrings(String num1, String num2) &#123;
        StringBuilder res = new StringBuilder(&quot;&quot;);
        int i = num1.length() - 1, j = num2.length() - 1, carry = 0;
        while(i &gt;= 0 || j &gt;= 0)&#123;
            int n1 = i &gt;= 0 ? num1.charAt(i) - '0' : 0;
            int n2 = j &gt;= 0 ? num2.charAt(j) - '0' : 0;
            int tmp = n1 + n2 + carry;
            carry = tmp / 10;
            res.append(tmp % 10);
            i--; 
            j--;
        &#125;
        if(carry == 1) &#123;
          res.append(1);
        &#125;
        return res.reverse().toString();
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-iii/description/">437路径总和III</a></h1>
<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val = val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     &#125;
 * &#125;
 */
class Solution &#123;

    int result = 0;

    public int pathSum(TreeNode root, int targetSum) &#123;
        if(root == null) &#123;
            return 0;
        &#125;
        dfs(root, targetSum);
        pathSum(root.left, targetSum);
        pathSum(root.right, targetSum);
        return result;
    &#125;

    private void dfs(TreeNode root, long targetSum) &#123;
        if(root == null) &#123;
            return;
        &#125;
        if(root.val == targetSum) &#123;
            result++;
        &#125;
        dfs(root.left, targetSum - root.val);
        dfs(root.right, targetSum - root.val);
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/description/">448找到所有数组中消失的数字</a></h1>
<blockquote>
<p>遍历每个元素，对索引进行标记</p>
<ul>
<li>将对应索引位置的值变为负数</li>
</ul>
<p>遍历下索引，看看哪些索引位置上的数不是负数的</p>
<ul>
<li>位置上不是负数的索引，对应的元素就是不存在的</li>
</ul>
</blockquote>
<pre><code class="language-java">class Solution &#123;
    public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123;
        //用来存放结果
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); 
        //遍历下数组的元素，对对应的索引位置的元素作标记
        int len = nums.length;
        for(int i = 0; i &lt; len; i++)&#123;
            int num = Math.abs(nums[i]);  //由于数组的元素有可能被*-1，所以取绝对值
            int index = num - 1;
            if(nums[index] &gt; 0)&#123;
                nums[index] *= -1;
            &#125;
        &#125;      
        // 寻找没有标记的索引位置
        for(int i = 0; i &lt; len; i++)&#123;
            if(nums[i] &gt; 0)&#123;
                int num = i + 1;  //将索引转化为对应的元素
                res.add(num);
            &#125;     
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/">450删除二叉搜索树中的节点</a></h1>
<blockquote>
<p>二叉搜索树的性质：</p>
<ul>
<li>左子树的节点的值小于根节点的值，右子树的节点大于根节点的值。</li>
</ul>
</blockquote>
<blockquote>
<p>当root的值和key相等时，有四种情况：</p>
</blockquote>
<img src="/images/363.png" alt="image.png" style="zoom:50%;" />
<img src="/images/364.png" alt="image.png" style="zoom:50%;" />
<img src="/images/365.png" alt="image.png" style="zoom:50%;" />
<img src="/images/1654134742-qJVGmL-image.png" alt="image.png" style="zoom:50%;" />
<img src="/images/366.png" alt="image.png" style="zoom:50%;" />
<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val = val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     &#125;
 * &#125;
 */
    public TreeNode deleteNode(TreeNode root, int key) &#123;
        if (root == null) &#123;
            return null;
        &#125;
        if (root.val &gt; key) &#123;
            //当前节点的值大于目标值 递归去左子树寻找
            root.left = deleteNode(root.left, key);
        &#125; else if (root.val &lt; key) &#123;
            //当前节点的值小于目标值 递归去右子树寻找
            root.right = deleteNode(root.right, key);
        &#125; else &#123;
            //情况一可以和二三合并处理
            //情况二
            if (root.left == null) &#123;
                return root.right;
            &#125;
            //情况三
            if (root.right == null) &#123;
                return root.left;
            &#125;
            //情况四 
            //找到右节点的左子树中为空的位置
            TreeNode rightNode = root.right;
            while (rightNode.left != null) &#123;
                rightNode = rightNode.left;
            &#125;
            rightNode.left = root.left;
            root = root.right;
        &#125;
        return root;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543二叉树的直径</a></h1>
<pre><code class="language-java">class Solution &#123;
    int result = 0;
    public int diameterOfBinaryTree(TreeNode root) &#123;
        depth(root);
        return result;
    &#125;
    public int depth(TreeNode node) &#123;
        if (node == null) &#123;
            return 0;
        &#125;
        int L = depth(node.left);
        int R = depth(node.right);
        result = Math.max(result, L+R);
        return Math.max(L, R) + 1;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subtree-of-another-tree/description/">572另一棵树的子树</a></h1>
<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val = val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     &#125;
 * &#125;
 */
class Solution &#123;
    public boolean isSubtree(TreeNode s, TreeNode t) &#123;
        return dfs(s, t);
    &#125;

    public boolean dfs(TreeNode s, TreeNode t) &#123;
        if (s == null) &#123;
            return false;
        &#125;
        return check(s, t) || dfs(s.left, t) || dfs(s.right, t);
    &#125;

    public boolean check(TreeNode s, TreeNode t) &#123;
        if (s == null &amp;&amp; t == null) &#123;
            return true;
        &#125;
        if (s == null || t == null || s.val != t.val) &#123;
            return false;
        &#125;
        return check(s.left, t.left) &amp;&amp; check(s.right, t.right);
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/description/">617合并二叉树</a></h1>
<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val = val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     &#125;
 * &#125;
 */
class Solution &#123;
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123;
        if (t1 == null) &#123;
            return t2;
        &#125;
        if (t2 == null) &#123;
            return t1;
        &#125;
        TreeNode merged = new TreeNode(t1.val + t2.val);
        merged.left = mergeTrees(t1.left, t2.left);
        merged.right = mergeTrees(t1.right, t2.right);
        return merged;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-product-of-three-numbers/">628三个数的最大乘积</a></h1>
<pre><code class="language-java">class Solution &#123;
    public int maximumProduct(int[] nums) &#123;
        // 最小的和第二小的
        int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;
        // 最大的、第二大的和第三大的
        int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE;

        for (int x : nums) &#123;
            if (x &lt; min1) &#123;
                min2 = min1;
                min1 = x;
            &#125; else if (x &lt; min2) &#123;
                min2 = x;
            &#125;

            if (x &gt; max1) &#123;
                max3 = max2;
                max2 = max1;
                max1 = x;
            &#125; else if (x &gt; max2) &#123;
                max3 = max2;
                max2 = x;
            &#125; else if (x &gt; max3) &#123;
                max3 = x;
            &#125;
        &#125;

        return Math.max(min1 * min2 * max1, max1 * max2 * max3);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>时间复杂度：O(N)，其中 N 为数组长度，我们仅需遍历数组一次。</p>
<p>空间复杂度：O(1)。</p>
</blockquote>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-width-of-binary-tree/description/">662二叉树最大宽度</a></h1>
<blockquote>
<p>此题求二叉树所有层的最大宽度，比较直观的方法是求出每一层的宽度，然后求出最大值。</p>
<p>求每一层的宽度时，因为两端点间的 <code>null</code> 节点也需要计入宽度，因此可以对节点进行编号。</p>
<p>一个编号为 <code>index</code> 的左子节点的编号记为 <code>2×index</code>，右子节点的编号记为 <code>2×index+1</code>，计算每层宽度时，用每层节点的最大编号减去最小编号再加 1 即为宽度。</p>
<p>遍历节点时，可以用广度优先搜索来遍历每一层的节点，并求出最大值。</p>
</blockquote>
<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val = val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     &#125;
 * &#125;
 */
class Solution &#123;
    public int widthOfBinaryTree(TreeNode root) &#123;
        if(root == null) &#123;
            return 0;
        &#125;

        Deque&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        // 根节点编号为 0
        root.val = 0;
        queue.add(root);

        int sum;
        int ans = 0;
        while(!queue.isEmpty()) &#123;
            sum = queue.size();
            // 队头和队尾的编号值求差用来更新宽度
            ans = Math.max(ans, queue.getLast().val - queue.getFirst().val + 1);
            // 一次处理一层，进入这个循环前队列中是一层的所有非空节点
            while(sum &gt; 0) &#123;
                TreeNode temp = queue.remove();

                // 子节点入队前修改 val, val = 满二叉树中节点编号
                if(temp.left != null) &#123;
                    queue.add(temp.left);
                    temp.left.val = temp.val * 2 + 1;
                &#125;
                if(temp.right != null) &#123;
                    queue.add(temp.right);
                    temp.right.val = temp.val * 2 + 2;
                &#125;
                sum--;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/">674最长连续递增序列</a></h1>
<pre><code class="language-java">class Solution &#123;
    public int findLengthOfLCIS(int[] nums) &#123;
        if (nums == null || nums.length == 0) &#123;
            return 0;
        &#125;
        int count = 1, result = 1;
        for (int i =0;i&lt;nums.length - 1;i++)&#123;
            if (nums[i] &lt; nums[i+1])&#123;
                count++;
            &#125;else &#123;
                count = 1;
            &#125;
            result = Math.max(result , count);
        &#125;
        return result;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-search/">704二分查找</a></h1>
<pre><code class="language-java">class Solution &#123;
    public int search(int[] nums, int target) &#123;
        if (nums==null || nums.length == 0) &#123;
            return -1;
        &#125;
        int left = 0, right = nums.length - 1;
        while(left&lt;=right)&#123;
            int middle = left + (right - left) / 2;
            if (nums[middle]==target) &#123;
                return middle;
            &#125; else if (nums[middle] &gt; target) &#123;
                right = middle - 1;
            &#125; else &#123;
                left = middle + 1;
            &#125;
        &#125;
        return -1;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/middle-of-the-linked-list/description/">876链表的中间结点</a></h1>
<p><strong>快慢指针法</strong></p>
<blockquote>
<p>用两个指针 <code>slow</code> 与 <code>fast</code> 一起遍历链表。</p>
<p><code>slow</code> 一次走一步，<code>fast</code> 一次走两步。</p>
<p>那么当 <code>fast</code> 到达链表的末尾时，<code>slow</code> 必然位于中间。</p>
</blockquote>
<pre><code class="language-java">/**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode() &#123;&#125;
 *     ListNode(int val) &#123; this.val = val; &#125;
 *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;
 * &#125;
 */
class Solution &#123;
    public ListNode middleNode(ListNode head) &#123;
        ListNode slow = head, fast = head;
        while (fast != null &amp;&amp; fast.next != null) &#123;
            slow = slow.next;
            fast = fast.next.next;
        &#125;
        return slow;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/description/">958二叉树的完全性检验</a></h1>
<pre><code class="language-java">class Solution &#123;
    public boolean isCompleteTree(TreeNode root) &#123;
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        TreeNode prev = root;
        queue.add(root);
        while (!queue.isEmpty()) &#123;
            TreeNode node = queue.remove();
            if (prev == null &amp;&amp; node != null) &#123;
                return false;
            &#125;
            if (node != null) &#123;
                queue.add(node.left);
                queue.add(node.right);
            &#125;
            prev = node;
        &#125;
        return true;
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum-bsts/">1214查找两颗二分搜索树之和</a></h1>
<blockquote>
<p>给出两棵二叉搜索树，请你从两棵树中各找出一个节点，使得这两个节点的值之和等于目标值 Target。</p>
<p>如果可以找到返回 True，否则返回 False。</p>
<p><strong>示例 1：</strong></p>
<p>输入：root1 = [2,1,4], root2 = [1,0,3], target = 5 输出：true 解释：2 加 3 和为 5。</p>
</blockquote>
<p><strong>二分法解决:</strong></p>
<blockquote>
<p>先固定一棵树的一个节点，将目标值Target减去这个节点的值，得到新的目标值target。</p>
<p>将这个新的目标值和另外一棵树进行比较，利用二分搜索数的特性进行查找命中，从根节点开始，如果新的目标值target和根节点的值相等，则直接返回true。</p>
<p>如果新的目标值比根节点小，进行左递归查找，如果新的目标值比根节点大，进行右递归。</p>
<p>依次类推，直到树底下的节点为空，才返回false。</p>
<p>固定一棵树的一个节点，查找另一棵树的节点的时间复杂度是<code>O(logn)</code>。</p>
<p>因为一棵树需要遍历，时间复杂度是<code>O(nlogn)</code>。</p>
</blockquote>
<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) &#123; val = x; &#125;
 * &#125;
 */
class Solution &#123;
    public boolean twoSumBSTs(TreeNode root1, TreeNode root2, int target) &#123;
        if (!root1) return false;
        if (find(root2, target - root1.val)) return true;
        return twoSumBSTs(root1.left, root2, target) || 
        twoSumBSTs(root1.right, root2, target);            
    &#125;

    private boolean find(TreeNode node, int target) &#123;
        if (!node) return false;
        if (node.val == target) return true;
        else if (target &lt; node.val) return find(node.left, target);
        else return find(node.right, target);
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-missing-positive-number/">1539第K个缺失的正整数</a></h1>
<blockquote>
<p>设：<code>arr = [2,3,4,5,7,11], k = 5</code></p>
<p>可以利用数组下标来得到该位置之前缺失的元素数量，例如：</p>
<p>i = 0，此时数组元素<code>arr[i] = 2</code>，在0位置上，不缺失的情况下，对应的元素应该是1，所以缺失个数为<code>arr[i] - i - 1 = 1</code>,因为数组下标是从0开始的，而元素是从1开始的，所以计算个数的时候，除了减掉下标值之外，还需要再减1。</p>
<p>按照这个方式，能计算出该数组的每个元素对应的缺失元素个数：</p>
</blockquote>
<img src="/images/367.png" style="zoom:50%;" />
<blockquote>
<p>在这个序列中，能够通过二分查找，找到k所对应的位置，有了这个位置，就能通过对应的元素找到缺失的第k个整数。</p>
<p>举例来说，如果要找到k = 5，第5个缺失的元素，那么需要从一个确定的数向后或向前推算：</p>
<p>对于2,3,4来说，它们之前缺少1个元素，所以不考虑这些元素。</p>
<p>对于7来说，它之前缺少3个元素，那么从它开始往后推2个元素，就有可能是缺失的第5个元素。</p>
<p>前提是它后面的元素缺失数量要大于k = 5。</p>
<p>对于11来说，它之前缺少6个元素，要找的第5个元素，一定是在它之前缺失的，那从它开始往前推2个元素（第6个，第5个），就是要找的缺失的第5个元素。</p>
<p>根据这种分析，就可以在这个缺失数量的序列上进行二分查找，确定一个区间<code>[i,j]</code>，满足<code>lack[i] &lt; k &lt;= lack[j]</code>，则第k个缺失的数为<code>k - (arr[i] - i - 1) + arr[i]</code>，<code>arr[i] - i - 1</code>表示<code>arr[i]</code>位置缺少的元素个数，<code>k - 缺失个数</code>表示从<code>arr[i]</code>开始还缺少几个元素，再加上<code>arr[i]</code>，就是第k个缺失的元素。</p>
</blockquote>
<pre><code class="language-java">class Solution &#123;
    public int findKthPositive(int[] arr, int k) &#123;
        // 第一个数比缺失的数要大的话，直接返回k
        if(arr[0] &gt; k)&#123;
            return k;
        &#125;
        // 找到缺失数量大于k的最小的位置
        int left = 0, right = arr.length;
        while(left &lt; right)&#123;
            int mid = left + (right - left) / 2;
            int x = mid &lt; arr.length ? arr[mid] : Integer.MAX_VALUE;
            if(x - mid - 1 &gt;= k)&#123;
                right = mid;
            &#125;else&#123;
                left = mid + 1;
            &#125;
        &#125;
        // 第k个缺失的数 - （最小位置之前的那个数所缺失的个数） + 最小位置前面的那个数
        // 5 - （7 - 3 - 1） + 7 = 第五个缺失的数 - 7前面有3个缺失的数 + 7
        return k - (arr[left - 1] - (left - 1) - 1) + arr[left - 1];
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143最长公共子序列</a></h1>
<blockquote>
<p>定义一个二维数组 dp 用来存储最长公共子序列的长度，其中 <code>dp[i][j]</code> 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。</p>
</blockquote>
<pre><code class="language-java">class Solution &#123;
    public int longestCommonSubsequence(String text1, String text2) &#123;
        int n1 = text1.length(), n2 = text2.length();
        int[][] dp = new int[n1+1][n2+1];
        for (int i = 1;i &lt;= n1;i++) &#123;
            for (int j = 1;j&lt;=n2;j++) &#123;
                if(text1.charAt(i-1) == text2.charAt(j-1)) &#123;
                    dp[i][j] = dp[i-1][j-1] + 1;
                &#125; else &#123;
                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
                &#125;
            &#125;
        &#125;
        return dp[n1][n2];
    &#125;
&#125;
</code></pre>
<h1><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-nesting-depth-of-the-parentheses/">1614括号的最大嵌套深度</a></h1>
<pre><code class="language-java">class Solution &#123;
    public int maxDepth(String s) &#123;
        int ans = 0, size = 0;
        for (int i = 0; i &lt; s.length(); ++i) &#123;
            char ch = s.charAt(i);
            if (ch == '(') &#123;
                ++size;
                ans = Math.max(ans, size);
            &#125; else if (ch == ')') &#123;
                --size;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;
</code></pre>

	</div>
</div>


    <div class="post-guide">
        <div class="item left">
            
              <a href="/2022/11/26/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E5%89%91%E6%8C%87OFFER/">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  剑指OFFER
              </a>
            
        </div>
        <div class="item right">
            
              <a href="/2022/11/25/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/">
                面试算法
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>




<script>

    //document.oncontextmenu=new Function("event.returnValue=false");
	//document.onselectstart=new Function("event.returnValue=false");

	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "https://hm.baidu.com/hm.js?7eeb54583579fabc0878be210d6ad60a";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();

	

	$(function () {
		const btw = new BTWPlugin();
	    btw.init({
	        id: 'container',
	        blogId: '22377-1706525467336-300',
	        name: '月伴飞鱼',
	        qrcode: '/小程序码.jpg',
	        keyword: '验证码',
	        btnText: '为防止机器刷接口，需要完成人机检测',
        	cookieAge: 1
	    });

	    var contents = document.getElementsByClassName("content999");
	    //监听文章内容的copy事件
	    contents[0].addEventListener('copy',function(e){
	        setClipboardText(e);
	    });

	    function setClipboardText(event){
	        // clipboardData 对象是为通过编辑菜单、快捷菜单和快捷键执行的编辑操作所保留的，也就是你复制或者剪切内容
	        let clipboardData = event.clipboardData || window.clipboardData;

	        // 如果未复制或者未剪切，则return出去
	        if (!clipboardData) { return; }

	        event.preventDefault();

	        // Selection 对象，表示用户选择的文本范围或光标的当前位置。
	        // 声明一个变量接收 -- 用户输入的剪切或者复制的文本转化为字符串
	        let text = window.getSelection().toString();
	    
	        if (text) {
	            // 如果文本存在则先取消文本默认事件
	            event.preventDefault();
	            // 通过调用常clipboardData对象的 setData(format, data) 方法；来设置相关文本
	            // format: 一个DOMString 表示要添加到 drag object的拖动数据的类型。
	            // data: 一个 DOMString表示要添加到 drag object的数据。
	            var copyright = '\n\n'
	            + '\n著作权归作者所有。'
	            + '\n商业转载请联系作者获得授权，非商业转载请注明出处。'
	            + '\n作者: 月伴飞鱼'
	            + '\n原文地址: http://hardyfish.top/2022/11/26/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/LeetCode/'
	    
	            clipboardData.setData('text/plain', text + copyright);
	    
	        }
	    };
	});

	
</script>

<script>
    const btw = new BTWPlugin();
    btw.init({
        id: 'container',
        blogId: '22377-1706525467336-300',
        name: '月伴飞鱼',
        qrcode: '/小程序码.jpg',
        keyword: '验证码',
        btnText: '为防止机器刷接口，需要完成人机检测',
        cookieAge: 1
    });

	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "https://hm.baidu.com/hm.js?7eeb54583579fabc0878be210d6ad60a";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
</script>
	</div>
	<div id="footer">
	<p>
	©2019-<span id="footerYear"></span> 
	<a href="/">月伴飞鱼</a> 
	
	
		|
		<span id="busuanzi_container_site_pv">
			PV 180986
		</span>
		|
		<span id="busuanzi_container_site_uv"> 
			UV 10079
		</span>
	
	<br>
	微信搜索 <a href="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/个人公众号.jpg" target="_blank">月伴飞鱼</a> 关注我
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>
	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>