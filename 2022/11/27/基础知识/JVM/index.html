<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		JVM | 
	 
	月伴飞鱼
	</title>
	
	<!-- keywords,description -->
	 

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/%E5%A4%B4%E5%83%8F.jpg">
	
  
  	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="/css/jquery.fancybox.min.css">

	
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="/lib/highlight/darcula.css">

	
<link rel="stylesheet" href="/css/clipboard-use.css">


	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">

	
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>


	
<script src="/lib/highlight/highlight.min.js"></script>

	
<script src="https://readmore.openwrite.cn/js/readmore.js"></script>

	
<script src="/lib/jquery-3.4.1.min.js"></script>

	
<script src="/lib/jquery.pjax.js"></script>


	
<script src="/js/main.js"></script>

	
<script src="/js/jquery.fancybox.min.js"></script>

	
		
<script src="/lib/valine/av-3.0.4-min.js"></script>

		
<script src="/lib/valine/Valine-1.3.10-min.js"></script>

	
	
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
	
<script src="/js/clipboard.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body oncontextmenu="return false;">
	<header id="header">
    <a id="title" href="/" class="logo">公众号月伴飞鱼</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">关于我</a>
		</li>

	    <li class="menu-item">
			<a href="/site" class="menu-item-link">关于网站</a>
		</li>

		<li class="menu-item">
			<a href="/个人公众号.jpg" class="menu-item-link" target="_blank">我的公众号</a>
		</li>
		
		<li class="menu-item">
			<a href="https://tech.meituan.com/" class="menu-item-link" target="_blank">
				美团技术团队
			</a>
		</li>
		<li class="menu-item">
			<a href="https://tech.youzan.com/" class="menu-item-link" target="_blank">
				有赞技术团队
			</a>
		</li>
		<!--<li class="menu-item">
			<select class="menu-item-link menu-item-select">
				<option class="menu-item-link"  value="volvo">Volvo</option>
				<option class="menu-item-link"  value="saab">Saab</option>
				<option class="menu-item-link"  value="fiat">Fiat</option>
				<option class="menu-item-link"  value="audi">Audi</option>
			</select>
		</li>-->
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="text" placeholder="按目录搜索一下">
		<div id="tree">
			

			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										中间件
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/30/%E4%B8%AD%E9%97%B4%E4%BB%B6/Dubbo/">
										Dubbo
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/12/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/Elasticsearch/">
										Elasticsearch
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/30/%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty/">
										Netty
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/ZooKeeper/">
										ZooKeeper
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										代码思想
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/11/02/%E4%BB%A3%E7%A0%81%E6%80%9D%E6%83%B3/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/">
										代码重构
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										前端相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/CSS/">
										CSS
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/Vue/">
										Vue
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/12/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">
										小程序
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										基础知识
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/11/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Go%E5%9F%BA%E7%A1%80/">
										Go基础
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file active">
									<a href="/2022/11/27/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM/">
										JVM
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/11/21/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E5%9F%BA%E7%A1%80/">
										Java基础
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F/">
										分布式
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/12/10/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">
										并发编程
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
										设计模式
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										娱乐相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/27/%E5%A8%B1%E4%B9%90%E7%9B%B8%E5%85%B3/%E4%B9%A6%E7%B1%8D/">
										书籍
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/10/%E5%A8%B1%E4%B9%90%E7%9B%B8%E5%85%B3/%E7%94%B5%E5%BD%B1/">
										电影
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/05/%E5%A8%B1%E4%B9%90%E7%9B%B8%E5%85%B3/%E7%9F%A5%E8%AF%86/">
										知识
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/09/%E5%A8%B1%E4%B9%90%E7%9B%B8%E5%85%B3/%E9%9F%B3%E4%B9%90/">
										音乐
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										学习专栏
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/31/%E5%AD%A6%E4%B9%A0%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%91/">
										代码之丑
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/26/%E5%AD%A6%E4%B9%A0%E4%B8%93%E6%A0%8F/%E5%A4%A7%E5%8E%82%E6%99%8B%E5%8D%87%E6%8C%87%E5%8D%97/">
										大厂晋升指南
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										学习书籍
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/11/16/%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/">
										Java开发手册
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										工具相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/11/09/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Arthas/">
										Arthas
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/21/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/GIT/">
										GIT
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/21/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Hexo/">
										Hexo
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/21/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/MAC/">
										MAC
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/01/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Maven/">
										Maven
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/">
										实用工具
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										成长相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/31/%E6%88%90%E9%95%BF%E7%9B%B8%E5%85%B3/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">
										技术学习
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/09/%E6%88%90%E9%95%BF%E7%9B%B8%E5%85%B3/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/">
										面试相关
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										数据库
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/27/%E6%95%B0%E6%8D%AE%E5%BA%93/HBase/">
										HBase
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/09/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/">
										MongoDB
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/12/02/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">
										MySQL
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/">
										Redis
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										服务器
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E6%9C%8D%E5%8A%A1%E5%99%A8/Docker/">
										Docker
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/09/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/">
										Nginx
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/03/%E6%9C%8D%E5%8A%A1%E5%99%A8/Tomcat/">
										Tomcat
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/09/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E8%BF%90%E7%BB%B4%E7%9F%A5%E8%AF%86/">
										运维知识
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										架构相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/21/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/DDD/">
										DDD
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/02/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/%E6%9E%B6%E6%9E%84%E5%9B%BE/">
										架构图
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/02/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0/">
										架构学习
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/26/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/%E7%B3%BB%E7%BB%9F%E4%BF%9D%E9%9A%9C/">
										系统保障
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/31/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD/">
										系统性能
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/26/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">
										系统设计
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										框架相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/11/15/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/JWT/">
										JWT
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/08/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/MyBatis/">
										MyBatis
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/14/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/RPC%E6%A1%86%E6%9E%B6/">
										RPC框架
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/26/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/Seata/">
										Seata
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/14/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/Spring/">
										Spring
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/03/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/Thrift/">
										Thrift
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/10/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/">
										开源框架
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										消息队列
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/KAFKA/">
										KAFKA
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/">
										RocketMQ
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										算法相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/11/26/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/LeetCode/">
										LeetCode
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/11/26/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E5%89%91%E6%8C%87OFFER/">
										剑指OFFER
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/11/25/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/">
										面试算法
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										系统相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/11/19/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/">
										任务系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/18/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/%E5%B9%BF%E5%91%8A%E7%B3%BB%E7%BB%9F/">
										广告系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/19/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/%E6%89%93%E8%BD%A6%E7%B3%BB%E7%BB%9F/">
										打车系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/18/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/">
										推荐系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/19/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F/">
										用户系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/19/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/">
										直播系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/19/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/%E7%9F%AD%E9%93%BE%E7%B3%BB%E7%BB%9F/">
										短链系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/19/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/%E7%A4%BE%E5%8C%BA%E7%B3%BB%E7%BB%9F/">
										社区系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/19/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/">
										秒杀系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/19/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/">
										红包系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/18/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F/">
										订单系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										英语相关
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										老友记
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/08/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E8%80%81%E5%8F%8B%E8%AE%B0/%E7%AC%AC%E4%B8%80%E5%AD%A3/">
										第一季
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/08/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E8%80%81%E5%8F%8B%E8%AE%B0/%E7%AC%AC%E4%B8%89%E5%AD%A3/">
										第三季
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/23/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E8%80%81%E5%8F%8B%E8%AE%B0/%E7%AC%AC%E4%BA%94%E5%AD%A3/">
										第五季
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										雅思
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/12/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E9%9B%85%E6%80%9D/%E5%89%91%E6%A1%A5%E9%9B%85%E6%80%9D%E5%90%AC%E5%8A%9B%E7%9C%9F%E9%A2%98/">
										剑桥雅思听力真题
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										计算机基础
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
										操作系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
										数据结构
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/">
										算法知识
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/12/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">
										网络基础
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">

	JVM
</h1>
<div class="article-meta">
	<span>月伴飞鱼</span>
	<span>2022-11-27 22:44:24</span>
    
		<div id="article-categories">
            
                
                    <span>
                        <i class="fa fa-folder" aria-hidden="true"></i>
                        <a href="/categories/基础知识/">基础知识</a>
						
                    </span>
                
            
		</div>
    
</div>

<div id="container" class = "content999" oncontextmenu="return false;">
	<div id="article-content">
		<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><p><strong>内存结构</strong></p>
<blockquote>
<p>堆：</p>
<ul>
<li>存放对象实例, 几乎所有的对象实例以及数组都在这里分配内存。</li>
</ul>
<p>虚拟机栈:</p>
<ul>
<li>栈帧:用于支持虚拟机进行方法执行的数据结构。<ul>
<li>存储了方法的<code>局部变量表</code>， 操作数栈，动态连接和返回地址等地址。</li>
<li>每个方法从调用到执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程。</li>
<li>栈内存为线程私有的空间, 每个线程都会创建私有的栈没存, 生命周期与线程相同。</li>
<li>除了一些 Native方法调用是通过本地方法栈实现的, 其他所有Java方法调用都是栈来实现的。</li>
</ul>
</li>
</ul>
<p>本地方法栈：</p>
<ul>
<li><p>和虚拟机栈非常相似，区别如下:</p>
<ul>
<li><p>虚拟机栈执行 Java 方法服务。</p>
</li>
<li><p>本地方法栈使用到的 Native方法(例如 C++ 程序)服务。</p>
</li>
</ul>
</li>
</ul>
<p>方法区:</p>
<ul>
<li>各个线程共享的内存区域。</li>
<li>存储已经被虚拟机加载的类型信息，常量，静态变量，即时编译器编译后的代码缓存等数据。</li>
<li>具体实现: 永久代，元空间。</li>
</ul>
<p>永久代和元空间的区别:</p>
<ul>
<li><p>JDK1.8之前是永久代。</p>
</li>
<li><p>JDK1.8之后是元空间。</p>
</li>
<li><p>存储位置：</p>
<ul>
<li>永久代使用的内存区域是 JVM进程所使用的区域，大小受 JVM的大小限制。</li>
<li>元空间使用的是物理内存区域，元空间大小只受物理内存大小的限制。</li>
</ul>
</li>
<li><p>存储内容不同：</p>
<ul>
<li>永久代主要存储方法区存储内容中的数据。</li>
<li>元空间只存储类的元信息，而静态变量和运行时常量池都在堆中。</li>
</ul>
</li>
</ul>
<p>程序计数器：</p>
<ul>
<li>一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。</li>
<li>每条线程都有一个独立的程序计数器，各线程之间的计数器互不影响，为线程私有。</li>
</ul>
<p>程序计数器的作用:</p>
<ul>
<li>多线程的情况下，用来记录当前执行的位置，当线程切换回来时能正确运行。</li>
<li>字节码解释器通过改变程序计数器来以此读取指令，从而实现代码的流程控制: 如: 选择, 循环, 顺序执行, 异常处理等。</li>
</ul>
<p>程序计数器是唯一不会出现<code>OutOfMemoryError</code>异常的内存区域，其生命周期随着线程的创建而生，线程的销毁为亡。</p>
</blockquote>
<img src="/images/image-20231024202233389.png" alt="image-20231024202233389" style="zoom:30%;" />

<p><strong>堆结构</strong></p>
<blockquote>
<p>基于<strong>分代收集理论</strong>设计，分为<strong>年轻代和老年代</strong>，其中年轻代又分为<strong>Eden区和Survivor 0区和Survivor 1区（Survivor0和Survivor1也叫From和To区）</strong></p>
<ul>
<li>默认情况下，<strong>老年代占总的堆内存的2&#x2F;3，年轻代占1&#x2F;3</strong></li>
</ul>
</blockquote>
<p><img src="/images/image-20231026171802543.png" alt="image-20231026171802543"></p>
<p><strong>符号引用</strong></p>
<blockquote>
<p>在JVM中，一个类的方法名、类名、修饰符、返回值等等都是一系列的符号，而这些符号都是一个个的常量，存储在常量池中。</p>
<p>同时这些个符号被加载到内存后，都有对应的内存地址，而这些内存地址就是直接引用。</p>
</blockquote>
<p><strong>动态链接</strong></p>
<blockquote>
<p>符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。 </p>
<p>另外一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接。</p>
</blockquote>
<p><strong>方法出口</strong></p>
<blockquote>
<p>方法出口就是方法执行完成后，需要返回的一些信息。</p>
<p>一般来说，方法正常退出时，方法的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。</p>
<p>而方法异常退出时，返回地址是要通过<strong>异常处理器表</strong>来确定的，栈帧中就一般不会保存这部分信息。</p>
</blockquote>
<p><strong>操作数栈</strong></p>
<blockquote>
<p>就是存放方法运行过程中产生的一些临时数据，目的是为了计算，以栈的数据结构进行存储。</p>
</blockquote>
<p><strong>局部变量表</strong></p>
<blockquote>
<p>方法内部的变量都是存放在局部变量表中。</p>
<p>如果是对象类型，局部变量表中存放的是堆给对象分配的内存地址，也就是指针，而不是对象直接存在局部变量表中。</p>
</blockquote>
<p><strong>元空间</strong></p>
<blockquote>
<p>在JDK1.7之前，HotSpot 虚拟机把方法区当成永久代（方法区的落地实现）来进行垃圾回收。</p>
<p>JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</p>
<p>HotSpots取消了永久代，那么是不是也就没有方法区了呢？</p>
<ul>
<li>不是，方法区是一个规范，规范没变，它就一直在，只不过取代永久代的是元空间（Metaspace)而已。</li>
</ul>
</blockquote>
<p>它和永久代有什么不同的？</p>
<blockquote>
<p>存储位置不同：</p>
<ul>
<li>永久代在物理上是堆的一部分，和新生代、老年代的地址是连续的，而元空间属于本地内存。</li>
</ul>
<p>存储内容不同：</p>
<ul>
<li>在原来的永久代划分中，永久代用来存放类的元数据信息、静态变量以及常量池等。</li>
<li>现在类的元信息存储在元空间中，静态变量和常量池等并入堆中，相当于原来的永久代中的数据，被元空间和堆内存给瓜分了。</li>
</ul>
</blockquote>
<img src="/images/image-20231021170545015.png" alt="image-20231021170545015" style="zoom:50%;" />

<p>为什么要废弃永久代，引入元空间？</p>
<blockquote>
<p>在原来的永久代划分中，永久代需要存放类的元数据、静态变量和常量等。</p>
<p>它的大小不容易确定，因为这其中有很多影响因素，比如类的总数，常量池的大小和方法数量等，<code>-XX:MaxPermSize</code> 指定太小很容易造成永久代内存溢出。</p>
<p>移除永久代是为融合HotSpot VM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。</p>
<ul>
<li>永久代会为GC带来不必要的复杂度，并且回收效率偏低。</li>
</ul>
</blockquote>
<p>废除永久代的好处:</p>
<blockquote>
<p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间，不会遇到永久代存在时的内存溢出错误。</p>
<p>将运行时常量池从PermGen分离出来，与类的元数据分开，提升类元数据的独立性。</p>
<p>将元数据从PermGen剥离出来到Metaspace，可以提升对元数据的管理同时提升GC效率。</p>
</blockquote>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p><strong>对象的生命周期</strong></p>
<p>对象的创建流程：</p>
<blockquote>
<p>开始 new一个对象</p>
<p>进行常量池检查</p>
<ul>
<li>看能否在常量池中定位到这个类的符号引用, 定位不到则加载类</li>
<li>看是否加载过这个类, 没加载过则加载类</li>
</ul>
<p>分配内存空间</p>
<ul>
<li>指针碰撞: GC不带压缩功能, Serial和ParNew</li>
<li>空闲列表: GC带压缩功能, CMS</li>
</ul>
<p>内存空间初始化为零值:</p>
<ul>
<li>保证了对象的实例字段在不赋初始值就直接使用, 程序能访问到这些字段的数据类型所对应的零值</li>
</ul>
<p>必要信息设置</p>
<ul>
<li>对象类的元数据</li>
<li>对象的哈希码</li>
<li>GC分代年龄 -&gt; 对象头</li>
</ul>
<p>init()</p>
</blockquote>
<p><img src="/images/image-20231021164000947.png" alt="image-20231021164000947"></p>
<p><strong>对象的内存分配方式</strong></p>
<p>指针碰撞:</p>
<blockquote>
<p>假设堆中的内存是绝对规整的, 所有用过的内存放一边, 未使用内存放另一边, 中间边界线就可以类比为指针, 内存分配就是把指针向未分配的区域挪一段与对象大小相等的距离, 这就是指针碰撞。</p>
</blockquote>
<p>空闲列表：</p>
<blockquote>
<p>如果堆中的内存不是很规整的, 已使用和未使用的内存就会相互交错, 这个时候就要维护一个列表来记录所有已使用和未使用的内存块, 在分配内存时从列表找到一块足够大的空间划分给对象实例, 并更新内存列表。</p>
</blockquote>
<table>
<thead>
<tr>
<th>分配方法</th>
<th>说明</th>
<th>收集器</th>
</tr>
</thead>
<tbody><tr>
<td>指针碰撞</td>
<td>内存地址是连续的(新生代)</td>
<td>Serial和 ParNew收集器</td>
</tr>
<tr>
<td>空闲列表</td>
<td>内存地址不连续(老年代)</td>
<td>CMS收集器和 Mark-Sweep收集器</td>
</tr>
</tbody></table>
<p><strong>对象的内存布局</strong></p>
<p>在堆内存中, 一个对象的的存储布局可以分为三个区域:</p>
<blockquote>
<p>对象头: </p>
<ul>
<li><p>存储对象自身的运行时数据(哈希吗+GC分代年龄+锁状态标准)</p>
</li>
<li><p>类型指针: 类元素的指针, 虚拟机通过这个指针来确定这个对象是哪个类的实例</p>
</li>
</ul>
<p>实例数据: </p>
<ul>
<li>存储对象真正的有效信息, 例如: 非静态变量也会存入堆空间</li>
</ul>
<p>对齐填充: </p>
<ul>
<li>JVM内对象都采用<code>8byte</code>对齐, 不够<code>8byte整数倍</code>的就需要通过对齐填充来补全</li>
</ul>
</blockquote>
<img src="/images/image-20231021164641584.png" alt="image-20231021164641584" style="zoom:80%;" />

<p><strong>如何访问一个对象</strong></p>
<p>对象的访问方式由虚拟机决定, 目前主流的访问方式有以下两种</p>
<blockquote>
<p>句柄:</p>
<ul>
<li>使用句柄的话, 堆中会专门划分出一块内存来作为句柄池, <code>reference中存储对象句柄的地址</code>, 句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。</li>
</ul>
<p>直接指针: </p>
<ul>
<li>访问速度快, 节省了一次指针定位的开销</li>
<li>直接访问, <code>reference中存储的就是对象的地址</code>, 节省了一次指针定位的开销</li>
</ul>
</blockquote>
<p><strong>强、软、弱、虚引用</strong></p>
<blockquote>
<p><strong>四种引用的目的是让程序自己决定对象的生命周期</strong>，通过垃圾回收器对这四种引用做不同的处理，来实现对象生命周期的改变。</p>
</blockquote>
<p>强引用:</p>
<blockquote>
<p>如果一个对象具有强引用，那<strong>垃圾收器绝不会回收它</strong>。</p>
<p>当内存空间不足，<strong>宁愿抛出OutOfMemoryError错误，使程序异常终止</strong>，也不会靠随意回收具有强引用对象来解决内存不足的问题。</p>
<p>如：<code>Object obj = new Object()；</code>这种就是强引用。</p>
</blockquote>
<p>软引用：</p>
<blockquote>
<p>在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行第二次回收。</p>
<p>如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
<ul>
<li>使用软引用的方式是SoftReference。</li>
</ul>
<p><strong>软引用通常用在对内存敏感的程序中，比如高速缓存就有用到软引用，内存够用的时候就保留，不够用就回收。</strong></p>
</blockquote>
<p>弱引用：</p>
<blockquote>
<p>在垃圾回收时，如果这个对象只被弱引用关联（没有任何强引用关联他），那么这个对象就会被回收。</p>
<ul>
<li>只要垃圾回收，不管内存够不够用，弱引用都会被回收。</li>
</ul>
<p>使用弱引用的方式是类WeakReference。</p>
</blockquote>
<p>虚引用：</p>
<blockquote>
<p>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，它不能单独使用也不能通过它访问对象，虚引用必须和引用队列（RefenenceQueue）联合使用。</p>
<ul>
<li><p>主要作用是跟踪对象垃圾回收的状态。</p>
</li>
<li><p>提供了一种确保对象被 Finalize 以后，做某些事情的机制。</p>
</li>
</ul>
<p><strong>设置虚引用的唯一目的，就是在这个对象被回收器回收的时候收到一个系统通知或者后续添加进一步的处理</strong></p>
</blockquote>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p><strong>GC类型</strong></p>
<p>Minor GC(Young GC):</p>
<blockquote>
<p>新生代收集（ Minor GC&#x2F;Young GC ）：</p>
<ul>
<li>当年轻代空间不足时，就会触发Minor GC。</li>
</ul>
<p>整个年轻代中又可以分为<strong>Eden区和survivor区</strong>，survivor区又分为survivor0和survivor1。</p>
<ul>
<li>Eden区和Survivor0区和Survivor1区，之间的配比是<strong>8：1：1（默认情况下）</strong></li>
</ul>
<p><strong>年轻代GC回收过程：</strong></p>
<ul>
<li><p>当Eden区被对象塞满后就会发生GC。</p>
</li>
<li><p>在eden区中筛选出来有用的对象，把有用的对象复制到<code>survivor0/survivor1</code>，第一次随机分配，假设分配到survivor0<strong>，剩下</strong>eden区的对象都是垃圾对象，直接干掉。</p>
</li>
<li><p>程序继续执行，eden区的对象又放不下了，又触发Minor GC，这次它不仅会回收eden区，还会回收survivor0区的垃圾对象，把eden区和survivor0区的有用对象一起放到<code>survivor1</code>区，eden区和<code>survivor0</code>区剩余的垃圾对象直接干掉。</p>
</li>
<li><p>程序继续执行，eden区的对象又放不下了，又会触发Minor GC，这次它不仅会回收eden区，还会回收survivor1区的垃圾对象，把eden区和survivor1区的引用对象一起放到<code>survivor0</code>区，eden区和<code>survivor1</code>区剩余的垃圾对象直接干掉。</p>
</li>
<li><p>依次往复循环，直到超过了一定的次数，对象就会放到老年代区，老年代放不下就要执行Full GC了。</p>
</li>
</ul>
</blockquote>
<p>老年代收集（Major GC&#x2F;Old GC）：老年代的垃圾收集。</p>
<blockquote>
<p>在老年代空间不足时，则触发Major GC。</p>
</blockquote>
<p><strong>对象什么情况会进入老年代？</strong></p>
<p>大对象：</p>
<blockquote>
<p>需要大量连续内存空间的对象，最典型的大对象就是那种很长的字符串以及数组。</p>
</blockquote>
<p>长期存活的对象：</p>
<blockquote>
<p>虚拟机给每个对象定义了一个对象年龄(Age)计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1，对象在Survivor区中每熬过一次Minor GC，年龄就增加1，当他的年龄增加到一定程度(默认是15岁), 就将会被晋升到老年代中。</p>
<ul>
<li>对象晋升到老年代的年龄阈值，可以通过参数<code>-XX:MaxTenuringThreshold</code>设置。</li>
</ul>
</blockquote>
<p>动态对象年龄判定：</p>
<blockquote>
<p>如果在Survivor空间中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
</blockquote>
<p>空间分配担保：</p>
<blockquote>
<p>在一次安全Minor GC 中，存活的对象不能在另一个Survivor 完全容纳，则会通过担保机制进入老年代。</p>
</blockquote>
<p><strong>什么样的对象会被回收？</strong></p>
<p>引用计数法：</p>
<blockquote>
<p>给对象中添加一个引用计数器，每当有一个地方引用他时，计数器值就+1。</p>
<p>当引用失效时，计数器值就-1，任何时刻计数器为0的对象就是不可能在被使用。、</p>
<p>无法解决对象之间互相引用的情况。</p>
<ul>
<li>A到B，B到C，C到A，相互引用，但是他们垃圾的话，用引用计数是无法被回收的。</li>
</ul>
</blockquote>
<p>可达性分析算法：</p>
<blockquote>
<p>通过GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的，这些对象就会被当作垃圾从而被回收掉的。</p>
</blockquote>
<p>哪些是GCRoots对象的根:</p>
<blockquote>
<p>虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象</p>
<p>方法区中的类静态属性引用的对象</p>
<p>方法区中常量引用的对象</p>
<p>本地方法栈中（Native方法）引用的对象</p>
</blockquote>
<p><strong>触发Full GC执行的情况？</strong></p>
<blockquote>
<p>调用<code>System.gc()</code>时，系统建议执行Full GC，但是不必然执行。</p>
<p>老年代空间不足。</p>
<p>方法区空间不足。</p>
<p>通过Minor GC后进入老年代的平均大小 大于 老年代的可用内存。</p>
<ul>
<li>Eden、Survivor Space0（From Space）区 向Survivor Space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存 小于 该对象大小。</li>
</ul>
</blockquote>
<p><strong>空间分配担保机制</strong></p>
<blockquote>
<p>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间 是否大于 新生代所有对象的总空间。</p>
<ul>
<li><p>如果大于，则此次Minor GC是安全的。</p>
</li>
<li><p>如果小于，则虚拟机会查看 <code>-XX:HandlePromotionFailure</code> 设置值是否允许担保失败。</p>
</li>
</ul>
<p>如果<code>HandlePromotionFailure=true</code>，那么会继续 检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。</p>
<ul>
<li><p>如果大于，则尝试进行一次Minor GC。</p>
</li>
<li><p>如果小于，则进行一次Full GC。</p>
</li>
</ul>
<p>如果<code>HandlePromotionFailure=false</code>，则进行一次Full GC。</p>
</blockquote>
<p><img src="/images/image-20231021164242524.png" alt="image-20231021164242524"></p>
<p><strong>安全点</strong></p>
<blockquote>
<p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为安全点(Safepoint)。</p>
<p>当JVM触发GC时，首先会让所有的用户线程到达安全点SafePoint时阻塞，也就是STW，然后枚举根节点，即找到所有的GC Roots，然后就可以从这些GC Roots向下搜寻，可达的对象就保留，不可达的对象就回收。</p>
</blockquote>
<p><strong>三色标记算法</strong></p>
<blockquote>
<p>根据CMS的运行过程来看，它的低停顿是在<strong>并发标记</strong>、<strong>并发收集</strong>阶段，做成并行，而没有<strong>STW</strong>，但是这样做会带来一个问题：</p>
<ul>
<li>由于用户程序的执行，对象的状态很容易发生变化，原本有GC Roots引用的对象，现在没有GC Roots引用了&#x2F;原本是垃圾对象，后面又复活了，又不是垃圾对象了，引用状态的改变，对JVM来说是很不可控的一种行为。</li>
</ul>
<p>为了解决这个问题，JVM引入了<strong>三色标记</strong>这个解决方案。</p>
</blockquote>
<p>GCRoot如果想查找到存活对象，会根据可达分析算法分析，遍历整个引用链，按照是否访问过该对象分成三种不同的颜色：</p>
<ul>
<li>白色、灰色、黑色。</li>
</ul>
<blockquote>
<p><strong>白色：</strong></p>
<ul>
<li>对象没有被访问过 （没有被GCRoot扫描过，有可能是为垃圾对象）。</li>
</ul>
<p><strong>灰色：</strong></p>
<ul>
<li>对象已经被访问过（被GCRoot扫描过），且对象中的属性没有被GCRoot扫描，该对象就是为灰色对象。</li>
<li>如果该对象的属性被扫描的情况下，从灰色变为黑色。</li>
</ul>
<p><strong>黑色：</strong></p>
<ul>
<li>对象已经被访问过（被GCRoot扫描过），且本对象中的属性已经被GCRoot扫描过，该对象就是为黑色对象。</li>
</ul>
</blockquote>
<p>三色标记算法原理：</p>
<img src="/images/image-20231026113802190.png" alt="image-20231026113802190" style="zoom:60%;" />

<blockquote>
<p>在初始阶段的时候，所有的对象都是存放在白色容器中。</p>
<p>初始标记阶段，GCRoot标记直接关联对象置为灰色。</p>
<p>并发标记阶段，扫描整个引用链，有子节点的话，则当前节点变为黑色，子节点变为灰色。</p>
<p>在白色盒子剩下的对象都是为没有被GCRoot关联的对象，可能会被垃圾回收机制清理。</p>
<p>下次GCRoot起点从灰色节点开始计算。</p>
</blockquote>
<p>三色标记算法缺陷：</p>
<blockquote>
<p>在并发标记阶段的时候，因为用户线程与GC线程同时运行，有可能会产生多标或者漏标。</p>
<p><strong>多标:</strong> </p>
<ul>
<li>在并发标记阶段，把一个GC Roots引用链上的对象已经标记了，但是用户线程没有停止，当方法结束的时候，这个对象链上可能都是垃圾对象，称为浮动垃圾。</li>
</ul>
<p><strong>漏标:</strong> </p>
<ul>
<li>在并发标记阶段，原先已经被扫描过的对象重新有了新的引用，导致无法被扫描。</li>
</ul>
</blockquote>
<p>CMS解决漏标问题：<strong>增量更新</strong>方式：</p>
<blockquote>
<p>当黑色对象插入新的指向<strong>白色对象</strong>的引用关系的时候，就将这个新插入的引用记录下来，等<strong>并发标记</strong>结束之后，等到<strong>重新标记阶段，会stop the world</strong>再将这些记录过的引用关系中的<strong>黑色对象</strong>为根，重新扫描一次。</p>
</blockquote>
<p>G1如何解决漏标问题：<strong>原始快照STAB</strong>方式：</p>
<blockquote>
<p>当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用关系记录下来，在并发标记结束之后，等到重新标记阶段，会stop the world再讲这些记录过的引用关系中的灰色对象为根，重新扫描一次，这样就能扫描到白色对象，将这些白色对象标记成黑色对象<strong>，</strong>目的就是让这种对象在本次GC中存下来，等待下一轮GC的时候重新扫描，这个对象也有可能是浮动垃圾。</p>
</blockquote>
<p>增量更新针对的是<code>新增</code>，原始快照针对的是<code>删除</code>。</p>
<blockquote>
<p>无论是<strong>插入</strong>和<strong>删除</strong>，JVM的记录操作都是通过<strong>写屏障</strong>实现的，<strong>STAB</strong>是写前屏障，<strong>增量更新</strong>是写后屏障。</p>
</blockquote>
<p><strong>跨代引用</strong></p>
<blockquote>
<p>跨代引用是指年老代空间中的对象引用了新生代的对象，或者新生代中的对象引用了年老代中的对象。</p>
<p>面对这种情况，在进行可达性分析扫描存活对象时，不可能从新生代一直扫描至年老代的，因为这样就会出现整堆扫描的情况，效率必然会很低。</p>
<p>在HotSpot虚拟机中，为了解决跨代引用的问题，会专门在内存中开辟一块小空间用于维护这些特殊的引用，从而达到让GC不必扫描整个堆空间的目的，而开辟的这块小空间则被称为<strong>记忆集、卡表</strong>。</p>
</blockquote>
<p>记忆集（Remember Set）：</p>
<blockquote>
<p>为了解决跨代引用的问题，在新生代引入了记录集的数据结构，记录从非收集区到收集区的引用指针集合，避免在通过根可达算法判断对象存活时把整个老年代加入扫描范围。</p>
<p>GC时，GC收集器只需通过记忆集判断出某一块非收集区域是否存在指向收集区域的指针即可，无需进行详细的根搜索过程。</p>
</blockquote>
<p>卡表（Card Table）：</p>
<blockquote>
<p>卡表是HotSpot虚拟机中记忆集的实现方式，卡表中记录中记忆集的记录精度、与堆内存区域的映射关系等。</p>
<p>如果有年老代的对象引用了新生代的对象，那么该新生代对象所在区域对应的卡页元素设置为1，反之则为0。</p>
<p>G1以后的GC收集器不分代，所以G1以后的记忆集不是通过数组实现的，而是通过哈希表结构实现。</p>
<ul>
<li>JVM对于卡页的维护也是通过写屏障的方式。</li>
</ul>
</blockquote>
<p>Remembered Set：</p>
<blockquote>
<p>G1中实现的一种新的数据结构：简称为<code>RSet</code>，也被称为双向卡表。</p>
<p>在每个<code>Region</code>区中都存在一个<code>RSet</code>，其中记录了其他<code>Region</code>中的对象引用当前<code>Region</code>中对象的关系，也就是记录着<strong>谁引用了我的对象</strong>，属于<code>points-into</code>结构。</p>
<p>之前的卡表则是属于<code>points-out</code>结构，记录着<strong>我引用了谁的对象</strong>，在卡表中存在多个卡页，每个卡页记录着一定范围（<code>512KB</code>）的堆。</p>
<p><code>RSet</code>也好，<code>CardTable</code>也好，都是记忆集的一种具体实现，你也可以将<code>RSet</code>理解成一种<code>CardTable</code>的进阶实现方式。</p>
<p>G1中的<code>RSet</code>本质上就是一个哈希表结构（<code>HashTable</code>），<code>Key</code>为其他引用当前区内对象的<code>Region</code>起始地址，<code>Value</code>则是一个集合，里面的元素为其他<code>Region</code>中每个引用当前区内对象的地址。</p>
<p>实际上G1中的<code>RSet</code>对内存的开销也并不小，当JVM中分区较多且运行时间较长的情况下，这块的内存开销可能会占用到<code>20%</code>以上。</p>
</blockquote>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p><strong>分代收集理论</strong></p>
<blockquote>
<p>分代思想就是将<strong>堆</strong>分为<strong>新生代</strong>和<strong>老年代</strong>，然后根据各个<strong>年代</strong>的特点选择<strong>合适的垃圾收集算法</strong>。</p>
<ul>
<li><p>在<strong>新生代</strong>中，每次收集都会有大量的对象(近99%)死去，所以选择<strong>复制算法</strong>，只需要付出少量对象的复制成本就可以完成每次收集。</p>
</li>
<li><p>在<strong>老年代</strong>中，对象的存活几率较高，复制成本太高，而且没有额外的空间给它分配担保，所以必须使用<strong>标记整理算法或标记清除算法</strong>进行垃圾收集。</p>
</li>
</ul>
</blockquote>
<p><strong>标记-清除算法</strong></p>
<blockquote>
<p>标记-清除算法共有两个阶段，分为<strong>标记</strong>和<strong>清除</strong>：</p>
<ul>
<li><strong>标记</strong>存活的对象，也可以反过来，标记所有需要回收的对象。</li>
<li>在标记完成后统一回收未被标记的对象。</li>
</ul>
<p>两个明显的问题：</p>
<ul>
<li>效率问题：如果标记的对象太多，那么效率不高。</li>
<li>空间问题：标记清除后，会产生大量不连续的碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ul>
</blockquote>
<p><strong>复制算法</strong></p>
<blockquote>
<p>它可以将内存分为大小相同的两块，每次使用其中的一块，当这一块内存使用完后，就会将存活的对象复制到另外一块去，然后把使用过的空间一次性清理掉，这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<p>把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。</p>
<ul>
<li>发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上。</li>
<li>然后直接清理掉Eden和已用过的那块Survivor空间。</li>
</ul>
<p>HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1：</p>
<ul>
<li>即每次新生代中可用内存空间为整个新生代容量的90%**(Eden的80%加上一个Survivor的10%)**，只有一个Survivor空间，即10%的新生代是会被浪费的。</li>
</ul>
<p>复制算法的局限性：</p>
<ul>
<li>最大的弊端就是<strong>浪费内存空间</strong>。</li>
</ul>
</blockquote>
<p><strong>标记-整理算法</strong></p>
<blockquote>
<p>其中的标记过程仍然与<strong>标记-清除</strong>算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p>
</blockquote>
<p>标记-整理算法的缺点：</p>
<blockquote>
<p>要移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，而且这种对象移动操作必须全程暂停用户应用程序才能进行。</p>
<ul>
<li>不移动对象停顿时间会更短，如果从整个程序的吞吐量来看，移动对象会更划算。</li>
</ul>
<p>HotSpot虚拟机里关注吞吐量的<code>Parallel Scavenge</code>收集器是基于标记-整理算法的。</p>
<p>而关注延迟的<strong>CMS收集器</strong>则是基于标记-清除算法的。</p>
</blockquote>
<p>折中方案:</p>
<blockquote>
<p>让JVM平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。</p>
<ul>
<li>基于<strong>标记-清除</strong>算法的<strong>CMS收集器</strong>面临空间碎片过多时采用的就是这种处理办法。</li>
</ul>
</blockquote>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p><strong>基本概念</strong></p>
<blockquote>
<p>串行<code>Serial</code>收集：</p>
<ul>
<li>所有用户线程停止，单条GC线程回收堆的情况被称为串行回收。</li>
</ul>
<p>并行<code>Parallel</code>收集：</p>
<ul>
<li>所有用户线程停止，多条GC线程回收堆的情况（需多核CPU支持）。</li>
</ul>
<p>独占<code>Monopoly</code>执行：</p>
<ul>
<li>GC工作时，GC线程会抢占所有资源执行，整个应用程序会被停止。</li>
</ul>
<p>并发<code>Concurrent</code>执行：</p>
<ul>
<li>用户线程和GC线程同时（交替）执行的情况，不会停下某类线程。</li>
</ul>
</blockquote>
<p>吞吐量:</p>
<blockquote>
<p>指CPU用于执行用户代码的时间与CPU总耗时的比值，计算公式为：</p>
<ul>
<li>吞吐量 &#x3D; 用户代码执行总时长 &#x2F;（用户代码执行总时长 + 垃圾回收总时长）。</li>
</ul>
<p>如JVM在线上执行了<code>100min</code>，其中执行用户代码花费了<code>99min</code>，垃圾回收总用时<code>1min</code>，那么吞吐量则为<code>99min/(99min+1min)=99%</code>。</p>
</blockquote>
<p>写屏障：</p>
<blockquote>
<p>指在赋值操作前后加入一些逻辑处理（类似于SpringAOP面向切面前后置处理的思想）。</p>
</blockquote>
<p><strong>GC组合方案:</strong></p>
<blockquote>
<p>追求低延迟，用户交互度较为频繁：采用：<code>ParNew + CMS</code>。</p>
<p>追求高吞吐，后台计算工作较多：采用：<code>Parallel Scavenge + Parallel Old</code>。</p>
</blockquote>
<p><strong>Serial收集器</strong></p>
<blockquote>
<p>单线程的GC收集器，被称为串行收集器。</p>
<p>该收集器在发生GC时，会产生STW，也就是会停止所有用户线程。</p>
<p>由于会停止其他用户线程，所以在执行GC时并不会出现线程间的切换。</p>
<p>在单颗<code>CPU</code>的机器上，它的清理效率非常高。</p>
<p>一般来说，采用<code>Client</code>模式运行的JVM，选取该款收集器作为内嵌GC是个不错的选择。</p>
</blockquote>
<p><strong>ParNew收集器（多线程）</strong></p>
<blockquote>
<p><code>Serial</code>收集器的多线程版本，是作用于新生代区域的收集器。</p>
<ul>
<li>在整个实现上，除开GC收集阶段会使用多条线程回收外，其他实现几乎与<code>Serial</code>收集器大致相同。</li>
</ul>
<p>该款GC收集器因为采用了多线程，所以需要多核CPU的支持，该收集器会根据<strong>CPU</strong>核数，开启<strong>不同的GC线程数</strong>，从而达到<strong>最优</strong>的垃圾回收效果（也可通过<code>-XX:ParallelGCThreads</code>参数指定）。</p>
<ul>
<li>若是单核的机器上运行时，其效率可能不如<code>Serial</code>。</li>
<li>如果是以<code>Server</code>模式运行的程序，而老年代又采用了<code>CMS</code>收集器，那么新生代搭配<code>ParNew</code>是个不错的选择。</li>
</ul>
</blockquote>
<p><strong>Parallel Scavenge收集器（多线程）</strong></p>
<blockquote>
<p>一款作用于新生代的多线程GC收集器，但与<code>ParNew</code>收集器不同的是：</p>
<ul>
<li><code>ParNew</code>通过控制GC线程数量来缩短程序暂停时间，更关心程序的<strong>响应时间</strong>。</li>
<li><code>Parallel Scavenge</code>更关心的是<strong>程序运行的吞吐量</strong>，更注重一段时间内，用户代码执行时长与程序执行总时长的占比。</li>
</ul>
<p><code>PS</code>收集器可以通过<code>-XX:MaxGCPauseMillis</code>与<code>-XX:GCTimeRatio</code>参数精准控制GC发生时的时间以及吞吐量占比。</p>
<p><code>PS</code>收集器还可以通过开启<code>-XX:+UseAdaptiveSizePolicy</code>参数，让JVM启动自适应的GC调节策略，开启该参数后，JVM会根据当前系统的运行状态调整吞吐比与GC时间，从而确保能够提供最合适的停顿时间和吞吐量。</p>
</blockquote>
<p><strong>Serial Old（MSC）收集器（单线程）</strong></p>
<blockquote>
<p><code>Serial Old（MSC）</code>与<code>Serial</code>收集器相同，同样是一款单线程串行回收的收集器。</p>
<p>不同的是：<code>MSC</code>是一款作用于年老代空间的收集器，它采用标记-整理算法对年老代空间进行回收。</p>
<p>同时，该款收集器也可作为<code>CMS</code>的备用收集器使用。</p>
</blockquote>
<p><strong>Parallel Old收集器（多线程）</strong></p>
<blockquote>
<p><code>Parallel Old</code>则是<code>Parallel Scavenge</code>收集器的年老代版本，同样采用多线程进行并行收集，其内部采用标记-整理算法。</p>
<p>与新生代的<code>PS</code>收集器相同的是：<code>PO</code>同样追求的是<strong>吞吐量优先</strong>。</p>
</blockquote>
<p><strong>ShenandoahGC</strong></p>
<blockquote>
<p>JDK12推出了<code>ShenandoahGC</code>收集器，它与<code>G1、ZGC</code>收集器一样，都是基于分区结构实现的一款收集器。</p>
<p>和ZGC对比，相同的是：它们的停顿时间都不会受到堆空间大小的影响。</p>
</blockquote>
<p><strong>ZGC收集器</strong></p>
<blockquote>
<p>JDK11时推出垃圾回收器<code>ZGC</code>，是一款基于分区概念的内存布局GC器。</p>
<ul>
<li>是真正意义上的不分代收集器，无论是从逻辑上，还是物理上都不再保留分代的概念。</li>
</ul>
<p><code>ZGC</code>主要是超低延迟与吞吐量，在实现时，<code>ZGC</code>也会在尽可能堆吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾回收的停顿时间限制在<code>10ms</code>以内的低延迟。</p>
</blockquote>
<p>引入ZGC的目的主要有如下四点：</p>
<blockquote>
<p>奠定未来GC特性的基础。</p>
<p>为了支持超大级别堆空间（<code>TB</code>级别），最高支持<code>16TB</code>。</p>
<p>在最糟糕的情况下，对吞吐量的影响也不会降低超过15%。</p>
<p>GC触发产生的停顿时间不会偏差<code>10ms</code>。</p>
</blockquote>
<h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><blockquote>
<p>CMS（Concurrent Mark Sweep）收集器是<strong>以获取最短回收停顿时间</strong>为目标的收集器。</p>
<ul>
<li>它是HotSpot虚拟机第一款真正意义上的并发收集器，第一次实现了让<strong>垃圾收集线程与用户线程(基本上)同时工作。</strong></li>
</ul>
</blockquote>
<p>它是<strong>标记-清除</strong>算法实现，整个过程可以分为以下步骤：</p>
<img src="/images/image-20231026112357922.png" alt="image-20231026112357922" style="zoom:60%;" />

<blockquote>
<p>初始标记：</p>
<ul>
<li>暂停所有的其他线程<strong>stop the world</strong>，并记下GC Roots直接引用的对象，速度很快。</li>
</ul>
<p>并发标记：</p>
<ul>
<li>从GC Roots的直接关联对象开始遍历整个对象链的过程，这个过程很长，但是<code>不需要停顿用户线程</code>，可以与垃圾收集线程一起并发运行。<ul>
<li>因为用户程序继续执行，可能会有导致已经标记过的对象状态发生变化。</li>
</ul>
</li>
</ul>
<p>重新标记：</p>
<ul>
<li>为了修正并发标记期间因为用户线程继续运行而导致标记产生变动的那一部分对象的标记记录。<ul>
<li>这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。</li>
<li>主要用到三色标记里的增量更新算法做重新标记。</li>
</ul>
</li>
</ul>
<p>并发清理：</p>
<ul>
<li>开启用户线程，同时GC线程开始对未标记的区域做清扫。<ul>
<li>这个阶段如果有新增对象会被标记为<strong>黑色</strong>，不做任何处理。</li>
</ul>
</li>
</ul>
<p>并发重置：</p>
<ul>
<li>重置本次GC过程中的标记数据。</li>
</ul>
</blockquote>
<p><strong>CMS的缺点</strong></p>
<blockquote>
<p>对CPU的资源敏感，会和服务器抢资源。</p>
<p>无法处理浮动垃圾，就是在并发标记和并发清理阶段产生的垃圾对象，只能等下一次GC来收集。</p>
<p>它使用的是<strong>标记-清除</strong>算法，那么就会导致收集结束后，会产生大量的<strong>内存碎片</strong>，不利于后续对象的存储。</p>
</blockquote>
<h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><blockquote>
<p>G1<strong>（Garbage First）</strong>是一款面向服务器的垃圾收集器，<strong>主要针对配置多核处理器以及大容量内存的机器</strong>，满足<strong>GC停顿时间要求的同时，还具备高吞吐量性能特征</strong>。</p>
<ul>
<li>JDK 9 开始默认使用<strong>G1 垃圾收集器</strong>。</li>
</ul>
</blockquote>
<hr>
<p><strong>内存划分</strong></p>
<blockquote>
<p>G1将堆划分为多个大小相等的独立的<code>Region</code>区域。</p>
<p>一般<code>Region</code>区的大小等于堆空间的总大小除以2048，比如目前的堆空间总大小为8GB，就是<code>8192MB/2048=4MB</code>，那么最终每个<code>Region</code>区的大小为<code>4MB</code>。</p>
<ul>
<li>也可以用参数<code>-XX:G1HeapRegionSize</code>强制指定每个<code>Region</code>区的大小。</li>
</ul>
</blockquote>
<p><strong>新生代和老年代</strong></p>
<blockquote>
<p>默认新生代对堆内存的初始占比是5%，如果堆大小为8GB，那么年轻代占据<code>400MB</code>左右的内存，对应大概是100个<code>Region</code>区，可以通过<code>-XX:G1NewSizePercent</code>设置新生代初始占比。</p>
<p>在Java程序运行中，JVM会不停的给新生代增加更多的<code>Region</code>区，但是最多新生代的占比不会超过堆空间总大小的60%，可以通过<code>-XX:G1MaxNewSizePercent</code>调整。</p>
<p>新生代中的<code>Eden</code>区和<code>Survivor</code>区对应的<code>Region</code>区比例也跟之前一样，默认8:1:1，假设新生代现在有400个<code>Region</code>，那么整个新生代的占比则为<code>Eden=320,S0/From=40,S1/To=40</code>。</p>
</blockquote>
<blockquote>
<p>G1中的年老代晋升条件和之前的无差，达到年龄阈值的对象会被转入年老代的<code>Region</code>区中，不同的是对于大对象的分配，在G1中不会让大对象进入年老代，在G1中由专门存放大对象的<code>Region</code>区叫做<code>Humongous</code>区，如果在分配对象时，判定出一个对象属于大对象，那么则会直接将其放入<code>Humongous</code>区存储。</p>
</blockquote>
<p><strong>在G1中，判定一个对象是否为大对象的方式为：</strong></p>
<blockquote>
<p>对象大小是否超过单个普通<code>Region</code>区的50%，如果超过则代表当前对象为大对象，那么该对象会被直接放入<code>Humongous</code>区。</p>
<ul>
<li>比如：目前是8GB的堆空间，每个<code>Region</code>区的大小为<code>4MB</code>，当一个对象大小超过<code>2MB</code>时则会被判定为属于大对象。</li>
</ul>
<p>如果程序运行过程中出现一个巨型对象，当一个<code>Humongous</code>区存不下时，可能会横跨多个<code>Region</code>区存储它。</p>
</blockquote>
<p><code>Humongous</code>区存在的意义：</p>
<blockquote>
<p>可以避免一些短命的巨型对象直接进入年老代，节约年老代的内存空间，可以有效避免年老代因空间不足时的GC开销。</p>
<p>当堆空间发生全局GC(<code>FullGC</code>)时，除开回收新生代和年老代之外，也会对<code>Humongous</code>区进行回收。</p>
</blockquote>
<p><strong>什么场景下适合采用G1收集器的建议</strong></p>
<blockquote>
<p>堆空间内<code>50%</code>以上的内存会被存活占用的应用。</p>
<p>分配速度和晋升速度特别快的应用。</p>
<p>至少<code>8GB</code>以上堆内存的应用。</p>
<p>采用原本分代收集器GC时间会长达<code>1s+</code>的应用。</p>
<p>追求停顿时间在<code>500ms</code>以内的应用。</p>
</blockquote>
<p><strong>GC类型</strong></p>
<p>YoungGC：</p>
<blockquote>
<p>在G1中，当新生代区域被用完时，G1首先会大概计算一下回收当前的新生代空间需要花费多少时间，如果回收时间远远小于参数<code>-XX:MaxGCPauseMills</code>设定的值，那么不会触发<code>YoungGC</code>，而是会继续为新生代增加新的<code>Region</code>区用于存放新分配的对象实例。</p>
<ul>
<li>用户未显式通过<code>-XX:MaxGCPauseMills</code>参数设定GC预期回收停顿时间值，那么G1默认为<code>200ms</code>。</li>
</ul>
<p>直至某次<code>Eden</code>区空间再次被放满并经过计算后，此次回收的耗时接近<code>-XX:MaxGCPauseMills</code>参数设定的值，那么才会触发<code>YoungGC</code>。</p>
<p>当<code>YoungGC</code>被触发时，首先会将目标<code>Region</code>区中的存活对象移动至幸存区空间（<code>Survivor-From</code>区标志的<code>Region</code>）。</p>
<p>同时达到晋升年龄标准的对象也会被移入至年老代<code>Region</code>中存储。</p>
<ul>
<li>G1收集器在发生<code>YoungGC</code>时，复制移动对象时是采用的多线程并行复制，以此来换取更优异的GC性能。</li>
</ul>
</blockquote>
<p>MixedGC:</p>
<blockquote>
<p>当整个堆中年老代的区域占有率达到参数<code>-XX:InitiatingHeapOccupancyPercent</code>设定的值后触发<code>MixedGC</code>，发生该类型GC后，会回收所有新生代<code>Region</code>区、部分年老代<code>Region</code>区（会根据期望的GC停顿时间选择合适的年老代<code>Region</code>区优先回收）以及大对象<code>Humongous</code>区。</p>
<p>正常情况下，G1垃圾收集时会先发生<code>MixedGC</code>，主要采用复制算法，在GC时先将要回收的<code>Region</code>区中存活的对象拷贝至别的<code>Region</code>区内，拷贝过程中，如果发现没有足够多的空闲<code>Region</code>区承载拷贝对象，此时就会触发一次<code>Full GC</code>。</p>
</blockquote>
<p>FullGC:</p>
<blockquote>
<p>当整个堆空间中的空闲<code>Region</code>不足以支撑拷贝对象或由于元数据空间满了等原因触发，在发生<code>FullGC</code>时，G1首先会停止系统所有用户线程，然后采用单线程进行标记、清理和压缩整理内存，以便于清理出足够多的空闲<code>Region</code>来供下一次<code>MixedGC</code>使用。</p>
<p>但该过程是单线程串行收集的，因此这个过程非常耗时(<code>ShenandoahGC</code>中采用了多线程并行收集)。</p>
<ul>
<li>G1收集器中并没有FullGC，，G1中的FullGC是采Sserial old FullGC。</li>
</ul>
</blockquote>
<p><strong>GC过程</strong></p>
<img src="/images/image-20231026110901495.png" alt="image-20231026110901495" style="zoom:60%;" />

<p>G1收集器在发生GC时执行过程大致会分为四个步骤（主要指<code>MixedGC</code>）：</p>
<blockquote>
<p>初始标记（<code>InitialMark</code>）：</p>
<ul>
<li>先触发<code>STW</code>，然后使用单条GC线程快速标记<code>GCRoots</code>直连的对象。</li>
</ul>
<p>并发标记（<code>ConcurrentMarking</code>）：</p>
<ul>
<li>与CMS的并发标记过程一致，采用多条GC线程与用户线程共同执行，根据<code>Root</code>根节点标记所有对象。</li>
</ul>
<p>最终标记（<code>Remark</code>）：</p>
<ul>
<li>同CMS的重新标记阶段（也会<strong>STW</strong>），主要是为了纠正并发标记阶段因用户操作导致的错标、误标、漏标对象。</li>
</ul>
<p>筛选回收（<code>Cleanup</code>）：</p>
<ul>
<li>先对各个<code>Region</code>区的回收价值和成本进行排序，找出 回收价值最大 的<code>Region</code>优先回收。</li>
<li>筛选回收阶段在G1收集器中是会停止所有用户线程后，采用多线程并行回收的。</li>
</ul>
<p>假设此时年老代空间共有<code>800</code>个<code>Region</code>区，并且都满了，所以此刻会触发GC。</p>
<p>但根据GC的预期停顿时间值，本次GC只能允许停顿<code>200ms</code>，而G1经过前面的成本计算后，大致可推断出：</p>
<ul>
<li>本次GC回收<code>600</code>个<code>Region</code>区恰好停顿时间可控制在<code>200ms</code>左右，那么最终就会以 回收<code>600</code>个<code>Region</code>区 为基准触发GC，这样则能尽量确保GC导致的停顿时间可以被控制在我们指定的范围之内。</li>
</ul>
<p>G1会在后台维护着一个优先列表：</p>
<ul>
<li><code>CollectionSet（CSet）</code>，它记录了GC要收集的<code>Region</code>集合，集合里的<code>Region</code>可以是任意年代的。</li>
</ul>
<p>在G1中回收算法都是采用复制算法，都会将一个<code>Region</code>区中存活的对象复制到另外一个<code>Region</code>区内。</p>
</blockquote>
<p><strong>G1缺点：</strong></p>
<blockquote>
<p>G1需要记忆集 (卡表)来记录新生代和老年代之间的引用关系。</p>
<ul>
<li>这种数据结构在 G1 中需要占用大量的内存，可能达到整个堆内存容量的 20% 甚至更多。</li>
<li>而且 G1 中维护记忆集的成本较高，带来了更高的执行负载，影响效率。</li>
</ul>
<p>CMS 在小内存应用上的表现要优于 G1，而大内存应用上 G1 更有优势，大小内存的界限是6GB到8GB。</p>
</blockquote>
<h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><blockquote>
<p>当JVM需要用到某个类时，虚拟机会加载它的<code>.class</code>文件，加载了相关的字节码信息后，会为它创建对应的<code>Class</code>对象，这个过程就被称为类加载。</p>
<p>类加载过程被分为三个步骤，五个阶段，分别为加载、验证、准备、解析以及初始化。</p>
<p>加载、验证、准备、初始化这四个阶段的顺序是确定的。</p>
<ul>
<li>解析阶段不一定，在某些情况下可以在初始化阶段之后再开始（动态绑定或晚期绑定）。</li>
</ul>
</blockquote>
<p><img src="/images/image-20231021143234009.png" alt="image-20231021143234009"></p>
<p><strong>加载步骤</strong></p>
<blockquote>
<p>指通过完全限定名查找Class文件二进制数据并将其加载进内存的过程：</p>
<ul>
<li>通过完全限定名查找定位<code>.class</code>文件，并获取其二进制字节流数据。</li>
<li>把字节流所代表的静态存储结构转换为运行时数据结构。</li>
<li>在堆中间中为其创建一个<code>Class</code>对象，作为程序访问这些数据的入口。</li>
</ul>
</blockquote>
<p><strong>验证阶段</strong></p>
<blockquote>
<p>主要用于确保被加载的<code>Class</code>正确性，检测<code>Class</code>字节流中的数据是否符合虚拟机的要求，确保不会危害虚拟机自身安全。</p>
<p>验证阶段主要包括四种验证：</p>
<ul>
<li>文件格式验证、元数据验证、字节码验证以及符号引用验证。</li>
</ul>
</blockquote>
<p><strong>准备阶段</strong></p>
<blockquote>
<p>准备阶段主要是为类中声明的静态变量分配内存空间，并将其初始化成默认值（零值）。</p>
<ul>
<li>在这里进行的内存分配仅包括类成员(<code>static</code>成员)，而实例成员则会在创建具体的Java对象时被一起分配在堆空间中。</li>
<li>同时也不包含使用<code>final</code>修饰的<code>static</code>成员，因为<code>final</code>在编译的时候就会分配了，准备阶段会显示初始化。</li>
</ul>
</blockquote>
<p><strong>解析阶段</strong></p>
<blockquote>
<p>解析阶段主要是把类中对常量池内的符号引用转换为直接引用的过程。</p>
<ul>
<li>解析操作往往会伴随着JVM在执行完初始化之后再执行。</li>
</ul>
<p>符号引用：</p>
<ul>
<li>用一组符号来描述引用的目标，符号引用的字面量形式明确定义在 Java虚拟机规范 的Class文件格式中。</li>
</ul>
<p>直接引用：</p>
<ul>
<li>直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li>
</ul>
<p>符号引用转直接引用的过程，主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符等7类符号引用进行（分别对应常量池中的<code>CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info</code>等）。</p>
</blockquote>
<p><strong>初始化步骤</strong></p>
<blockquote>
<p>初始化步骤中，主要是对类的静态变量赋予正确的初始值，也就是在声明静态变量时指定的初始化值以及静态代码块中的赋值。</p>
<ul>
<li>本质上就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程。</li>
</ul>
</blockquote>
<p><strong>使用、卸载</strong></p>
<blockquote>
<p>当一个类完整的经过了类加载过程之后，在内存中已经生成了Class对象，同时在Java程序中可以通过它开始创建实例对象使用。</p>
<p>当一个Class对象不再被任何一处位置引用，即不可触及时，Class就会结束生命周期，该类加载的数据也会被卸载。</p>
<p>Java虚拟机自带的类加载器加载的类，在虚拟机的生命周期中始终不会被卸载，因为JVM始终会保持与这些类加载器的引用，而这些类加载器也会始终保持着自己加载的Class对象的引用，所以对于虚拟机而言，这些Class对象始终是可以被触及的。</p>
<ul>
<li>由用户自定义的类加载器加载的类是可以被卸载的。</li>
</ul>
</blockquote>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p><strong>Bootstrap引导类加载器</strong></p>
<blockquote>
<p>引导类加载器也被称为启动类加载器或根类加载器，指<code>BootstrapClassLoader</code>。</p>
<p>引导类加载器使用C++语言实现，是JVM自身的一部分，主要负责将<code>&lt;JAVA_HOME&gt;\lib</code>路径下的核心类库或<code>-Xbootclasspath</code>参数指定的路径下的jar包加载到内存中。</p>
</blockquote>
<p><strong>Extension拓展类加载器</strong></p>
<blockquote>
<p>位于<code>HotSpot</code>源码目录中的<code>sun.misc.Launcher$ExtClassLoader</code>位置。</p>
<p>它主要负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录下或者由系统变量<code>-Djava.ext.dir</code>指定位路径中的类库。</p>
</blockquote>
<p><strong>Application系统类加载器</strong></p>
<blockquote>
<p>位于<code>HotSpot</code>源码目录中的<code>sun.misc.Launcher$AppClassLoader</code>位置。</p>
<p>它负责加载系统类路径<code>java -classpath</code>或<code>-D java.class.path</code>指定路径下的类库，也就是classpath&#96;路径。</p>
<p>该类加载器是程序的默认类加载器，可以通过<code>ClassLoader.getSystemClassLoader()</code>方法可以直接获取到它。</p>
</blockquote>
<p><strong>自定义类加载器</strong></p>
<blockquote>
<p>如果需要自定义类加载器，只需要继承<code>ClassLoader</code>类，但继承<code>ClassLoader</code>需要自己重写<code>findClass()</code>方法并编写加载逻辑。</p>
</blockquote>
<p><strong>线程上下文类加载器</strong></p>
<blockquote>
<p>很多服务提供者接口（<code>Service Provider Interface，SPI</code>），这些接口允许第三方为它们提供实现，如常见的<code>SPI</code>有<code>JDBC、JNDI</code>等，这些<code>SPI</code>的接口属于<code>Java</code>核心库，一般存在<code>rt.jar</code>包中，由启动类加载器（<code>Bootstrap</code>）加载，而<code>SPI</code>的第三方实现代码则是作为<code>Java</code>应用所依赖的<code>jar</code>包被存放在<code>classpath</code>路径下。</p>
<p>由于<code>SPI</code>接口中的代码需要加载第三方实现类并调用其相关函数，但<code>SPI</code>的核心接口类是由启动类加载器（<code>Bootstrap</code>）加载的，<code>Bootstrap</code>加载器无法直接加载<code>SPI</code>的实现类。</p>
<p>SPI提供了一种动态的服务发现机制（约定），只要第三方在编写实现类时，在工程内新建一个<code>META-INF/services/</code>目录并在该目录下创建一个与服务接口名称同名的文件，那么在程序启动的时候，就会根据约定去找到所有符合规范的实现类，然后交给线程上下文类加载器进行加载处理。</p>
<p>线程的上下文类加载器默认设置的就是系统类加载器（<code>System</code>）。</p>
</blockquote>
<img src="/images/image-20231021144123067.png" alt="image-20231021144123067" style="zoom:50%;" />

<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p><strong>双亲委派类加载过程</strong></p>
<blockquote>
<p>当<code>App</code>尝试加载一个类时，它不会直接尝试加载这个类，首先会在自己的命名空间中查询是否已经加载过这个类，如果没有会先将这个类加载请求委派给父类加载器<code>Ext</code>完成。</p>
<p>当<code>Ext</code>尝试加载一个类时，它也不会直接尝试加载这个类，也会在自己的命名空间中查询是否已经加载过这个类，没有的话也会先将这个类加载请求委派给父类加载器<code>Bootstrap</code>完成。</p>
<p>如果<code>Bootstrap</code>加载失败，这个需要被加载的类不在<code>Bootstrap</code>的加载范围内，那么<code>Bootstrap</code>会重新将这个类加载请求交由子类加载器<code>Ext</code>完成。</p>
<p>如果<code>Ext</code>加载失败，这个类也不在<code>Ext</code>的加载范围内，最后会重新将这个类加载请求交给子类加载器<code>App</code>完成。</p>
<p>如果<code>App</code>加载器也加载失败这个类根据全限定名无法查找到，则会抛出<code>ClassNotFoundException</code>异常。</p>
</blockquote>
<blockquote>
<p><strong>此处的父子关系并非继承关系，而是采用组合关系来实现</strong></p>
</blockquote>
<img src="/images/image-20231026173048245.png" alt="image-20231026173048245" style="zoom:70%;" />

<p><strong>双亲委派机制的优势</strong></p>
<blockquote>
<p>可以避免一个类在不同层级的类加载器中重复加载，如果父类加载器已经加载过该类了，那么就不需要子类加载器再加载一次。</p>
<p><strong>沙箱安全机制:</strong></p>
<p>可以保障Java核心类的安全性问题，比如通过网络传输过来一个<code>java.lang.String</code>类，需要被加载时，通过这种双亲委派的方式，最终找到<code>Bootstrap</code>加载器后，发现该类已经被加载，从而就不会再加载传输过来的<code>java.lang.String</code>类，而是直接返回<code>Bootstrap</code>加载的<code>String.class</code>。</p>
<p>这样可以有效防止Java的核心API类在运行时被篡改，从而保证所有子类共享同一基础类，减少性能开销和安全隐患问题。</p>
</blockquote>
<p><strong>双亲委派的实现原理</strong></p>
<blockquote>
<p>所有的类加载器都间接的继承自<code>ClassLoader</code>类，包括<code>Ext、App</code>类加载器（<code>Bootstrap</code>除外，因为它是C++实现的）。</p>
<p>双亲委派模型的实现逻辑全在于<code>loadClass()</code>方法，而<code>ExtClassLoader</code>加载器是没有重写<code>loadClass()</code>方法，<code>AppClassLoader</code>加载器虽然重写了<code>loadClass()</code>方法，但其内部最终还是调用父类的<code>loadClass()</code>方法。</p>
<p>无论是<code>ExtClassLoader</code>还是<code>AppClassLoader</code>加载器，其本身都未打破<code>ClassLoader.loadClass()</code>方法中定义的双亲委派逻辑，<code>Bootstrap、Ext、App</code>这些JVM自带的类加载器都默认会遵守双亲委派模型。</p>
</blockquote>
<pre><code class="java">// sun.misc.Launcher类 → AppClassLoader内部类 → loadClass()方法
 public Class loadClass(String name, boolean resolve)
     throws ClassNotFoundException
 &#123;
     int i = name.lastIndexOf(&#39;.&#39;);
     if (i != -1) &#123;
         SecurityManager sm = System.getSecurityManager();
         if (sm != null) &#123;
             sm.checkPackageAccess(name.substring(0, i));
         &#125;
     &#125;
     // 依旧调用的是父类loadClass()方法
     return (super.loadClass(name, resolve));
 &#125;
</code></pre>
<p><strong>打破双亲委派机制</strong></p>
<blockquote>
<p>需要重写loadClass方法，在<code>loadClass</code>方法中不委托给父类尝试着进行加载，直接在当前的类加载器进行加载。</p>
<p>打破双亲委派机制的场景:</p>
<ul>
<li>一个Tomcat可能部署多个应用，不同的应用可能依赖的同一个第三方类库的不同版本（会造成很多大量的文件路径相同的类），这种情况下就不能通过双亲委派机制去加载，要保证每个应用的类库是独立的，相互隔离。</li>
</ul>
</blockquote>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p><strong>问题排查工具</strong></p>
<p><a target="_blank" rel="noopener" href="https://fastthread.io/">https://fastthread.io/</a></p>
<p><a target="_blank" rel="noopener" href="https://gceasy.io/">https://gceasy.io/</a></p>
<p><a target="_blank" rel="noopener" href="https://heaphero.io/">https://heaphero.io/</a></p>
<p><strong>内存泄漏</strong></p>
<blockquote>
<p>对象不会再被程序用到了，但是GC又不能回收他们的情况，叫内存泄漏。</p>
</blockquote>
<p>内存泄漏举例:</p>
<blockquote>
<p>单例模式：</p>
<ul>
<li>单例的生命周期和应用程序一样长，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏。</li>
</ul>
<p>资源未关闭 ：</p>
<ul>
<li>如：数据库连接，网络连接和IO连接必须手动Close，否则是不能被回收的。</li>
</ul>
</blockquote>
<p><strong>内存溢出</strong></p>
<p><strong>栈溢出</strong></p>
<blockquote>
<p>线程请求的栈深度大于虚拟机允许的最大深度。</p>
<p>虚拟机在扩展栈深度时，无法申请到足够的内存空间：OutOfMemoryError</p>
</blockquote>

	</div>
</div>


    <div class="post-guide">
        <div class="item left">
            
              <a href="/2022/12/02/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  MySQL
              </a>
            
        </div>
        <div class="item right">
            
              <a href="/2022/11/26/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E5%89%91%E6%8C%87OFFER/">
                剑指OFFER
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>




<script>

    //document.oncontextmenu=new Function("event.returnValue=false");
	//document.onselectstart=new Function("event.returnValue=false");

	

	$(function () {
		const btw = new BTWPlugin();
	    btw.init({
	        id: 'container',
	        blogId: '22377-1701222497346-690',
	        name: '月伴飞鱼',
	        qrcode: '/小程序码.jpg',
	        keyword: '验证码',
	    });

	    var contents = document.getElementsByClassName("content999");
	    //监听文章内容的copy事件
	    contents[0].addEventListener('copy',function(e){
	        setClipboardText(e);
	    });

	    function setClipboardText(event){
	        // clipboardData 对象是为通过编辑菜单、快捷菜单和快捷键执行的编辑操作所保留的，也就是你复制或者剪切内容
	        let clipboardData = event.clipboardData || window.clipboardData;

	        // 如果未复制或者未剪切，则return出去
	        if (!clipboardData) { return; }

	        event.preventDefault();

	        // Selection 对象，表示用户选择的文本范围或光标的当前位置。
	        // 声明一个变量接收 -- 用户输入的剪切或者复制的文本转化为字符串
	        let text = window.getSelection().toString();
	    
	        if (text) {
	            // 如果文本存在则先取消文本默认事件
	            event.preventDefault();
	            // 通过调用常clipboardData对象的 setData(format, data) 方法；来设置相关文本
	            // format: 一个DOMString 表示要添加到 drag object的拖动数据的类型。
	            // data: 一个 DOMString表示要添加到 drag object的数据。
	            var copyright = '\n\n'
	            + '\n著作权归作者所有。'
	            + '\n商业转载请联系作者获得授权，非商业转载请注明出处。'
	            + '\n作者: 月伴飞鱼'
	            + '\n原文地址: https://hardyfish.top/2022/11/27/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM/'
	    
	            clipboardData.setData('text/plain', text + copyright);
	    
	        }
	    };
	});

	
</script>

<script>
    const btw = new BTWPlugin();
    btw.init({
        id: 'container',
        blogId: '22377-1701222497346-690',
        name: '月伴飞鱼',
        qrcode: '/小程序码.jpg',
        keyword: '验证码',
    });
</script>
	</div>
	<div id="footer">
	<p>
	©2019-<span id="footerYear"></span> 
	<a href="/">月伴飞鱼</a> 
	
	
		|
		<span id="busuanzi_container_site_pv">
			PV 180986
		</span>
		|
		<span id="busuanzi_container_site_uv"> 
			UV 10079
		</span>
	
	<br>
	微信搜索 <a href="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/个人公众号.jpg" target="_blank">月伴飞鱼</a> 关注我
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>
	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>