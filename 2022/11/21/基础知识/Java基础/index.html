<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		Java基础 | 
	 
	月伴飞鱼
	</title>
	
	<!-- keywords,description -->
	 

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/%E5%A4%B4%E5%83%8F.jpg">
	
  
  	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="/css/jquery.fancybox.min.css">

	
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="/lib/highlight/darcula.css">

	
<link rel="stylesheet" href="/css/clipboard-use.css">


	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">

	
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>


	
<script src="/lib/highlight/highlight.min.js"></script>

	
<script src="https://readmore.openwrite.cn/js/readmore.js"></script>

	
<script src="/lib/jquery-3.4.1.min.js"></script>

	
<script src="/lib/jquery.pjax.js"></script>


	
<script src="/js/main.js"></script>

	
<script src="/js/jquery.fancybox.min.js"></script>

	
		
<script src="/lib/valine/av-3.0.4-min.js"></script>

		
<script src="/lib/valine/Valine-1.3.10-min.js"></script>

	
	
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
	
<script src="/js/clipboard.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
	<header id="header">
    <a id="title" href="/" class="logo">公众号月伴飞鱼</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">关于我</a>
		</li>

		<li class="menu-item">
			<a href="/个人公众号.jpg" class="menu-item-link" target="_blank">我的公众号</a>
		</li>
		
		<li class="menu-item">
			<a href="https://tech.meituan.com/" class="menu-item-link" target="_blank">
				美团技术团队
			</a>
		</li>
		<li class="menu-item">
			<a href="https://tech.youzan.com/" class="menu-item-link" target="_blank">
				有赞技术团队
			</a>
		</li>
		<!--<li class="menu-item">
			<select class="menu-item-link menu-item-select">
				<option class="menu-item-link"  value="volvo">Volvo</option>
				<option class="menu-item-link"  value="saab">Saab</option>
				<option class="menu-item-link"  value="fiat">Fiat</option>
				<option class="menu-item-link"  value="audi">Audi</option>
			</select>
		</li>-->
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="text" placeholder="按目录搜索一下">
		<div id="tree">
			

			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										中间件
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/12/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/Elasticsearch/">
										Elasticsearch
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										前端相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/CSS/">
										CSS
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/Vue/">
										Vue
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/12/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">
										小程序
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										基础知识
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/11/27/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM/">
										JVM
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file active">
									<a href="/2022/11/21/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E5%9F%BA%E7%A1%80/">
										Java基础
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F/">
										分布式
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/12/10/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">
										并发编程
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
										设计模式
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										工具相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/">
										实用工具
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/07/28/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/">
										常用代码
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">
										开发工具
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										数据库
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/12/02/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">
										MySQL
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										服务器
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E6%9C%8D%E5%8A%A1%E5%99%A8/Docker/">
										Docker
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/09/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/">
										Nginx
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/09/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E8%BF%90%E7%BB%B4%E7%9F%A5%E8%AF%86/">
										运维知识
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										框架相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/08/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/MyBatis/">
										MyBatis
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/14/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/Spring/">
										Spring
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/01/17/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/Thrift/">
										Thrift
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/10/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/">
										开源框架
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										消息队列
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/KAFKA/">
										KAFKA
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/">
										RocketMQ
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										生活相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/10/%E7%94%9F%E6%B4%BB%E7%9B%B8%E5%85%B3/%E7%94%B5%E5%BD%B1/">
										电影
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/09/%E7%94%9F%E6%B4%BB%E7%9B%B8%E5%85%B3/%E9%9F%B3%E4%B9%90/">
										音乐
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										算法相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/11/26/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/LeetCode/">
										LeetCode
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/11/26/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E5%89%91%E6%8C%87OFFER/">
										剑指OFFER
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/11/25/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/">
										面试算法
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										英语相关
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										老友记
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/08/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E8%80%81%E5%8F%8B%E8%AE%B0/%E7%AC%AC%E4%B8%80%E5%AD%A3/">
										第一季
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/08/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E8%80%81%E5%8F%8B%E8%AE%B0/%E7%AC%AC%E4%B8%89%E5%AD%A3/">
										第三季
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										雅思
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/12/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E9%9B%85%E6%80%9D/%E5%89%91%E6%A1%A5%E9%9B%85%E6%80%9D%E5%90%AC%E5%8A%9B%E7%9C%9F%E9%A2%98/">
										剑桥雅思听力真题
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										计算机基础
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
										操作系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
										数据结构
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/">
										算法知识
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/12/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">
										网络基础
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">

	Java基础
</h1>
<div class="article-meta">
	<span>月伴飞鱼</span>
	<span>2022-11-21 23:49:55</span>
    
		<div id="article-categories">
            
                
                    <span>
                        <i class="fa fa-folder" aria-hidden="true"></i>
                        <a href="/categories/基础知识/">基础知识</a>
						
                    </span>
                
            
		</div>
    
</div>

<div id="container" class = "content999">
	<div id="article-content">
		<p><strong>接口和抽象的区别</strong></p>
<blockquote>
<p>抽象类带来的很大的作用就是实现代码复用，比如当有多个子类有相同的属性或方法时，我们可以抽象出一个公共的类，然后子类继承这个抽象类，当然，这个公共类可以是普通父类，也可以是抽象类。</p>
<ul>
<li>但是抽象类中的方法可以交给子类去实现，让子类有不同的功能。</li>
</ul>
<p>接口实现了约定和实现相分离，降低了代码间的耦合性，提高代码的可扩展性。</p>
<ul>
<li>调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。</li>
</ul>
</blockquote>
<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><p><strong>Final</strong></p>
<p>Final可以用来修饰变量、方法或者类。</p>
<blockquote>
<p>修饰变量：</p>
<ul>
<li>这个<strong>变量一旦被赋值就不能被修改了</strong>，如果尝试给其赋值，会报编译错误。</li>
</ul>
<p>修饰方法：</p>
<ul>
<li>该方法不可以被重写。</li>
</ul>
<p>修饰类：</p>
<ul>
<li>这个类<strong>不可被继承</strong>。</li>
</ul>
<p>注意：Final修饰对象时，只是引用不可变，而对象本身的内容依然是可以变化的。</p>
<ul>
<li>这一点同样适用于数组。</li>
</ul>
</blockquote>
<p><strong>Static</strong></p>
<blockquote>
<p><strong>修饰类变量:</strong></p>
<ul>
<li>如果该变量是 public 的话，表示该变量任何类都可以直接访问，而且无需初始化类，直接使用 <strong>类名.static 变量</strong> 访问。</li>
</ul>
<p><strong>修饰方法:</strong></p>
<ul>
<li><p>代表该方法和当前类是无关的，任意类都可以直接访问（如果权限是 public 的话）。</p>
</li>
<li><p>被 static 修饰的方法，在类初始化的时候并不会初始化，只有当自己被调用时，才会被执行。</p>
</li>
</ul>
<p><strong>修饰方法块:</strong></p>
<ul>
<li>方法块（静态块）常常用于在类启动之前，初始化一些值。</li>
<li>静态块只能调用同样被 static 修饰的变量，并且 static 的变量需要写在静态块的前面，不然编译会报错。</li>
</ul>
</blockquote>
<p><strong>Transient</strong></p>
<blockquote>
<p>transient用来修饰类变量，意思是当前变量无需进行序列化。</p>
</blockquote>
<p><strong>非静态初始化块（构造代码块）：</strong></p>
<blockquote>
<p>给对象进行初始化，对象一建立就运行，且优先于构造函数的运行。</p>
<p>非静态初始化块给所有对象进行统一初始化，构造函数只给对应对象初始化。</p>
<p>可以将所有构造函数共性的东西定义在构造代码块中。</p>
</blockquote>
<p><strong>静态初始化块：</strong></p>
<blockquote>
<p>给类进行初始化，随着类的加载而执行，且只执行一次。</p>
</blockquote>
<blockquote>
<p><strong>与构造代码块的区别：</strong></p>
<ul>
<li>构造代码块用于初始化对象，每创建一个对象就会被执行一次。</li>
<li>静态代码块用于初始化类，随着类的加载而执行，不管创建几个对象，都只执行一次。</li>
<li>静态代码块优先于构造代码块的执行。</li>
</ul>
</blockquote>
<p>执行顺序：</p>
<blockquote>
<p>所有的静态初始化块都优先执行，其次才是非静态的初始化块和构造函数，它们的执行顺序是：</p>
<ul>
<li>父类的静态初始化块</li>
<li>子类的静态初始化块</li>
<li>父类的初始化块</li>
<li>父类的构造函数</li>
<li>子类的初始化块</li>
<li>子类的构造函数</li>
</ul>
</blockquote>
<h2 id="Long"><a href="#Long" class="headerlink" title="Long"></a>Long</h2><p>Long 自己实现了一种缓存机制，缓存了从 -128 到 127 内的所有 Long 值，如果是这个范围内的 Long 值，就不会初始化，而是从缓存中拿，缓存初始化源码如下：</p>
<pre><code class="java">private static class LongCache &#123;
    private LongCache()&#123;&#125;
    // 缓存，范围从 -128 到 127，+1 是因为有个 0
    static final Long cache[] = new Long[-(-128) + 127 + 1];
 
    // 容器初始化时，进行加载
    static &#123;
        // 缓存 Long 值，注意这里是 i - 128 ，所以再拿的时候就需要 + 128
        for(int i = 0; i &lt; cache.length; i++)
            cache[i] = new Long(i - 128);
    &#125;
&#125;
</code></pre>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><strong>字符串是一个常量</strong>，一旦创建了一个 String 对象，就无法改变它的值，它的内容也就不可能发生变化（不考虑反射这种特殊行为）。</p>
<p><strong>String 具备不变性背后的原因是什么：</strong></p>
<pre><code class="java">public final class String
    implements Java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;
    /** The value is used for character storage. */
    private final char value[];
    //...
&#125;
</code></pre>
<blockquote>
<p><code>private final</code> 的 char 数组，数组名字叫 value。</p>
<p>它存储着字符串的每一位字符，同时 value 数组是被 final 修饰的，这个 value 一旦被赋值，引用就不能修改了。</p>
<p>除了构造函数之外，并没有任何其他方法会修改 value 数组里面的内容，而且 value 的权限是 private，外部的类也访问不到，所以最终使得 value 是不可变的。</p>
<p>String 类是被 final 修饰的，所以这个 String 类是不会被继承的，因此没有任何人可以通过扩展或者覆盖行为来破坏 String 类的不变性。</p>
</blockquote>
<p><strong>String 不可变的好处</strong></p>
<blockquote>
<p>1、使用字符串常量池。</p>
<p>2、用作 HashMap 的 key。</p>
<p>3、缓存 HashCode。</p>
<p>4、<strong>线程安全</strong>。</p>
</blockquote>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>ThreadLocal 提供了线程本地变量的实例，它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。</p>
<p><strong>使用场景</strong></p>
<blockquote>
<p>ThreadLocal 用作保存每个线程独享的对象，为每个线程都创建一个副本，这样每个线程都可以修改自己所拥有的副本, 而不会影响其他线程的副本，确保了线程安全。</p>
<p>ThreadLocal 用作每个线程内需要独立保存信息，以便供其他方法更方便地获取该信息的场景，避免了传参，类似于全局变量的概念。</p>
</blockquote>
<p><strong>关键属性</strong></p>
<pre><code class="java">// threadLocalHashCode 表示当前 ThreadLocal 的 hashCode，用于计算当前 ThreadLocal 在 ThreadLocalMap 中的索引位置
private final int threadLocalHashCode = nextHashCode();
// 计算 ThreadLocal 的 hashCode 值(就是递增)
private static int nextHashCode() &#123;
    return nextHashCode.getAndAdd(HASH_INCREMENT);
&#125;
// static + AtomicInteger 保证了在一台机器中每个 ThreadLocal 的 threadLocalHashCode 是唯一的
// 被 static 修饰非常关键，因为一个线程在处理业务的过程中，ThreadLocalMap 是会被 set 多个 ThreadLocal 的，多个 ThreadLocal 就依靠 threadLocalHashCode 进行区分
private static AtomicInteger nextHashCode = new AtomicInteger();
</code></pre>
<p><strong>ThreadLocalMap</strong></p>
<blockquote>
<p>ThreadLocalMap 本身就是一个简单的 Map 结构，key 是 ThreadLocal，value 是 ThreadLocal 保存的值，底层是数组的数据结构。</p>
</blockquote>
<pre><code class="java">static class ThreadLocalMap &#123;
        // 数组中的每个节点值，WeakReference 是弱引用，当没有引用指向时，会直接被回收
        static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;
            // 当前 ThreadLocal 关联的值
            Object value;
            // WeakReference 的引用 referent 就是 ThreadLocal
            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;
                super(k);
                value = v;
            &#125;
        &#125;
        // 数组的初始化大小
        private static final int INITIAL_CAPACITY = 16;
        // 存储 ThreadLocal 的数组
        private Entry[] table;
        // 扩容的阈值，默认是数组大小的三分之二
        private int threshold;
&#125;
</code></pre>
<p><strong>ThreadLocal 是如何做到线程之间数据隔离的</strong></p>
<blockquote>
<p>主要因为是 ThreadLocalMap 是线程的属性。</p>
<p><code>ThreadLocals.ThreadLocalMap</code> 和 <code>InheritableThreadLocals.ThreadLocalMap</code> 分别是线程的属性，所以每个线程的 ThreadLocals 都是隔离独享的。</p>
<p>父线程在创建子线程的情况下，会拷贝 inheritableThreadLocals 的值，但不会拷贝 threadLocals 的值。</p>
</blockquote>
<p><strong>set 方法</strong></p>
<pre><code class="java">// set 操作每个线程都是串行的，不会有线程安全的问题
public void set(T value) &#123;
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    // 当前 thradLocal 之前有设置值，直接设置，否则初始化
    if (map != null)
        map.set(this, value);
    // 初始化ThreadLocalMap
    else
        createMap(t, value);
&#125;
</code></pre>
<pre><code class="java">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;
    Entry[] tab = table;
    int len = tab.length;
    // 计算 key 在数组中的下标，其实就是 ThreadLocal 的 hashCode 和数组大小-1取余
    int i = key.threadLocalHashCode &amp; (len-1);
 
    // 整体策略：查看 i 索引位置有没有值，有值的话，索引位置 + 1，直到找到没有值的位置
    // 这种解决 hash 冲突的策略，也导致了其在 get 时查找策略有所不同，体现在 getEntryAfterMiss 中
    for (Entry e = tab[i];
         e != null;
         // nextIndex 就是让在不超过数组长度的基础上，把数组的索引位置 + 1
         e = tab[i = nextIndex(i, len)]) &#123;
        ThreadLocal&lt;?&gt; k = e.get();
        // 找到内存地址一样的 ThreadLocal，直接替换
        if (k == key) &#123;
            e.value = value;
            return;
        &#125;
        // 当前 key 是 null，说明 ThreadLocal 被清理了，直接替换掉
        if (k == null) &#123;
            replaceStaleEntry(key, value, i);
            return;
        &#125;
    &#125;
    // 当前 i 位置是无值的，可以被当前 thradLocal 使用
    tab[i] = new Entry(key, value);
    int sz = ++size;
    // 当数组大小大于等于扩容阈值(数组大小的三分之二)时，进行扩容
    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)
        rehash();
&#125;
</code></pre>
<blockquote>
<p>1、通过递增的 AtomicInteger 作为 ThreadLocal 的 hashCode 的；</p>
<p>2、计算数组索引位置的公式是：</p>
<ul>
<li>hashCode 取模数组大小，由于 hashCode 不断自增，所以不同的 hashCode 大概率上会计算到同一个数组的索引位置（在实际项目中，ThreadLocal 都很少，基本上不会冲突）</li>
</ul>
<p>3、通过 hashCode 计算的索引位置 i 处如果已经有值了，会从 i 开始，通过 +1 不断的往后寻找，直到找到索引位置为空的地方，把当前 ThreadLocal 作为 key 放进去。</p>
</blockquote>
<p><strong>get 方法</strong></p>
<pre><code class="java">public T get() &#123;
    // 因为 threadLocal 属于线程的属性，所以需要先把当前线程拿出来
    Thread t = Thread.currentThread();
    // 从线程中拿到 ThreadLocalMap
    ThreadLocalMap map = getMap(t);
    if (map != null) &#123;
        // 从 map 中拿到 entry，由于 ThreadLocalMap 在 set 时的 hash 冲突的策略不同，导致拿的时候逻辑也不太一样
        ThreadLocalMap.Entry e = map.getEntry(this);
        // 如果不为空，读取当前 ThreadLocal 中保存的值
        if (e != null) &#123;
            @SuppressWarnings(&quot;unchecked&quot;)
            T result = (T)e.value;
            return result;
        &#125;
    &#125;
    // 否则给当前线程的 ThreadLocal 初始化，并返回初始值 null
    return setInitialValue();
&#125;
</code></pre>
<pre><code class="java">// 自旋 i+1，直到找到为止
private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;
    Entry[] tab = table;
    int len = tab.length;
    // 在大量使用不同 key 的 ThreadLocal 时，其实还蛮耗性能的
    while (e != null) &#123;
        ThreadLocal&lt;?&gt; k = e.get();
        // 内存地址一样，表示找到了
        if (k == key)
            return e;
        // 删除没用的 key
        if (k == null)
            expungeStaleEntry(i);
        // 继续使索引位置 + 1
        else
            i = nextIndex(i, len);
        e = tab[i];
    &#125;
    return null;
&#125;
</code></pre>
<p><strong>扩容</strong></p>
<p>ThreadLocalMap 中的 ThreadLocal 的个数超过阈值时，ThreadLocalMap 就要开始扩容了：</p>
<pre><code class="java">//扩容
private void resize() &#123;
    // 拿出旧的数组
    Entry[] oldTab = table;
    int oldLen = oldTab.length;
    // 新数组的大小为老数组的两倍
    int newLen = oldLen * 2;
    // 初始化新数组
    Entry[] newTab = new Entry[newLen];
    int count = 0;
    // 老数组的值拷贝到新数组上
    for (int j = 0; j &lt; oldLen; ++j) &#123;
        Entry e = oldTab[j];
        if (e != null) &#123;
            ThreadLocal&lt;?&gt; k = e.get();
            if (k == null) &#123;
                e.value = null; // Help the GC
            &#125; else &#123;
                // 计算 ThreadLocal 在新数组中的位置
                int h = k.threadLocalHashCode &amp; (newLen - 1);
                // 如果索引 h 的位置值不为空，往后+1，直到找到值为空的索引位置
                while (newTab[h] != null)
                    h = nextIndex(h, newLen);
                // 给新数组赋值
                newTab[h] = e;
                count++;
            &#125;
        &#125;
    &#125;
    // 给新数组初始化下次扩容阈值，为数组长度的三分之二
    setThreshold(newLen);
    size = count;
    table = newTab;
&#125;
</code></pre>
<blockquote>
<p>1、扩容后数组大小是原来数组的两倍。</p>
<p>2、扩容时是没有<strong>线程安全</strong>问题的，因为 ThreadLocalMap 是线程的一个属性，一个线程同一时刻只能对 ThreadLocalMap 进行操作，因为同一个线程执行业务逻辑必然是串行的，那么操作 ThreadLocalMap 必然也是串行的。</p>
</blockquote>
<p><strong>内存泄漏</strong></p>
<blockquote>
<p>ThreadLocalMap的每个Entry都是一个对key的弱引用，同时每个Entry都包含了一个对value的强引用。</p>
<ul>
<li>正常情况下，当线程终止，保存在ThreadLocal里的value会被垃圾回收，因为没有任何强引用了。</li>
</ul>
<p>但是，如果线程不终止（比如线程需要保持很久），那么key对应的value就不能被回收，因为有以下的调用链：<code>Thread ---&gt; ThreadLocalMap ---&gt; Entry(key为null) ---&gt; value</code></p>
<p>因为value和Thread之间还存在这个强引用链路，所以导致value无法回收，就可能会出现OOM。</p>
<p>JDK已经考虑到了这个问题，所以在set，remove，rehash方法中会扫描key为null的Entry，并把对应的value设置为null，这样value对象就可以被回收。</p>
</blockquote>
<p><strong>如何避免内存泄露</strong></p>
<p>调用remove方法，就会删除对应的Entry对象，可以避兔内存泄漏，所以使用完ThreadLocal之后，应该调用remove方法。</p>
<pre><code class="java">ThreadLocal&lt;String&gt; localName = new ThreadLocal();
try &#123;
    localName.set(&quot;月伴飞鱼&quot;);
    // 其它业务逻辑
&#125; finally &#123;
    localName.remove();
&#125;
</code></pre>
<p><strong>空指针问题</strong></p>
<p>ThreadLocal在进行get之前，必须先set，否则会报空指针异常。</p>
<pre><code class="java">public class ThreadLocalNPE &#123;
    ThreadLocal&lt;Long&gt; longThreadLocal = new ThreadLocal&lt;&gt;();
    public void set() &#123;
        longThreadLocal.set(Thread.currentThread().getId());
    &#125;
    //拆装箱问题
    public Long get() &#123;//long：NullPointerException
        Long res = longThreadLocal.get();
        return res;
    &#125;
 
    public static void main(String[] args) &#123;
        ThreadLocalNPE threadLocalNPE = new ThreadLocalNPE();
        System.out.println(threadLocalNPE.get());//NullPointerException
    &#125;
&#125;
</code></pre>
<blockquote>
<p>如果在每个线程中<code>ThreadLocal.set()</code>进去的东西本来就是多线程共享的同一个对象，比如static对象，那么多个线程的 <code>ThreadLocal.get()</code>取得的还是这个共享对象本身，还是有并发访问问题。</p>
</blockquote>
<p><strong>InheritableThreadLocal</strong></p>
<blockquote>
<p>InheritableThreadLocal解决父子线程变量传递的问题。</p>
<ul>
<li>如果我在后面改了父线程，子线程不会更新它的本地变量map。</li>
</ul>
</blockquote>
<p><strong>TransmittableThreadLocal</strong></p>
<blockquote>
<p>TransmittableThreadLocal解决线程池变量丢失问题。</p>
<ul>
<li>线程池会复用之前的线程，导致父线程的本地变量更新之后，之前创建的子线程拿不到这个值。</li>
</ul>
<p>TransmittableThreadLocal通过将线程封装成TtlRunnable，然后通过快照还有hold一个总收集变量来解决。</p>
</blockquote>
<h1 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h1><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>LinkedList 适用于要求有顺序、并且会按照顺序进行迭代的场景，底层数据结构是一个双向链表:</p>
<img src="/images/image-20231015001829797.png" alt="image-20231015001829797" style="zoom:30%;" />

<blockquote>
<p>链表每个节点我们叫做 Node，Node 有 prev 属性，代表前一个节点的位置，next 属性，代表后一个节点的位置。</p>
<p>first 是双向链表的头节点，它的前一个节点是 null。</p>
<p>last 是双向链表的尾节点，它的后一个节点是 null。</p>
<p>当链表中没有数据时，first 和 last 是同一个节点，前后指向都是 null。</p>
<p>因为是个双向链表，只要机器内存足够强大，是没有大小限制的。</p>
</blockquote>
<pre><code class="java">    transient Node&lt;E&gt; first;//第一个节点
    transient Node&lt;E&gt; last;//最后一个节点
</code></pre>
<pre><code class="java">private static class Node&lt;E&gt; &#123;
    E item;// 节点值
    Node&lt;E&gt; next; // 指向的下一个节点
    Node&lt;E&gt; prev; // 指向的前一个节点

    // 初始化参数顺序分别是：前一个节点、本身节点值、后一个节点
    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;
        this.item = element;
        this.next = next;
        this.prev = prev;
    &#125;
&#125;
</code></pre>
<p><strong>追加（新增）</strong></p>
<blockquote>
<p>追加节点时，add 方法默认是从尾部开始追加，addFirst 方法是从头部开始追加。</p>
<p>尾部追加节点比较简单，只需要简单地把指向位置修改下即可。</p>
</blockquote>
<pre><code class="java">// 从尾部开始追加节点
public void addLast(E e) &#123;
        linkLast(e);
    &#125;
void linkLast(E e) &#123;
    // 把尾节点数据暂存
    final Node&lt;E&gt; l = last;
    // 新建新的节点，初始化入参含义：
    // l 是新节点的前一个节点，当前值是尾节点值
    // e 表示当前新增节点，当前新增节点后一个节点是 null
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);
    // 新建节点追加到尾部
    last = newNode;
    //如果链表为空（l 是尾节点，尾节点为空，链表即空），头部和尾部是同一个节点，都是新建的节点
    if (l == null)
        first = newNode;
    //否则把前尾节点的下一个节点，指向当前尾节点。
    else
        l.next = newNode;
    //大小和版本更改
    size++;
    modCount++;
&#125;
</code></pre>
<p><strong>节点删除</strong></p>
<blockquote>
<p>节点删除的方式和追加类似，可以选择从头部删除，也可以选择从尾部删除，删除操作会把节点的值，前后指向节点都置为 null，帮助 GC 进行回收。</p>
<p><strong>链表结构的节点新增、删除都非常简单，仅仅把前后节点的指向修改下就好了，所以 LinkedList 新增和删除速度很快。</strong></p>
</blockquote>
<pre><code class="java">public E removeFirst() &#123;
    final Node&lt;E&gt; f = first;
    if (f == null)
        throw new NoSuchElementException();
    return unlinkFirst(f);
&#125;
//从头删除节点 f 是链表头节点
private E unlinkFirst(Node&lt;E&gt; f) &#123;
    // 拿出头节点的值，作为方法的返回值
    final E element = f.item;
    // 拿出头节点的下一个节点
    final Node&lt;E&gt; next = f.next;
    //帮助 GC 回收头节点
    f.item = null;
    f.next = null;
    // 头节点的下一个节点成为头节点
    first = next;
    //如果 next 为空，表明链表为空
    if (next == null)
        last = null;
    //链表不为空，头节点的前一个节点指向 null
    else
        next.prev = null;
    //修改链表大小和版本
    size--;
    modCount++;
    return element;
&#125;
</code></pre>
<p><strong>节点查询</strong></p>
<p>链表查询某一个节点是比较慢的，需要挨个循环查找。</p>
<blockquote>
<p>LinkedList 并没有采用从头循环到尾的做法，而是采取了<strong>简单二分法</strong>，首先看看 index 是在链表的前半部分，还是后半部分。</p>
<p>如果是前半部分，就从头开始寻找，反之亦然。通过这种方式，使循环的次数至少降低了一半，提高了查找的性能。</p>
</blockquote>
<pre><code class="java">// 根据链表索引位置查询节点
Node&lt;E&gt; node(int index) &#123;
    // 如果 index 处于队列的前半部分，从头开始找，size &gt;&gt; 1 是 size 除以 2 的意思。
    if (index &lt; (size &gt;&gt; 1)) &#123;
        Node&lt;E&gt; x = first;
        // 直到 for 循环到 index 的前一个 node 停止
        for (int i = 0; i &lt; index; i++)
            x = x.next;
        return x;
    &#125; else &#123;// 如果 index 处于队列的后半部分，从尾开始找
        Node&lt;E&gt; x = last;
        // 直到 for 循环到 index 的后一个 node 停止
        for (int i = size - 1; i &gt; index; i--)
            x = x.prev;
        return x;
    &#125;
&#125;
</code></pre>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><blockquote>
<p>HashSet原理：使用的就是组合 HashMap。</p>
<ul>
<li>把 HashMap 当作自己的一个局部变量。</li>
</ul>
</blockquote>
<pre><code class="java">// 把 HashMap 组合进来，key 是 Hashset 的 key，value 是下面的 PRESENT
private transient HashMap&lt;E,Object&gt; map;
// HashMap 中的 value
private static final Object PRESENT = new Object();
</code></pre>
<blockquote>
<p>1、在使用 HashSet 时，比如 add 方法，只有一个入参，但组合的 Map 的 add 方法却有 key，value 两个入参，相对应上 Map 的 key 就是我们 add 的入参，value 就是第二行代码中的 PRESENT，用一个默认值 PRESENT 来代替 Map 的 Value；</p>
<p>2、如果 HashSet 是被共享的，当多个线程访问的时候，就会有线程安全问题，因为在后续的所有操作中，并没有加锁。</p>
</blockquote>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><blockquote>
<p>TreeSet底层组合的是 TreeMap，所以继承了 TreeMap key 能够排序的功能，迭代的时候，也可以按照 key 的排序顺序进行迭代。</p>
</blockquote>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><blockquote>
<p>TreeMap 底层的数据结构就是红黑树，和 HashMap 的红黑树结构一样。</p>
<p>不同的是：TreeMap 利用了红黑树左节点小，右节点大的性质，根据 key 进行排序，使每个元素能够插入到红黑树大小适当的位置，维护了 key 的大小关系，适用于 key 需要排序的场景。</p>
<p>因为底层使用的是平衡红黑树的结构，所以 containsKey、get、put、remove 等方法的时间复杂度都是 <code>log(n)</code>。</p>
</blockquote>
<p>TreeMap 常见的属性有：</p>
<pre><code class="java">//比较器，如果外部有传进来 Comparator 比较器，首先用外部的
//如果外部比较器为空，则使用 key 自己实现的 Comparable#compareTo 方法
//比较手段和上面日常工作中的比较 demo 是一致的
private final Comparator&lt;? super K&gt; comparator;
 
//红黑树的根节点
private transient Entry&lt;K,V&gt; root;
 
//红黑树的已有元素大小
private transient int size = 0;
 
//树结构变化的版本号，用于迭代过程中的快速失败场景
private transient int modCount = 0;
 
//红黑树的节点
static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;&#125;
</code></pre>
<p><strong>新增节点</strong></p>
<blockquote>
<p>判断红黑树的节点是否为空，为空的话，新增的节点直接作为根节点：</p>
</blockquote>
<pre><code class="java">Entry&lt;K,V&gt; t = root;
//红黑树根节点为空，直接新建
if (t == null) &#123;
    // compare 方法限制了 key 不能为 null
    compare(key, key); // type (and possibly null) check
    // 成为根节点
    root = new Entry&lt;&gt;(key, value, null);
    size = 1;
    modCount++;
    return null;
&#125;
</code></pre>
<blockquote>
<p>根据红黑树左小右大的特性，进行判断，找到应该新增节点的父节点：</p>
</blockquote>
<pre><code class="kotlin">Comparator&lt;? super K&gt; cpr = comparator;
if (cpr != null) &#123;
    //自旋找到 key 应该新增的位置，就是应该挂载那个节点的头上
    do &#123;
        //一次循环结束时，parent 就是上次比过的对象
        parent = t;
        // 通过 compare 来比较 key 的大小
        cmp = cpr.compare(key, t.key);
        //key 小于 t，把 t 左边的值赋予 t，因为红黑树左边的值比较小，循环再比
        if (cmp &lt; 0)
            t = t.left;
        //key 大于 t，把 t 右边的值赋予 t，因为红黑树右边的值比较大，循环再比
        else if (cmp &gt; 0)
            t = t.right;
        //如果相等的话，直接覆盖原值
        else
            return t.setValue(value);
        // t 为空，说明已经到叶子节点了
    &#125; while (t != null);
&#125;
</code></pre>
<blockquote>
<p>在父节点的左边或右边插入新增节点：</p>
</blockquote>
<pre><code class="java">//cmp 代表最后一次对比的大小，小于 0 ，代表 e 在上一节点的左边
if (cmp &lt; 0)
    parent.left = e;
//cmp 代表最后一次对比的大小，大于 0 ，代表 e 在上一节点的右边，相等的情况第二步已经处理了。
else
    parent.right = e;
</code></pre>
<blockquote>
<p>1、着色旋转，达到平衡，结束。</p>
<p>2、新增节点时，就是利用了红黑树左小右大的特性，从根节点不断往下查找，直到找到节点是 null 为止，节点为 null 说明到达了叶子结点。</p>
<p>3、查找过程中，发现 key 值已经存在，直接覆盖。</p>
<p>4、TreeMap 是禁止 key 是 null 值的。</p>
</blockquote>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><blockquote>
<p>LinkedHashMap 是继承 HashMap 的，所以它拥有 HashMap 的所有特性，再此基础上，还提供了两大特性：</p>
<ul>
<li>按照插入顺序进行访问。</li>
<li>实现了访问最少最先删除功能，其目的是把很久都没有访问的 key 自动删除。</li>
</ul>
</blockquote>
<p><strong>LinkedHashMap链表结构</strong></p>
<pre><code class="java">// 链表头
transient LinkedHashMap.Entry&lt;K,V&gt; head;
 
// 链表尾
transient LinkedHashMap.Entry&lt;K,V&gt; tail;
 
// 继承 Node，为数组的每个元素增加了 before 和 after 属性
static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;
    Entry&lt;K,V&gt; before, after;
    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;
        super(hash, key, value, next);
    &#125;
&#125;
 
// 控制两种访问模式的字段，默认 false
// true 按照访问顺序，会把经常访问的 key 放到队尾
// false 按照插入顺序提供访问
final boolean accessOrder;
</code></pre>
<blockquote>
<p>LinkedHashMap 的数据结构很像是把 LinkedList 的每个元素换成了 HashMap 的 Node，像是两者的结合体，也正是因为增加了这些结构，从而能把 Map 的元素都串联起来，形成一个链表，而链表就可以保证顺序了，就可以维护元素插入进来的顺序。</p>
</blockquote>
<p><strong>如何按照顺序新增</strong></p>
<blockquote>
<p>LinkedHashMap 初始化时，默认 accessOrder 为 false，就是会按照插入顺序提供访问，插入方法使用的是父类 HashMap 的 put 方法，不过覆写了 put 方法执行中调用的 newNode&#x2F;newTreeNode 和 afterNodeAccess 方法。</p>
</blockquote>
<blockquote>
<p>newNode&#x2F;newTreeNode 方法，控制新增节点追加到链表的尾部，这样每次新节点都追加到尾部，即可保证插入顺序了。</p>
</blockquote>
<pre><code class="java">// 新增节点，并追加到链表的尾部
Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123;
    // 新增节点
    LinkedHashMap.Entry&lt;K,V&gt; p =
        new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);
    // 追加到链表的尾部
    linkNodeLast(p);
    return p;
&#125;
// link at the end of list
private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123;
    LinkedHashMap.Entry&lt;K,V&gt; last = tail;
    // 新增节点等于位节点
    tail = p;
    // last 为空，说明链表为空，首尾节点相等
    if (last == null)
        head = p;
    // 链表有数据，直接建立新增节点和上个尾节点之间的前后关系即可
    else &#123;
        p.before = last;
        last.after = p;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>LinkedHashMap 通过新增头节点、尾节点，给每个节点增加 before、after 属性，每次新增时，都把节点追加到尾节点等手段，在新增的时候，就已经维护了按照插入顺序的链表结构了。</p>
</blockquote>
<h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><p><strong>同步阻塞</strong></p>
<blockquote>
<p>用户空间的应用程序执行一个系统调用，这会导致应用程序阻塞，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据，在等待数据到处理数据的两个阶段，整个进程都被阻塞，不能处理别的网络IO。</p>
</blockquote>
<p><strong>同步非阻塞</strong></p>
<p>非阻塞的系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。</p>
<blockquote>
<p>进程在返回之后，可以干点别的事情，然后再发起系统调用。</p>
<p>重复上面的过程，循环往复的进行系统调用，这个过程通常被称之为轮询。</p>
<p>轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。</p>
<p>需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。</p>
</blockquote>
<p><strong>IO多路复用</strong></p>
<blockquote>
<p>IO多路复用，这是一种进程预先告知内核的能力，让内核发现进程指定的一个或多个IO条件就绪了，就通知进程。</p>
<p>IO复用的实现方式目前主要有Select、Poll和Epoll。</p>
</blockquote>
<p><strong>信号驱动</strong></p>
<blockquote>
<p>首先我们允许Socket进行信号驱动IO，并安装一个信号处理函数，进程继续运行并不阻塞。</p>
<p>当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I&#x2F;O操作函数处理数据。</p>
<p>此种IO方式存在的一个很大的问题：</p>
<ul>
<li>Linux中信号队列是有限制的，如果超过这个数字问题就无法读取数据。</li>
</ul>
</blockquote>
<p><strong>异步非阻塞</strong></p>
<blockquote>
<p>当用户线程进行了系统调用，立刻就可以开始去做其它的事，用户线程不阻塞。</p>
<ul>
<li>准备数据：当内核一直等到数据准备好了，它就会将数据从内核内核缓冲区，拷贝到用户缓冲区。</li>
</ul>
<ul>
<li>内核会给用户线程发送一个信号，或者回调用户线程注册的回调接口，告诉用户线程操作完成了。</li>
<li>用户线程读取用户缓冲区的数据，完成后续的业务操作。</li>
</ul>
<p>信号驱动IO，异步IO的主要区别在于：</p>
<ul>
<li>信号驱动由内核告诉我们何时可以开始一个IO操作(数据在内核缓冲区中)。</li>
<li>而异步IO则由内核通知IO操作何时已经完成(数据已经在用户空间中)。</li>
</ul>
</blockquote>
<p><strong>BIO，NIO，AIO的区别：</strong></p>
<blockquote>
<p>BIO：</p>
<ul>
<li>同步并阻塞，服务实现模式为一个连接对应一个线程，即客户端发送一个连接，服务端要有一个线程来处理。</li>
<li>如果连接多了，线程数量不够，就只能等待，即会发生阻塞。</li>
<li>适用连接数目比较小且固定的架构。</li>
</ul>
<p>NIO：</p>
<ul>
<li>同步非阻塞，服务实现模式是一个线程可以处理多个连接，即客户端发送的连接都会注册到多路复用器上，然后进行轮询连接，有I&#x2F;O请求就处理。</li>
<li>适用连接数目多且连接比较短的架构，如：聊天服务器，弹幕系统等，编程比较复杂。</li>
</ul>
<p>AIO：</p>
<ul>
<li>异步非阻塞，引入了异步通道，采用的是Proactor模式。</li>
<li>适用连接数目多且连接长的架构，如相册服务器。</li>
</ul>
</blockquote>
<h1 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h1><p><strong>JDK 17</strong></p>
<p>Sealed类：</p>
<blockquote>
<p>Sealed类是一种新的类修饰符，用于限制类的继承。</p>
<p>Sealed类可以控制哪些类可以继承自它，这样可以使得代码更加安全、可维护。</p>
</blockquote>
<p>Pattern Matching for Switch：</p>
<blockquote>
<p>新的Switch语法，可以用于模式匹配。</p>
<p>可以根据不同的模式执行不同的操作，从而使得代码更加简洁、易读、易维护。</p>
<p>可以减少代码量，避免出现大量的if-else语句。</p>
</blockquote>
<p>改进的垃圾回收器（ZGC（新型垃圾收集器）):</p>
<blockquote>
<p>改进了垃圾回收器，提高了垃圾回收的效率和吞吐量。</p>
<p>改进的垃圾回收器可以更加高效地回收内存，从而提高应用程序的性能和响应速度。</p>
</blockquote>
<p>风格的内存管理:</p>
<blockquote>
<p>引入了C++风格的内存管理，包括对堆内存分配的优化和对垃圾回收的改进。</p>
<p>C++风格的内存管理可以使得Java应用程序更加高效，从而提高应用程序的性能和响应速度。</p>
</blockquote>
<p><strong>JDK21</strong></p>
<p>序列化集合接口:</p>
<blockquote>
<p>新增了序列集合接口 <code>SequencedCollection</code>，常用的 <code>ArrayList</code>、<code>LinkedList</code>等都实现了这个接口。</p>
</blockquote>
<p>ZGC增加分代:</p>
<blockquote>
<p>JDK21中对 ZGC 进行了功能扩展，增加了分代功能，比如 CMS 收集器区分老年代和年轻代，这样一来，可以更频繁的回收年轻代。</p>
</blockquote>

	</div>
</div>


    <div class="post-guide">
        <div class="item left">
            
              <a href="/2022/11/25/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  面试算法
              </a>
            
        </div>
        <div class="item right">
            
        </div>
    </div>




<script>

    //document.oncontextmenu=new Function("event.returnValue=false");
	//document.onselectstart=new Function("event.returnValue=false");

	

	$(function () {
		const btw = new BTWPlugin();
	    btw.init({
	        id: 'container',
	        blogId: '22377-1657723090751-870',
	        name: '月伴飞鱼',
	        qrcode: '/个人公众号.jpg',
	        keyword: '验证码',
	    });

	    var contents = document.getElementsByClassName("content999");
	    //监听文章内容的copy事件
	    contents[0].addEventListener('copy',function(e){
	        setClipboardText(e);
	    });

	    function setClipboardText(event){
	        // clipboardData 对象是为通过编辑菜单、快捷菜单和快捷键执行的编辑操作所保留的，也就是你复制或者剪切内容
	        let clipboardData = event.clipboardData || window.clipboardData;

	        // 如果未复制或者未剪切，则return出去
	        if (!clipboardData) { return; }

	        event.preventDefault();

	        // Selection 对象，表示用户选择的文本范围或光标的当前位置。
	        // 声明一个变量接收 -- 用户输入的剪切或者复制的文本转化为字符串
	        let text = window.getSelection().toString();
	    
	        if (text) {
	            // 如果文本存在则先取消文本默认事件
	            event.preventDefault();
	            // 通过调用常clipboardData对象的 setData(format, data) 方法；来设置相关文本
	            // format: 一个DOMString 表示要添加到 drag object的拖动数据的类型。
	            // data: 一个 DOMString表示要添加到 drag object的数据。
	            var copyright = '\n\n'
	            + '\n著作权归作者所有。'
	            + '\n商业转载请联系作者获得授权，非商业转载请注明出处。'
	            + '\n作者: 月伴飞鱼'
	            + '\n原文地址: https://xiaoflyfish.cn/2022/11/21/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E5%9F%BA%E7%A1%80/'
	    
	            clipboardData.setData('text/plain', text + copyright);
	    
	        }
	    };
	});

	
</script>

<script>
    const btw = new BTWPlugin();
    btw.init({
        id: 'container',
        blogId: '22377-1657723090751-870',
        name: '月伴飞鱼',
        qrcode: '/个人公众号.jpg',
        keyword: '验证码',
    });
</script>
	</div>
	<div id="footer">
	<p>
	©2019-<span id="footerYear"></span> 
	<a href="/">月伴飞鱼</a> 
	
	
		|
		<span id="busuanzi_container_site_pv">
			PV 180986
		</span>
		|
		<span id="busuanzi_container_site_uv"> 
			UV 10079
		</span>
	
	<br>
	微信搜索 <a href="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/个人公众号.jpg" target="_blank">月伴飞鱼</a> 关注我
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>
	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>