<!DOCTYPE html>
<html lang="en" oncontextmenu="return false;">

<head oncontextmenu="return false;">
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta name="baidu-site-verification" content="codeva-QodU0Nk5F7" />
	<meta name="google-site-verification" content="DbSTw8OJwtH5Qei7n8Jnew0YyQ5naPzdLAPiscu7zQE" />
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">

	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "https://hm.baidu.com/hm.js?7eeb54583579fabc0878be210d6ad60a";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>

	
	<!-- title -->
	
	<title>
	
		Java基础 | 
	 
	月伴飞鱼
	</title>
	
	<!-- keywords,description -->
	 

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/%E5%A4%B4%E5%83%8F.jpg">
	
  
  	
<link rel="stylesheet" href="/css/main.css">

  	
<link rel="stylesheet" href="/css/reward.css">

	
<link rel="stylesheet" href="/css/jquery.fancybox.min.css">

	
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="/lib/highlight/darcula.css">

	
<link rel="stylesheet" href="/css/clipboard-use.css">


	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">


	
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>


	
<script src="/lib/highlight/highlight.min.js"></script>


	
<script src="https://readmore.openwrite.cn/js/readmore-2.0.js"></script>

	
<script src="/lib/jquery-3.4.1.min.js"></script>

	
<script src="/lib/jquery.pjax.js"></script>


	
<script src="/js/main.js"></script>

	
<script src="/js/jquery.fancybox.min.js"></script>

	
		
<script src="/lib/valine/av-3.0.4-min.js"></script>

		
<script src="/lib/valine/Valine-1.3.10-min.js"></script>

	
	
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
	
<script src="/js/clipboard.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body oncontextmenu="return false;">
	<header id="header" oncontextmenu="return false;">
    <a id="title" href="/" class="logo">公众号月伴飞鱼</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">关于我</a>
		</li>

		<li class="menu-item">
			<a href="/个人微信.jpeg" class="menu-item-link">联系作者</a>
		</li>

	    <li class="menu-item">
			<a href="/site" class="menu-item-link">关于网站</a>
		</li>

		<li class="menu-item">
			<a href="/个人公众号.jpg" class="menu-item-link" target="_blank">我的公众号</a>
		</li>
		
		<li class="menu-item">
			<a href="https://tech.meituan.com/" class="menu-item-link" target="_blank">
				美团技术团队
			</a>
		</li>
		<li class="menu-item">
			<a href="https://tech.youzan.com/" class="menu-item-link" target="_blank">
				有赞技术团队
			</a>
		</li>
		<!--<li class="menu-item">
			<select class="menu-item-link menu-item-select">
				<option class="menu-item-link"  value="volvo">Volvo</option>
				<option class="menu-item-link"  value="saab">Saab</option>
				<option class="menu-item-link"  value="fiat">Fiat</option>
				<option class="menu-item-link"  value="audi">Audi</option>
			</select>
		</li>-->
	</ul>
</header>

	<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="text" placeholder="按目录搜索一下">
		<div id="tree">
			

			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										中间件
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/30/%E4%B8%AD%E9%97%B4%E4%BB%B6/Dubbo/">
										Dubbo
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/12/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/Elasticsearch/">
										Elasticsearch
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/30/%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty/">
										Netty
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/ZooKeeper/">
										ZooKeeper
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										代码思想
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/12/15/%E4%BB%A3%E7%A0%81%E6%80%9D%E6%83%B3/CodeReview/">
										CodeReview
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/02/%E4%BB%A3%E7%A0%81%E6%80%9D%E6%83%B3/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/">
										代码重构
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										前端相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/CSS/">
										CSS
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/Vue/">
										Vue
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/12/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">
										小程序
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										基础知识
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/11/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Go%E5%9F%BA%E7%A1%80/">
										Go基础
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/11/27/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM/">
										JVM
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file active">
									<a href="/2022/11/21/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E5%9F%BA%E7%A1%80/">
										Java基础
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F/">
										分布式
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/12/10/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">
										并发编程
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
										设计模式
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										娱乐相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/27/%E5%A8%B1%E4%B9%90%E7%9B%B8%E5%85%B3/%E4%B9%A6%E7%B1%8D/">
										书籍
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/12/17/%E5%A8%B1%E4%B9%90%E7%9B%B8%E5%85%B3/%E5%81%9A%E8%8F%9C/">
										做菜
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/10/%E5%A8%B1%E4%B9%90%E7%9B%B8%E5%85%B3/%E7%94%B5%E5%BD%B1/">
										电影
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/09/%E5%A8%B1%E4%B9%90%E7%9B%B8%E5%85%B3/%E9%9F%B3%E4%B9%90/">
										音乐
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										学习专栏
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/31/%E5%AD%A6%E4%B9%A0%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%91/">
										代码之丑
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/26/%E5%AD%A6%E4%B9%A0%E4%B8%93%E6%A0%8F/%E5%A4%A7%E5%8E%82%E6%99%8B%E5%8D%87%E6%8C%87%E5%8D%97/">
										大厂晋升指南
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										学习书籍
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/11/16/%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/">
										Java开发手册
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										工具相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/11/09/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Arthas/">
										Arthas
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/21/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/GIT/">
										GIT
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/21/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Hexo/">
										Hexo
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/21/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/MAC/">
										MAC
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/01/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Maven/">
										Maven
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/">
										实用工具
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										成长相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/31/%E6%88%90%E9%95%BF%E7%9B%B8%E5%85%B3/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">
										技术学习
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/09/%E6%88%90%E9%95%BF%E7%9B%B8%E5%85%B3/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/">
										面试相关
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										数据库
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/27/%E6%95%B0%E6%8D%AE%E5%BA%93/HBase/">
										HBase
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/09/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/">
										MongoDB
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/12/02/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">
										MySQL
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/">
										Redis
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										服务器
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E6%9C%8D%E5%8A%A1%E5%99%A8/Docker/">
										Docker
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/09/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/">
										Nginx
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/03/%E6%9C%8D%E5%8A%A1%E5%99%A8/Tomcat/">
										Tomcat
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/09/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E8%BF%90%E7%BB%B4%E7%9F%A5%E8%AF%86/">
										运维知识
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										架构相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/21/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/DDD/">
										DDD
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/02/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/%E6%9E%B6%E6%9E%84%E5%9B%BE/">
										架构图
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/02/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0/">
										架构学习
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/26/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/%E7%B3%BB%E7%BB%9F%E4%BF%9D%E9%9A%9C/">
										系统保障
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/31/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD/">
										系统性能
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/26/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">
										系统设计
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										框架相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/11/15/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/JWT/">
										JWT
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/08/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/MyBatis/">
										MyBatis
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/14/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/RPC%E6%A1%86%E6%9E%B6/">
										RPC框架
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/26/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/Seata/">
										Seata
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/14/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/Spring/">
										Spring
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/03/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/Thrift/">
										Thrift
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/29/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/XXLJOB/">
										XXLJOB
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/10/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/">
										开源框架
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										消息队列
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/KAFKA/">
										KAFKA
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/">
										RocketMQ
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										源码相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/12/13/%E6%BA%90%E7%A0%81%E7%9B%B8%E5%85%B3/RocketMQ/">
										RocketMQ
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										算法相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/11/26/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/LeetCode/">
										LeetCode
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/11/26/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E5%89%91%E6%8C%87OFFER/">
										剑指OFFER
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/11/25/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/">
										面试算法
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										系统相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/11/19/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/">
										任务系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/18/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/%E5%B9%BF%E5%91%8A%E7%B3%BB%E7%BB%9F/">
										广告系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/19/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/%E6%89%93%E8%BD%A6%E7%B3%BB%E7%BB%9F/">
										打车系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/18/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/">
										推荐系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/19/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F/">
										用户系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/19/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/">
										直播系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/19/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/%E7%9F%AD%E9%93%BE%E7%B3%BB%E7%BB%9F/">
										短链系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/19/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/%E7%A4%BE%E5%8C%BA%E7%B3%BB%E7%BB%9F/">
										社区系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/19/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/">
										秒杀系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/19/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/">
										红包系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/18/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F/">
										订单系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										英语相关
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										老友记
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/08/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E8%80%81%E5%8F%8B%E8%AE%B0/%E7%AC%AC%E4%B8%80%E5%AD%A3/">
										第一季
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/08/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E8%80%81%E5%8F%8B%E8%AE%B0/%E7%AC%AC%E4%B8%89%E5%AD%A3/">
										第三季
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/11/23/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E8%80%81%E5%8F%8B%E8%AE%B0/%E7%AC%AC%E4%BA%94%E5%AD%A3/">
										第五季
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/12/17/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/">
										英语语法
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										雅思
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/12/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E9%9B%85%E6%80%9D/%E5%89%91%E6%A1%A5%E9%9B%85%E6%80%9D%E5%90%AC%E5%8A%9B%E7%9C%9F%E9%A2%98/">
										剑桥雅思听力真题
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										计算机基础
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
										操作系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
										数据结构
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/">
										算法知识
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/12/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">
										网络基础
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title" oncontextmenu="return false;">

	Java基础
</h1>
<div class="article-meta" oncontextmenu="return false;">
	<span>月伴飞鱼</span>
	<span>2022-11-21 23:49:55</span>
    
		<div id="article-categories">
            
                
                    <span>
                        <i class="fa fa-folder" aria-hidden="true"></i>
                        <a href="/categories/基础知识/">基础知识</a>
						
                    </span>
                
            
		</div>
    
</div>

<div id="container" class = "content999" oncontextmenu="return false;">
<!--打赏-->
        <div class="reward">
       <div class="reward-button">赏 <span class="reward-code">
        <span class="alipay-code"> <img class="alipay-img wdp-appear" src="/alipay.png"><b>支付宝打赏</b> </span> 
        <span class="wechat-code"> <img class="wechat-img wdp-appear" src="/weipay.jpeg"><b>微信打赏</b> </span> 
       </div>
      <p class="reward-notice">如果文章对你有帮助，欢迎点击上方按钮打赏作者！</p>
      </div>
      <!--打赏-->
	<div id="article-content">
		<p>不同版本JDK安装网站：<a target="_blank" rel="noopener" href="https://adoptium.net/zh-CN/">https://adoptium.net/zh-CN/</a></p>
<p><strong>值传递还是引用传递</strong></p>
<blockquote>
<p>Java中方法参数传递方式是按值传递。</p>
<p>如果参数是基本类型，传递的是基本类型的数据拷贝。</p>
<p>如果参数是引用类型，因为栈中存的是对象的地址值，所以传递的是该参量所引用的对象在堆中地址值的拷贝。</p>
</blockquote>
<p><strong>编译期与运行期</strong></p>
<blockquote>
<p><strong>编译期</strong>是指把源码交给编译器编译成计算机可执行文件的过程，<strong>运行期</strong>是指把编译后的文件交给计算机执行，直到程序结束。</p>
<p>在<code>Java</code>中就是把<code>.java</code>文件编译成<code>.class</code>文件，再把编译后的文件交给<code>JVM</code>加载执行。</p>
</blockquote>
<img src="/images/image-20231016000034082.png" alt="image-20231016000034082" style="zoom:40%;" />

<p><strong>接口和抽象的区别</strong></p>
<blockquote>
<p>抽象类带来的很大的作用就是实现代码复用，比如当有多个子类有相同的属性或方法时，我们可以抽象出一个公共的类，然后子类继承这个抽象类，当然，这个公共类可以是普通父类，也可以是抽象类。</p>
<ul>
<li>但是抽象类中的方法可以交给子类去实现，让子类有不同的功能。</li>
</ul>
<p>接口实现了约定和实现相分离，降低了代码间的耦合性，提高代码的可扩展性。</p>
<ul>
<li>调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。</li>
</ul>
</blockquote>
<p><strong>反射</strong></p>
<blockquote>
<p>在Java运行状态时，只要给定类的名字，就能知道这个类的所有信息，可以构造出指定对象，可以调用它的任意一个属性和方法。</p>
<ul>
<li>这种动态获取信息以及动态调用对象的方法的功能是反射机制。</li>
</ul>
</blockquote>
<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><p><strong>Final</strong></p>
<p>Final可以用来修饰变量、方法或者类。</p>
<blockquote>
<p>修饰变量：</p>
<ul>
<li>这个<strong>变量一旦被赋值就不能被修改了</strong>，如果尝试给其赋值，会报编译错误。</li>
</ul>
<p>修饰方法：</p>
<ul>
<li>该方法不可以被重写。</li>
</ul>
<p>修饰类：</p>
<ul>
<li>这个类<strong>不可被继承</strong>。</li>
</ul>
<p>注意：Final修饰对象时，只是引用不可变，而对象本身的内容依然是可以变化的。</p>
<ul>
<li>这一点同样适用于数组。</li>
</ul>
</blockquote>
<p><strong>Static</strong></p>
<blockquote>
<p><strong>修饰类变量:</strong></p>
<ul>
<li>如果该变量是 public 的话，表示该变量任何类都可以直接访问，而且无需初始化类，直接使用 <strong>类名.static 变量</strong> 访问。</li>
</ul>
<p><strong>修饰方法:</strong></p>
<ul>
<li><p>代表该方法和当前类是无关的，任意类都可以直接访问（如果权限是 public 的话）。</p>
</li>
<li><p>被 static 修饰的方法，在类初始化的时候并不会初始化，只有当自己被调用时，才会被执行。</p>
</li>
</ul>
<p><strong>修饰方法块:</strong></p>
<ul>
<li>方法块（静态块）常常用于在类启动之前，初始化一些值。</li>
<li>静态块只能调用同样被 static 修饰的变量，并且 static 的变量需要写在静态块的前面，不然编译会报错。</li>
</ul>
</blockquote>
<p><strong>Transient</strong></p>
<blockquote>
<p>transient用来修饰类变量，意思是当前变量无需进行序列化。</p>
</blockquote>
<p><strong>非静态初始化块（构造代码块）：</strong></p>
<blockquote>
<p>给对象进行初始化，对象一建立就运行，且优先于构造函数的运行。</p>
<p>非静态初始化块给所有对象进行统一初始化，构造函数只给对应对象初始化。</p>
<p>可以将所有构造函数共性的东西定义在构造代码块中。</p>
</blockquote>
<p><strong>静态初始化块：</strong></p>
<blockquote>
<p>给类进行初始化，随着类的加载而执行，且只执行一次。</p>
</blockquote>
<blockquote>
<p><strong>与构造代码块的区别：</strong></p>
<ul>
<li>构造代码块用于初始化对象，每创建一个对象就会被执行一次。</li>
<li>静态代码块用于初始化类，随着类的加载而执行，不管创建几个对象，都只执行一次。</li>
<li>静态代码块优先于构造代码块的执行。</li>
</ul>
</blockquote>
<p>执行顺序：</p>
<blockquote>
<p>所有的静态初始化块都优先执行，其次才是非静态的初始化块和构造函数，它们的执行顺序是：</p>
<ul>
<li>父类的静态初始化块</li>
<li>子类的静态初始化块</li>
<li>父类的初始化块</li>
<li>父类的构造函数</li>
<li>子类的初始化块</li>
<li>子类的构造函数</li>
</ul>
</blockquote>
<h2 id="Long"><a href="#Long" class="headerlink" title="Long"></a>Long</h2><p>Long 自己实现了一种缓存机制，缓存了从 -128 到 127 内的所有 Long 值，如果是这个范围内的 Long 值，就不会初始化，而是从缓存中拿，缓存初始化源码如下：</p>
<pre><code class="java">private static class LongCache &#123;
    private LongCache()&#123;&#125;
    // 缓存，范围从 -128 到 127，+1 是因为有个 0
    static final Long cache[] = new Long[-(-128) + 127 + 1];
 
    // 容器初始化时，进行加载
    static &#123;
        // 缓存 Long 值，注意这里是 i - 128 ，所以再拿的时候就需要 + 128
        for(int i = 0; i &lt; cache.length; i++)
            cache[i] = new Long(i - 128);
    &#125;
&#125;
</code></pre>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><strong>字符串是一个常量</strong>，一旦创建了一个 String 对象，就无法改变它的值，它的内容也就不可能发生变化（不考虑反射这种特殊行为）。</p>
<p><strong>String 具备不变性背后的原因是什么：</strong></p>
<pre><code class="java">public final class String
    implements Java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;
    /** The value is used for character storage. */
    private final char value[];
    //...
&#125;
</code></pre>
<blockquote>
<p><code>private final</code> 的 char 数组，数组名字叫 value。</p>
<p>它存储着字符串的每一位字符，同时 value 数组是被 final 修饰的，这个 value 一旦被赋值，引用就不能修改了。</p>
<p>除了构造函数之外，并没有任何其他方法会修改 value 数组里面的内容，而且 value 的权限是 private，外部的类也访问不到，所以最终使得 value 是不可变的。</p>
<p>String 类是被 final 修饰的，所以这个 String 类是不会被继承的，因此没有任何人可以通过扩展或者覆盖行为来破坏 String 类的不变性。</p>
</blockquote>
<p><strong>String 不可变的好处</strong></p>
<blockquote>
<p>1、使用字符串常量池。</p>
<p>2、用作 HashMap 的 key。</p>
<p>3、缓存 HashCode。</p>
<p>4、<strong>线程安全</strong>。</p>
</blockquote>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>泛型就是在定义类、接口、方法的时候指定某一种特定类型，让类、接口、方法的使用者来决定具体用哪一种类型的参数。</p>
<blockquote>
<p>泛型是在<code>1.5</code>引入的，只在<strong>编译期</strong>做泛型检查，<strong>运行期</strong>泛型就会消失，称为 <strong>泛型擦除</strong>，最终类型都会变成<code>Object</code>。</p>
<p>泛型的本质是参数化类型，而类型擦除使得类型参数只存在于编译期，在运行时，<code>JVM</code>是并不知道泛型的存在的。</p>
</blockquote>
<p><strong>泛型好处</strong></p>
<blockquote>
<p>在编译的时候能够检查类型安全，并且所有的强制转换都是自动和隐式的。</p>
</blockquote>
<p><strong>类型擦除</strong></p>
<pre><code class="java">public static void main(String[] args) &#123;
    List&lt;String&gt; list1=new ArrayList&lt;String&gt;();
    List&lt;Integer&gt; list2=new ArrayList&lt;Integer&gt;();
    System.out.println(list1.getClass()==list2.getClass());
&#125;
</code></pre>
<blockquote>
<p><code>ArrayList&lt;String&gt;</code>和<code>ArrayList&lt;Integer&gt;</code>在编译时是不同的类型，但是在编译完成后都被编译器简化成了<code>ArrayList</code>。</p>
</blockquote>
<p><strong>为什么要进行泛型的类型擦除？</strong></p>
<blockquote>
<p>主要目的是避免过多的创建类而造成的运行时的过度消耗。</p>
</blockquote>
<p><strong>泛型类</strong></p>
<pre><code class="java">public class GenericClass&lt;T&gt;&#123;
    //成员变量
    private T t;
    
    public  void function(T t)&#123;

    &#125;
    
    public T functionTwo(T t)&#123;
        //注意，这个不是泛型方法！！！
       return t;
    &#125;
&#125;
</code></pre>
<p><strong>泛型接口</strong></p>
<pre><code class="java">public interface GenericInterface&lt;T&gt; &#123;
    
    public T get();
    
    public void set(T t);

    public T delete(T t);
    
    default T defaultFunction(T t)&#123;
        return t;
    &#125;
&#125;
</code></pre>
<p><strong>泛型函数</strong></p>
<pre><code class="java">public class GenericFunction &#123;

    public &lt;T&gt; void function(T t) &#123;
    &#125;

    public &lt;T&gt; T functionTwo(T t) &#123;
        return t;
    &#125;

    public &lt;T&gt; String functionThree(T t) &#123;
        return &quot;&quot;;
    &#125;
&#125;
</code></pre>
<p><strong>通配符</strong></p>
<p>通配符是为了让<code>Java</code>泛型支持范围限定。</p>
<blockquote>
<p><code>&lt;?&gt;</code>：无界通配符，即类型不确定，任意类型。</p>
<p><code>&lt;? extends T&gt;</code>：上边界通配符，即<code>?</code>是继承自<code>T</code>的任意子类型，遵守只读不写。</p>
<p><code>&lt;? super T&gt;</code>：下边界通配符，即<code>?</code>是<code>T</code>的任意父类型，遵守只写不读。</p>
</blockquote>
<blockquote>
<p><code>&lt;? extends T&gt;</code>上边界通配符：</p>
<ul>
<li>不作为函数入参，只作为函数返回类型，比如<code>List&lt;? extends T&gt;</code>的使用<code>add</code>函数会编译不通过，<code>get</code>函数则没问题。</li>
</ul>
<p><code>&lt;? super T&gt;</code>下边界通配符：</p>
<ul>
<li>不作为函数返回类型，只作为函数入参，比如<code>List&lt;? super T&gt;</code>的<code>add</code>函数正常调用，<code>get</code>函数也没问题，但只会返回<code>Object</code>，所以意义不大。</li>
</ul>
</blockquote>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>ThreadLocal 提供了线程本地变量的实例，它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。</p>
<p><strong>使用场景</strong></p>
<blockquote>
<p>ThreadLocal 用作保存每个线程独享的对象，为每个线程都创建一个副本，这样每个线程都可以修改自己所拥有的副本, 而不会影响其他线程的副本，确保了线程安全。</p>
<p>ThreadLocal 用作每个线程内需要独立保存信息，以便供其他方法更方便地获取该信息的场景，避免了传参，类似于全局变量的概念。</p>
</blockquote>
<p><strong>关键属性</strong></p>
<pre><code class="java">// threadLocalHashCode 表示当前 ThreadLocal 的 hashCode，用于计算当前 ThreadLocal 在 ThreadLocalMap 中的索引位置
private final int threadLocalHashCode = nextHashCode();
// 计算 ThreadLocal 的 hashCode 值(就是递增)
private static int nextHashCode() &#123;
    return nextHashCode.getAndAdd(HASH_INCREMENT);
&#125;
// static + AtomicInteger 保证了在一台机器中每个 ThreadLocal 的 threadLocalHashCode 是唯一的
// 被 static 修饰非常关键，因为一个线程在处理业务的过程中，ThreadLocalMap 是会被 set 多个 ThreadLocal 的，多个 ThreadLocal 就依靠 threadLocalHashCode 进行区分
private static AtomicInteger nextHashCode = new AtomicInteger();
</code></pre>
<p><strong>ThreadLocalMap</strong></p>
<blockquote>
<p>ThreadLocalMap 本身就是一个简单的 Map 结构，key 是 ThreadLocal，value 是 ThreadLocal 保存的值，底层是数组的数据结构。</p>
</blockquote>
<pre><code class="java">static class ThreadLocalMap &#123;
        // 数组中的每个节点值，WeakReference 是弱引用，当没有引用指向时，会直接被回收
        static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;
            // 当前 ThreadLocal 关联的值
            Object value;
            // WeakReference 的引用 referent 就是 ThreadLocal
            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;
                super(k);
                value = v;
            &#125;
        &#125;
        // 数组的初始化大小
        private static final int INITIAL_CAPACITY = 16;
        // 存储 ThreadLocal 的数组
        private Entry[] table;
        // 扩容的阈值，默认是数组大小的三分之二
        private int threshold;
&#125;
</code></pre>
<p><strong>ThreadLocal 是如何做到线程之间数据隔离的</strong></p>
<blockquote>
<p>主要因为是 ThreadLocalMap 是线程的属性。</p>
<p><code>ThreadLocals.ThreadLocalMap</code> 和 <code>InheritableThreadLocals.ThreadLocalMap</code> 分别是线程的属性，所以每个线程的 ThreadLocals 都是隔离独享的。</p>
<p>父线程在创建子线程的情况下，会拷贝 inheritableThreadLocals 的值，但不会拷贝 threadLocals 的值。</p>
</blockquote>
<p><strong>set 方法</strong></p>
<pre><code class="java">// set 操作每个线程都是串行的，不会有线程安全的问题
public void set(T value) &#123;
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    // 当前 thradLocal 之前有设置值，直接设置，否则初始化
    if (map != null)
        map.set(this, value);
    // 初始化ThreadLocalMap
    else
        createMap(t, value);
&#125;
</code></pre>
<pre><code class="java">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;
    Entry[] tab = table;
    int len = tab.length;
    // 计算 key 在数组中的下标，其实就是 ThreadLocal 的 hashCode 和数组大小-1取余
    int i = key.threadLocalHashCode &amp; (len-1);
 
    // 整体策略：查看 i 索引位置有没有值，有值的话，索引位置 + 1，直到找到没有值的位置
    // 这种解决 hash 冲突的策略，也导致了其在 get 时查找策略有所不同，体现在 getEntryAfterMiss 中
    for (Entry e = tab[i];
         e != null;
         // nextIndex 就是让在不超过数组长度的基础上，把数组的索引位置 + 1
         e = tab[i = nextIndex(i, len)]) &#123;
        ThreadLocal&lt;?&gt; k = e.get();
        // 找到内存地址一样的 ThreadLocal，直接替换
        if (k == key) &#123;
            e.value = value;
            return;
        &#125;
        // 当前 key 是 null，说明 ThreadLocal 被清理了，直接替换掉
        if (k == null) &#123;
            replaceStaleEntry(key, value, i);
            return;
        &#125;
    &#125;
    // 当前 i 位置是无值的，可以被当前 thradLocal 使用
    tab[i] = new Entry(key, value);
    int sz = ++size;
    // 当数组大小大于等于扩容阈值(数组大小的三分之二)时，进行扩容
    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)
        rehash();
&#125;
</code></pre>
<blockquote>
<p>1、通过递增的 AtomicInteger 作为 ThreadLocal 的 hashCode 的；</p>
<p>2、计算数组索引位置的公式是：</p>
<ul>
<li>hashCode 取模数组大小，由于 hashCode 不断自增，所以不同的 hashCode 大概率上会计算到同一个数组的索引位置（在实际项目中，ThreadLocal 都很少，基本上不会冲突）</li>
</ul>
<p>3、通过 hashCode 计算的索引位置 i 处如果已经有值了，会从 i 开始，通过 +1 不断的往后寻找，直到找到索引位置为空的地方，把当前 ThreadLocal 作为 key 放进去。</p>
</blockquote>
<p><strong>get 方法</strong></p>
<pre><code class="java">public T get() &#123;
    // 因为 threadLocal 属于线程的属性，所以需要先把当前线程拿出来
    Thread t = Thread.currentThread();
    // 从线程中拿到 ThreadLocalMap
    ThreadLocalMap map = getMap(t);
    if (map != null) &#123;
        // 从 map 中拿到 entry，由于 ThreadLocalMap 在 set 时的 hash 冲突的策略不同，导致拿的时候逻辑也不太一样
        ThreadLocalMap.Entry e = map.getEntry(this);
        // 如果不为空，读取当前 ThreadLocal 中保存的值
        if (e != null) &#123;
            @SuppressWarnings(&quot;unchecked&quot;)
            T result = (T)e.value;
            return result;
        &#125;
    &#125;
    // 否则给当前线程的 ThreadLocal 初始化，并返回初始值 null
    return setInitialValue();
&#125;
</code></pre>
<pre><code class="java">// 自旋 i+1，直到找到为止
private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;
    Entry[] tab = table;
    int len = tab.length;
    // 在大量使用不同 key 的 ThreadLocal 时，其实还蛮耗性能的
    while (e != null) &#123;
        ThreadLocal&lt;?&gt; k = e.get();
        // 内存地址一样，表示找到了
        if (k == key)
            return e;
        // 删除没用的 key
        if (k == null)
            expungeStaleEntry(i);
        // 继续使索引位置 + 1
        else
            i = nextIndex(i, len);
        e = tab[i];
    &#125;
    return null;
&#125;
</code></pre>
<p><strong>扩容</strong></p>
<p>ThreadLocalMap 中的 ThreadLocal 的个数超过阈值时，ThreadLocalMap 就要开始扩容了：</p>
<pre><code class="java">//扩容
private void resize() &#123;
    // 拿出旧的数组
    Entry[] oldTab = table;
    int oldLen = oldTab.length;
    // 新数组的大小为老数组的两倍
    int newLen = oldLen * 2;
    // 初始化新数组
    Entry[] newTab = new Entry[newLen];
    int count = 0;
    // 老数组的值拷贝到新数组上
    for (int j = 0; j &lt; oldLen; ++j) &#123;
        Entry e = oldTab[j];
        if (e != null) &#123;
            ThreadLocal&lt;?&gt; k = e.get();
            if (k == null) &#123;
                e.value = null; // Help the GC
            &#125; else &#123;
                // 计算 ThreadLocal 在新数组中的位置
                int h = k.threadLocalHashCode &amp; (newLen - 1);
                // 如果索引 h 的位置值不为空，往后+1，直到找到值为空的索引位置
                while (newTab[h] != null)
                    h = nextIndex(h, newLen);
                // 给新数组赋值
                newTab[h] = e;
                count++;
            &#125;
        &#125;
    &#125;
    // 给新数组初始化下次扩容阈值，为数组长度的三分之二
    setThreshold(newLen);
    size = count;
    table = newTab;
&#125;
</code></pre>
<blockquote>
<p>1、扩容后数组大小是原来数组的两倍。</p>
<p>2、扩容时是没有<strong>线程安全</strong>问题的，因为 ThreadLocalMap 是线程的一个属性，一个线程同一时刻只能对 ThreadLocalMap 进行操作，因为同一个线程执行业务逻辑必然是串行的，那么操作 ThreadLocalMap 必然也是串行的。</p>
</blockquote>
<p><strong>内存泄漏</strong></p>
<blockquote>
<p>ThreadLocalMap的每个Entry都是一个对key的弱引用，同时每个Entry都包含了一个对value的强引用。</p>
<ul>
<li>正常情况下，当线程终止，保存在ThreadLocal里的value会被垃圾回收，因为没有任何强引用了。</li>
</ul>
<p>但是，如果线程不终止（比如线程需要保持很久），那么key对应的value就不能被回收，因为有以下的调用链：<code>Thread ---&gt; ThreadLocalMap ---&gt; Entry(key为null) ---&gt; value</code></p>
<p>因为value和Thread之间还存在这个强引用链路，所以导致value无法回收，就可能会出现OOM。</p>
<p>JDK已经考虑到了这个问题，所以在set，remove，rehash方法中会扫描key为null的Entry，并把对应的value设置为null，这样value对象就可以被回收。</p>
</blockquote>
<p><strong>如何避免内存泄露</strong></p>
<p>调用remove方法，就会删除对应的Entry对象，可以避兔内存泄漏，所以使用完ThreadLocal之后，应该调用remove方法。</p>
<pre><code class="java">ThreadLocal&lt;String&gt; localName = new ThreadLocal();
try &#123;
    localName.set(&quot;月伴飞鱼&quot;);
    // 其它业务逻辑
&#125; finally &#123;
    localName.remove();
&#125;
</code></pre>
<p><strong>空指针问题</strong></p>
<p>ThreadLocal在进行get之前，必须先set，否则会报空指针异常。</p>
<pre><code class="java">public class ThreadLocalNPE &#123;
    ThreadLocal&lt;Long&gt; longThreadLocal = new ThreadLocal&lt;&gt;();
    public void set() &#123;
        longThreadLocal.set(Thread.currentThread().getId());
    &#125;
    //拆装箱问题
    public Long get() &#123;//long：NullPointerException
        Long res = longThreadLocal.get();
        return res;
    &#125;
 
    public static void main(String[] args) &#123;
        ThreadLocalNPE threadLocalNPE = new ThreadLocalNPE();
        System.out.println(threadLocalNPE.get());//NullPointerException
    &#125;
&#125;
</code></pre>
<blockquote>
<p>如果在每个线程中<code>ThreadLocal.set()</code>进去的东西本来就是多线程共享的同一个对象，比如static对象，那么多个线程的 <code>ThreadLocal.get()</code>取得的还是这个共享对象本身，还是有并发访问问题。</p>
</blockquote>
<p><strong>InheritableThreadLocal</strong></p>
<blockquote>
<p>InheritableThreadLocal解决父子线程变量传递的问题。</p>
<ul>
<li>如果我在后面改了父线程，子线程不会更新它的本地变量map。</li>
</ul>
</blockquote>
<p><strong>TransmittableThreadLocal</strong></p>
<blockquote>
<p>TransmittableThreadLocal解决线程池变量丢失问题。</p>
<ul>
<li>线程池会复用之前的线程，导致父线程的本地变量更新之后，之前创建的子线程拿不到这个值。</li>
</ul>
<p>TransmittableThreadLocal通过将线程封装成TtlRunnable，然后通过快照还有hold一个总收集变量来解决。</p>
</blockquote>
<h1 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h1><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap 底层的数据结构主要是：数组 + 链表 + 红黑树。</p>
<blockquote>
<p>其中当链表的长度大于等于 8 时，链表会转化成红黑树，当红黑树的大小小于等于 6 时，红黑树会转化成链表。</p>
</blockquote>
<img src="/images/format,png.png" alt="图片描述" style="zoom:50%;" />

<p><strong>常见属性</strong></p>
<pre><code class="java"> //初始容量为 16
 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;
 
 //最大容量
 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;
 
 //负载因子默认值
 static final float DEFAULT_LOAD_FACTOR = 0.75f;
 
 //桶上的链表长度大于等于8时，链表转化成红黑树
 static final int TREEIFY_THRESHOLD = 8;
 
 //桶上的红黑树大小小于等于6时，红黑树转化成链表
 static final int UNTREEIFY_THRESHOLD = 6;
 
 //当数组容量大于 64 时，链表才会转化成红黑树
 static final int MIN_TREEIFY_CAPACITY = 64;
 
 //记录迭代过程中 HashMap 结构是否发生变化，如果有变化，迭代时会 fail-fast
 transient int modCount;
 
 //HashMap 的实际大小，可能不准(因为当你拿到这个值的时候，可能又发生了变化)
 transient int size;
 
 //存放数据的数组
 transient Node&lt;K,V&gt;[] table;
 
 // 扩容的门槛，有两种情况
 // 如果初始化时，给定数组大小的话，通过 tableSizeFor 方法计算，数组大小永远接近于 2 的幂次方，比如你给定初始化大小 19，实际上初始化大小为 32，为 2 的 5 次方。
 // 如果是通过 resize 方法进行扩容，大小 = 数组容量 * 0.75
 int threshold;
 
 //链表的节点
 static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;
 
 //红黑树的节点
 static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;
</code></pre>
<p><strong>新增</strong></p>
<blockquote>
<p>1、空数组有无初始化，没有的话初始化。</p>
<p>2、如果通过 key 的 hash 能够直接找到值，跳转到 6，否则到 3。</p>
<p>3、如果 hash 冲突，两种解决方案：链表 or 红黑树。</p>
<p>4、如果是链表，递归循环，把新元素追加到队尾。</p>
<p>5、如果是红黑树，调用红黑树新增的方法。</p>
<p>6、通过 2、4、5 将新元素追加成功，再根据 onlyIfAbsent 判断是否需要覆盖。</p>
<p>7、判断是否需要扩容，需要扩容进行扩容，结束。</p>
</blockquote>
<img src="/images/format,png-20231016190034410.png" alt="图片描述" style="zoom:50%;" />

<pre><code class="java">// 入参 hash：通过 hash 算法计算出来的值。
// 入参 onlyIfAbsent：false 表示即使 key 已经存在了，仍然会用新值覆盖原来的值，默认为 false
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) &#123;
    // n 表示数组的长度，i 为数组索引下标，p 为 i 下标位置的 Node 值
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    //如果数组为空，使用 resize 方法初始化
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    // 如果当前索引位置是空的，直接生成新的节点在当前索引位置上
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    // 如果当前索引位置有值的处理方法，即我们常说的如何解决 hash 冲突
    else &#123;
        // e 当前节点的临时变量
        Node&lt;K,V&gt; e; K k;
        // 如果 key 的 hash 和值都相等，直接把当前下标位置的 Node 值赋值给临时变量
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            e = p;
        // 如果是红黑树，使用红黑树的方式新增
        else if (p instanceof TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        // 是个链表，把新节点放到链表的尾端
        else &#123;
            // 自旋
            for (int binCount = 0; ; ++binCount) &#123;
                // e = p.next 表示从头开始，遍历链表
                // p.next == null 表明 p 是链表的尾节点
                if ((e = p.next) == null) &#123;
                    // 把新节点放到链表的尾部 
                    p.next = newNode(hash, key, value, null);
                    // 当链表的长度大于等于 8 时，链表转红黑树
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1)
                        treeifyBin(tab, hash);
                    break;
                &#125;
                // 链表遍历过程中，发现有元素和新增的元素相等，结束循环
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    break;
                //更改循环的当前元素，使 p 在遍历过程中，一直往后移动。
                p = e;
            &#125;
        &#125;
        // 说明新节点的新增位置已经找到了
        if (e != null) &#123;
            V oldValue = e.value;
            // 当 onlyIfAbsent 为 false 时，才会覆盖值 
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            // 返回老值
            return oldValue;
        &#125;
    &#125;
    // 记录 HashMap 的数据结构发生了变化
    ++modCount;
    //如果 HashMap 的实际大小大于扩容的门槛，开始扩容
    if (++size &gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
&#125;
</code></pre>
<p><strong>链表的新增</strong></p>
<blockquote>
<p>当链表长度大于等于 8 时，此时的链表就会转化成红黑树，转化的方法是：treeifyBin，此方法有一个判断，当链表长度大于等于 8，并且整个数组大小大于 64 时，才会转成红黑树，当数组大小小于 64 时，只会触发扩容，不会转化成红黑树。</p>
<p>JDK1.7中链表插入采用的是头插法，JDK1.8中插入使用的是尾插法。</p>
<ul>
<li>头插法：<strong>扩容</strong>时，扩容的逻辑会导致节点互相引用，导致<strong>死循环</strong>。</li>
</ul>
</blockquote>
<p><strong>为什么是8？</strong></p>
<blockquote>
<p>链表查询的时间复杂度是 <code>O(n)</code>，红黑树的查询复杂度是 <code>O(log(n))</code>。</p>
<p>在链表数据不多的时候，使用链表进行遍历也比较快，只有当链表数据比较多的时候，才会转化成红黑树，但红黑树需要的占用空间是链表的 2 倍，考虑到转化时间和空间损耗。</p>
</blockquote>
<p>在考虑设计 8 这个值的时候，参考了泊松分布概率函数，由泊松分布中得出结论，链表各个长度的命中概率为：</p>
<pre><code>* 0:    0.60653066
* 1:    0.30326533
* 2:    0.07581633
* 3:    0.01263606
* 4:    0.00157952
* 5:    0.00015795
* 6:    0.00001316
* 7:    0.00000094
* 8:    0.00000006
</code></pre>
<blockquote>
<p>当链表的长度是 8 的时候，出现的概率是 0.00000006，不到千万分之一，所以说正常情况下，链表的长度不可能到达 8 ，而一旦到达 8 时，肯定是 hash 算法出了问题，所以在这种情况下，为了让 HashMap 仍然有较高的查询性能，所以让链表转化成红黑树。</p>
</blockquote>
<p><strong>红黑树新增节点过程</strong></p>
<blockquote>
<p>1、首先判断新增的节点在红黑树上是不是已经存在：</p>
<ul>
<li><p>如果节点没有实现 Comparable 接口，使用 equals 进行判断。</p>
</li>
<li><p>如果节点自己实现了 Comparable 接口，使用 compareTo 进行判断。</p>
</li>
</ul>
<p>2、新增的节点如果已经在红黑树上，直接返回；不在的话，判断新增节点是在当前节点的左边还是右边，左边值小，右边值大。</p>
<p>3、自旋递归 1 和 2 步，直到当前节点的左边或者右边的节点为空时，停止自旋，当前节点即为我们新增节点的父节点。</p>
<p>4、把新增节点放到当前节点的左边或右边为空的地方，并于当前节点建立父子节点关系。</p>
<p>5、进行着色和旋转，结束。</p>
</blockquote>
<p><strong>扩容机制</strong></p>
<blockquote>
<p>扩容阈值:</p>
<ul>
<li><code>阈值 = 容量 x 负载因子</code>，假设当前 <code>HashMap</code>的容量是 16，负载因子是默认值 0.75，当 size 到达 <code>16 x 0.75=</code> 12 的时候，就会触发扩容。</li>
</ul>
</blockquote>
<p><strong>查找</strong></p>
<blockquote>
<p>根据 hash 算法定位数组的索引位置，equals 判断当前节点是否是我们需要寻找的 key，是的话直接返回，不是的话往下。</p>
<p>判断当前节点有无 next 节点，有的话判断是链表类型，还是红黑树类型。</p>
<p>分别走链表和红黑树不同类型的查找方法。</p>
</blockquote>
<pre><code class="java">// 采用自旋方式从链表中查找 key，e 初始为为链表的头节点
do &#123;
    // 如果当前节点 hash 等于 key 的 hash，并且 equals 相等，当前节点就是我们要找的节点
    // 当 hash 冲突时，同一个 hash 值上是一个链表的时候，我们是通过 equals 方法来比较 key 是否相等的
    if (e.hash == hash &amp;&amp;
        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
        return e;
    // 否则，把当前节点的下一个节点拿出来继续寻找
&#125; while ((e = e.next) != null);
</code></pre>
<p><strong>HashMap为什么是线程不安全的</strong></p>
<blockquote>
<p>同时 put 碰撞导致数据丢失。</p>
<ul>
<li>多个线程同时使用 put 来添加元素，而且两个 put 的 key 是一样的，它们发生了碰撞，这样最终就只会保留一个数据。</li>
</ul>
<p>可见性问题无法保证。</p>
<ul>
<li>如果线程 1 给某个 key 放入了一个新值，那么线程 2 在获取对应的 key 的值的时候，它的可见性是无法保证的。</li>
</ul>
<p>死循环造成 CPU 100%：</p>
<ul>
<li>扩容的时候，会反转散列桶中的节点顺序，当有多个线程同时进行扩容的时候，如果两个线程同时反转的话，便可能形成一个循环。</li>
</ul>
</blockquote>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList整体架构是一个数组结构:</p>
<p><img src="/images/image-20231016184326651.png" alt="image-20231016184326651"></p>
<p>基本概念：</p>
<blockquote>
<p><code>DEFAULT_CAPACITY</code>：表示数组的初始大小，默认是 10。</p>
<p>size：表示当前数组的大小，类型是 int，没有使用 volatile 修饰，非线程安全。</p>
<p>modCount：统计当前数组被修改的版本次数，数组结构有变动，就会加 1。</p>
</blockquote>
<p><strong>初始化</strong></p>
<blockquote>
<p>ArrayList无参构造器初始化时，默认大小是空数组，并不是默认的<code>DEFAULT_CAPACITY</code> 10，10 是在第一次 add 时扩容的值。</p>
</blockquote>
<p><strong>新增</strong></p>
<blockquote>
<p>判断是否需要扩容，如果需要则执行扩容操作。</p>
<p>赋值新元素。</p>
</blockquote>
<pre><code class="java">public boolean add(E e) &#123;
    // 确保数组大小是否足够，不够则执行扩容，size 为当前数组的大小
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    // 直接赋值
    elementData[size++] = e;
    return true;
&#125;
</code></pre>
<pre><code class="java">private void ensureCapacityInternal(int minCapacity) &#123;
    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
&#125;

// 计算 capacity
private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;
    // 如果数组为空，则返回默认容量(10) 和最小容量(比如初始化 List add 一个 element 时 minCapacity 为 1)之间的 max 值
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;
        return Math.max(DEFAULT_CAPACITY, minCapacity);
    &#125;
    return minCapacity;
&#125;

// 确保容量足够
private void ensureExplicitCapacity(int minCapacity) &#123;
    // 记录数组被修改 
    modCount++;

    // 如果我们期望的最小容量大于目前数组的长度，则执行扩容操作
    // overflow-conscious code
    if (minCapacity - elementData.length &gt; 0)
        grow(minCapacity);
&#125;

// 扩容，并把现有数据拷贝到新的数组中去
private void grow(int minCapacity) &#123;
    // overflow-conscious code
    int oldCapacity = elementData.length;
    // 新的容量为旧的容量的 1.5 倍(capacity &gt;&gt; 1  ==&gt; capacity / 2)
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    // 如果新的容量小于我们期望值 minCapacity，则将新的容量值赋值为期望值
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    // 如果新的容量大于 JVM 所能分配的数组的最大值，那么就用 Integer 的最大值
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // 通过复制进行扩容
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
&#125;
</code></pre>
<blockquote>
<p>扩容的规则并不是翻倍，而是 原来容量大小 + 原来容量大小的一半（原来容量的 1.5 倍）。</p>
<p>ArrayList 中数组的最大容量是 <code>Integer.MAX_VALUE</code>，超过这个值，JVM 就不会给数组分配内存空间了。</p>
<p>新增时，并没有对值进行严格的校验，所以 ArrayList 是允许 null 值的。</p>
</blockquote>
<p><strong>扩容</strong></p>
<blockquote>
<p>扩容会先新建一个符合我们预期容量 <code>newCapacity</code> 的新数组，然后把旧数组的数据拷贝过去。</p>
</blockquote>
<pre><code class="java">public static int[] copyOf(int[] original, int newLength) &#123;
    int[] copy = new int[newLength];
    System.arraycopy(original, 0, copy, 0,
                     Math.min(original.length, newLength));
    return copy;
&#125;

public static native void arraycopy(Object src,  int  srcPos, Object dest, int destPos, int length);
</code></pre>
<p><strong>线程安全</strong></p>
<blockquote>
<p>只有当 <code>ArrayList</code> 作为共享变量时，才会有线程安全问题，当 <code>ArrayList</code> 是方法内部局部变量时，是没有线程安全问题的。</p>
<p>本质是因为 ArrayList 自身的 elementData、size、modCount 在进行各种操作时，都没有加锁，而且这些变量的类型并非是可见的(volatile)的，所以如果多个线程对这些变量进行操作时，可能会有值被覆盖的情况。</p>
</blockquote>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>LinkedList 适用于要求有顺序、并且会按照顺序进行迭代的场景，底层数据结构是一个双向链表:</p>
<img src="/images/image-20231015001829797.png" alt="image-20231015001829797" style="zoom:30%;" />

<blockquote>
<p>链表每个节点我们叫做 Node，Node 有 prev 属性，代表前一个节点的位置，next 属性，代表后一个节点的位置。</p>
<p>first 是双向链表的头节点，它的前一个节点是 null。</p>
<p>last 是双向链表的尾节点，它的后一个节点是 null。</p>
<p>当链表中没有数据时，first 和 last 是同一个节点，前后指向都是 null。</p>
<p>因为是个双向链表，只要机器内存足够强大，是没有大小限制的。</p>
</blockquote>
<pre><code class="java">    transient Node&lt;E&gt; first;//第一个节点
    transient Node&lt;E&gt; last;//最后一个节点
</code></pre>
<pre><code class="java">private static class Node&lt;E&gt; &#123;
    E item;// 节点值
    Node&lt;E&gt; next; // 指向的下一个节点
    Node&lt;E&gt; prev; // 指向的前一个节点

    // 初始化参数顺序分别是：前一个节点、本身节点值、后一个节点
    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;
        this.item = element;
        this.next = next;
        this.prev = prev;
    &#125;
&#125;
</code></pre>
<p><strong>追加（新增）</strong></p>
<blockquote>
<p>追加节点时，add 方法默认是从尾部开始追加，addFirst 方法是从头部开始追加。</p>
<p>尾部追加节点比较简单，只需要简单地把指向位置修改下即可。</p>
</blockquote>
<pre><code class="java">// 从尾部开始追加节点
public void addLast(E e) &#123;
        linkLast(e);
    &#125;
void linkLast(E e) &#123;
    // 把尾节点数据暂存
    final Node&lt;E&gt; l = last;
    // 新建新的节点，初始化入参含义：
    // l 是新节点的前一个节点，当前值是尾节点值
    // e 表示当前新增节点，当前新增节点后一个节点是 null
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);
    // 新建节点追加到尾部
    last = newNode;
    //如果链表为空（l 是尾节点，尾节点为空，链表即空），头部和尾部是同一个节点，都是新建的节点
    if (l == null)
        first = newNode;
    //否则把前尾节点的下一个节点，指向当前尾节点。
    else
        l.next = newNode;
    //大小和版本更改
    size++;
    modCount++;
&#125;
</code></pre>
<p><strong>节点删除</strong></p>
<blockquote>
<p>节点删除的方式和追加类似，可以选择从头部删除，也可以选择从尾部删除，删除操作会把节点的值，前后指向节点都置为 null，帮助 GC 进行回收。</p>
<p><strong>链表结构的节点新增、删除都非常简单，仅仅把前后节点的指向修改下就好了，所以 LinkedList 新增和删除速度很快。</strong></p>
</blockquote>
<pre><code class="java">public E removeFirst() &#123;
    final Node&lt;E&gt; f = first;
    if (f == null)
        throw new NoSuchElementException();
    return unlinkFirst(f);
&#125;
//从头删除节点 f 是链表头节点
private E unlinkFirst(Node&lt;E&gt; f) &#123;
    // 拿出头节点的值，作为方法的返回值
    final E element = f.item;
    // 拿出头节点的下一个节点
    final Node&lt;E&gt; next = f.next;
    //帮助 GC 回收头节点
    f.item = null;
    f.next = null;
    // 头节点的下一个节点成为头节点
    first = next;
    //如果 next 为空，表明链表为空
    if (next == null)
        last = null;
    //链表不为空，头节点的前一个节点指向 null
    else
        next.prev = null;
    //修改链表大小和版本
    size--;
    modCount++;
    return element;
&#125;
</code></pre>
<p><strong>节点查询</strong></p>
<p>链表查询某一个节点是比较慢的，需要挨个循环查找。</p>
<blockquote>
<p>LinkedList 并没有采用从头循环到尾的做法，而是采取了<strong>简单二分法</strong>，首先看看 index 是在链表的前半部分，还是后半部分。</p>
<p>如果是前半部分，就从头开始寻找，反之亦然。通过这种方式，使循环的次数至少降低了一半，提高了查找的性能。</p>
</blockquote>
<pre><code class="java">// 根据链表索引位置查询节点
Node&lt;E&gt; node(int index) &#123;
    // 如果 index 处于队列的前半部分，从头开始找，size &gt;&gt; 1 是 size 除以 2 的意思。
    if (index &lt; (size &gt;&gt; 1)) &#123;
        Node&lt;E&gt; x = first;
        // 直到 for 循环到 index 的前一个 node 停止
        for (int i = 0; i &lt; index; i++)
            x = x.next;
        return x;
    &#125; else &#123;// 如果 index 处于队列的后半部分，从尾开始找
        Node&lt;E&gt; x = last;
        // 直到 for 循环到 index 的后一个 node 停止
        for (int i = size - 1; i &gt; index; i--)
            x = x.prev;
        return x;
    &#125;
&#125;
</code></pre>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><blockquote>
<p>HashSet原理：使用的就是组合 HashMap。</p>
<ul>
<li>把 HashMap 当作自己的一个局部变量。</li>
</ul>
</blockquote>
<pre><code class="java">// 把 HashMap 组合进来，key 是 Hashset 的 key，value 是下面的 PRESENT
private transient HashMap&lt;E,Object&gt; map;
// HashMap 中的 value
private static final Object PRESENT = new Object();
</code></pre>
<blockquote>
<p>1、在使用 HashSet 时，比如 add 方法，只有一个入参，但组合的 Map 的 add 方法却有 key，value 两个入参，相对应上 Map 的 key 就是我们 add 的入参，value 就是第二行代码中的 PRESENT，用一个默认值 PRESENT 来代替 Map 的 Value；</p>
<p>2、如果 HashSet 是被共享的，当多个线程访问的时候，就会有线程安全问题，因为在后续的所有操作中，并没有加锁。</p>
</blockquote>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><blockquote>
<p>TreeSet底层组合的是 TreeMap，所以继承了 TreeMap key 能够排序的功能，迭代的时候，也可以按照 key 的排序顺序进行迭代。</p>
</blockquote>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><blockquote>
<p>TreeMap 底层的数据结构就是红黑树，和 HashMap 的红黑树结构一样。</p>
<p>不同的是：TreeMap 利用了红黑树左节点小，右节点大的性质，根据 key 进行排序，使每个元素能够插入到红黑树大小适当的位置，维护了 key 的大小关系，适用于 key 需要排序的场景。</p>
<p>因为底层使用的是平衡红黑树的结构，所以 containsKey、get、put、remove 等方法的时间复杂度都是 <code>log(n)</code>。</p>
</blockquote>
<p>TreeMap 常见的属性有：</p>
<pre><code class="java">//比较器，如果外部有传进来 Comparator 比较器，首先用外部的
//如果外部比较器为空，则使用 key 自己实现的 Comparable#compareTo 方法
//比较手段和上面日常工作中的比较 demo 是一致的
private final Comparator&lt;? super K&gt; comparator;
 
//红黑树的根节点
private transient Entry&lt;K,V&gt; root;
 
//红黑树的已有元素大小
private transient int size = 0;
 
//树结构变化的版本号，用于迭代过程中的快速失败场景
private transient int modCount = 0;
 
//红黑树的节点
static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;&#125;
</code></pre>
<p><strong>新增节点</strong></p>
<blockquote>
<p>判断红黑树的节点是否为空，为空的话，新增的节点直接作为根节点：</p>
</blockquote>
<pre><code class="java">Entry&lt;K,V&gt; t = root;
//红黑树根节点为空，直接新建
if (t == null) &#123;
    // compare 方法限制了 key 不能为 null
    compare(key, key); // type (and possibly null) check
    // 成为根节点
    root = new Entry&lt;&gt;(key, value, null);
    size = 1;
    modCount++;
    return null;
&#125;
</code></pre>
<blockquote>
<p>根据红黑树左小右大的特性，进行判断，找到应该新增节点的父节点：</p>
</blockquote>
<pre><code class="kotlin">Comparator&lt;? super K&gt; cpr = comparator;
if (cpr != null) &#123;
    //自旋找到 key 应该新增的位置，就是应该挂载那个节点的头上
    do &#123;
        //一次循环结束时，parent 就是上次比过的对象
        parent = t;
        // 通过 compare 来比较 key 的大小
        cmp = cpr.compare(key, t.key);
        //key 小于 t，把 t 左边的值赋予 t，因为红黑树左边的值比较小，循环再比
        if (cmp &lt; 0)
            t = t.left;
        //key 大于 t，把 t 右边的值赋予 t，因为红黑树右边的值比较大，循环再比
        else if (cmp &gt; 0)
            t = t.right;
        //如果相等的话，直接覆盖原值
        else
            return t.setValue(value);
        // t 为空，说明已经到叶子节点了
    &#125; while (t != null);
&#125;
</code></pre>
<blockquote>
<p>在父节点的左边或右边插入新增节点：</p>
</blockquote>
<pre><code class="java">//cmp 代表最后一次对比的大小，小于 0 ，代表 e 在上一节点的左边
if (cmp &lt; 0)
    parent.left = e;
//cmp 代表最后一次对比的大小，大于 0 ，代表 e 在上一节点的右边，相等的情况第二步已经处理了。
else
    parent.right = e;
</code></pre>
<blockquote>
<p>1、着色旋转，达到平衡，结束。</p>
<p>2、新增节点时，就是利用了红黑树左小右大的特性，从根节点不断往下查找，直到找到节点是 null 为止，节点为 null 说明到达了叶子结点。</p>
<p>3、查找过程中，发现 key 值已经存在，直接覆盖。</p>
<p>4、TreeMap 是禁止 key 是 null 值的。</p>
</blockquote>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><blockquote>
<p>LinkedHashMap 是继承 HashMap 的，所以它拥有 HashMap 的所有特性，再此基础上，还提供了两大特性：</p>
<ul>
<li>按照插入顺序进行访问。</li>
<li>实现了访问最少最先删除功能，其目的是把很久都没有访问的 key 自动删除。</li>
</ul>
</blockquote>
<p><strong>LinkedHashMap链表结构</strong></p>
<pre><code class="java">// 链表头
transient LinkedHashMap.Entry&lt;K,V&gt; head;
 
// 链表尾
transient LinkedHashMap.Entry&lt;K,V&gt; tail;
 
// 继承 Node，为数组的每个元素增加了 before 和 after 属性
static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;
    Entry&lt;K,V&gt; before, after;
    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;
        super(hash, key, value, next);
    &#125;
&#125;
 
// 控制两种访问模式的字段，默认 false
// true 按照访问顺序，会把经常访问的 key 放到队尾
// false 按照插入顺序提供访问
final boolean accessOrder;
</code></pre>
<blockquote>
<p>LinkedHashMap 的数据结构很像是把 LinkedList 的每个元素换成了 HashMap 的 Node，像是两者的结合体，也正是因为增加了这些结构，从而能把 Map 的元素都串联起来，形成一个链表，而链表就可以保证顺序了，就可以维护元素插入进来的顺序。</p>
</blockquote>
<p><strong>如何按照顺序新增</strong></p>
<blockquote>
<p>LinkedHashMap 初始化时，默认 accessOrder 为 false，就是会按照插入顺序提供访问，插入方法使用的是父类 HashMap 的 put 方法，不过覆写了 put 方法执行中调用的 newNode&#x2F;newTreeNode 和 afterNodeAccess 方法。</p>
</blockquote>
<blockquote>
<p>newNode&#x2F;newTreeNode 方法，控制新增节点追加到链表的尾部，这样每次新节点都追加到尾部，即可保证插入顺序了。</p>
</blockquote>
<pre><code class="java">// 新增节点，并追加到链表的尾部
Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123;
    // 新增节点
    LinkedHashMap.Entry&lt;K,V&gt; p =
        new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);
    // 追加到链表的尾部
    linkNodeLast(p);
    return p;
&#125;
// link at the end of list
private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123;
    LinkedHashMap.Entry&lt;K,V&gt; last = tail;
    // 新增节点等于位节点
    tail = p;
    // last 为空，说明链表为空，首尾节点相等
    if (last == null)
        head = p;
    // 链表有数据，直接建立新增节点和上个尾节点之间的前后关系即可
    else &#123;
        p.before = last;
        last.after = p;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>LinkedHashMap 通过新增头节点、尾节点，给每个节点增加 before、after 属性，每次新增时，都把节点追加到尾节点等手段，在新增的时候，就已经维护了按照插入顺序的链表结构了。</p>
</blockquote>
<h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><p><strong>同步阻塞</strong></p>
<blockquote>
<p>用户空间的应用程序执行一个系统调用，这会导致应用程序阻塞，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据，在等待数据到处理数据的两个阶段，整个进程都被阻塞，不能处理别的网络IO。</p>
</blockquote>
<img src="/images/640-8212892.png" alt="图片" style="zoom:80%;" />

<p><strong>同步非阻塞</strong></p>
<p>非阻塞的系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。</p>
<blockquote>
<p>进程在返回之后，可以干点别的事情，然后再发起系统调用。</p>
<p>重复上面的过程，循环往复的进行系统调用，这个过程通常被称之为轮询。</p>
<p>轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。</p>
<p>需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。</p>
</blockquote>
<img src="/images/640-20231025134847570.png" alt="图片" style="zoom:80%;" />

<p><strong>IO多路复用</strong></p>
<blockquote>
<p>IO多路复用，这是一种进程预先告知内核的能力，让内核发现进程指定的一个或多个IO条件就绪了，就通知进程。</p>
<p>IO复用的实现方式目前主要有Select、Poll和Epoll。</p>
</blockquote>
<img src="/images/640-20231025134928516.png" alt="图片" style="zoom:80%;" />

<p><strong>信号驱动</strong></p>
<blockquote>
<p>首先允许Socket进行信号驱动IO，并安装一个信号处理函数，进程继续运行并不阻塞。</p>
<p>当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I&#x2F;O操作函数处理数据。</p>
<p>此种IO方式存在的一个很大的问题：</p>
<ul>
<li>Linux中信号队列是有限制的，如果超过这个数字问题就无法读取数据。</li>
</ul>
</blockquote>
<img src="/images/640-20231025134954345.png" alt="图片" style="zoom:80%;" />

<p><strong>异步非阻塞</strong></p>
<blockquote>
<p>当用户线程进行了系统调用，立刻就可以开始去做其它的事，用户线程不阻塞。</p>
<ul>
<li>准备数据：当内核一直等到数据准备好了，它就会将数据从内核内核缓冲区，拷贝到用户缓冲区。</li>
</ul>
<ul>
<li>内核会给用户线程发送一个信号，或者回调用户线程注册的回调接口，告诉用户线程操作完成了。</li>
<li>用户线程读取用户缓冲区的数据，完成后续的业务操作。</li>
</ul>
<p>信号驱动IO，异步IO的主要区别在于：</p>
<ul>
<li>信号驱动由内核告诉我们何时可以开始一个IO操作(数据在内核缓冲区中)。</li>
<li>而异步IO则由内核通知IO操作何时已经完成(数据已经在用户空间中)。</li>
</ul>
</blockquote>
<img src="/images/640-20231025135037054.png" alt="图片" style="zoom:80%;" />

<p><strong>BIO，NIO，AIO的区别：</strong></p>
<blockquote>
<p>BIO：</p>
<ul>
<li>同步并阻塞，服务实现模式为一个连接对应一个线程，即客户端发送一个连接，服务端要有一个线程来处理。</li>
<li>如果连接多了，线程数量不够，就只能等待，即会发生阻塞。</li>
<li>适用连接数目比较小且固定的架构。</li>
</ul>
<p>NIO：</p>
<ul>
<li>同步非阻塞，服务实现模式是一个线程可以处理多个连接，即客户端发送的连接都会注册到多路复用器上，然后进行轮询连接，有I&#x2F;O请求就处理。</li>
<li>适用连接数目多且连接比较短的架构，如：聊天服务器，弹幕系统等，编程比较复杂。</li>
</ul>
<p>AIO：</p>
<ul>
<li>异步非阻塞，引入了异步通道，采用的是Proactor模式。</li>
<li>适用连接数目多且连接长的架构，如相册服务器。</li>
</ul>
</blockquote>
<h1 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h1><p><strong>JDK 17</strong></p>
<p>Sealed类：</p>
<blockquote>
<p>Sealed类是一种新的类修饰符，用于限制类的继承。</p>
<p>Sealed类可以控制哪些类可以继承自它，这样可以使得代码更加安全、可维护。</p>
</blockquote>
<p>Pattern Matching for Switch：</p>
<blockquote>
<p>新的Switch语法，可以用于模式匹配。</p>
<p>可以根据不同的模式执行不同的操作，从而使得代码更加简洁、易读、易维护。</p>
<p>可以减少代码量，避免出现大量的if-else语句。</p>
</blockquote>
<p>改进的垃圾回收器（ZGC（新型垃圾收集器）):</p>
<blockquote>
<p>改进了垃圾回收器，提高了垃圾回收的效率和吞吐量。</p>
<p>改进的垃圾回收器可以更加高效地回收内存，从而提高应用程序的性能和响应速度。</p>
</blockquote>
<p>风格的内存管理:</p>
<blockquote>
<p>引入了C++风格的内存管理，包括对堆内存分配的优化和对垃圾回收的改进。</p>
<p>C++风格的内存管理可以使得Java应用程序更加高效，从而提高应用程序的性能和响应速度。</p>
</blockquote>
<p><strong>JDK21</strong></p>
<p>序列化集合接口:</p>
<blockquote>
<p>新增序列集合接口 <code>SequencedCollection</code>，常用的 <code>ArrayList</code>、<code>LinkedList</code>等都实现了这个接口。</p>
</blockquote>
<p>ZGC增加分代:</p>
<blockquote>
<p>增加了分代功能，比如 <code>CMS</code> 收集器区分老年代和年轻代，这样一来，可以更频繁的回收年轻代。</p>
</blockquote>
<p>虚拟线程（协程）:</p>
<blockquote>
<p>虚拟线程可以看作是一种用户级线程，与操作系统的线程或进程不同，它是由编程语言或库提供的，而不是由操作系统管理的。</p>
</blockquote>

	</div>
</div>


    <div class="post-guide">
        <div class="item left">
            
              <a href="/2022/11/25/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  面试算法
              </a>
            
        </div>
        <div class="item right">
            
        </div>
    </div>




<script>

    //document.oncontextmenu=new Function("event.returnValue=false");
	//document.onselectstart=new Function("event.returnValue=false");

	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "https://hm.baidu.com/hm.js?7eeb54583579fabc0878be210d6ad60a";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();

	

	$(function () {
		const btw = new BTWPlugin();
	    btw.init({
	        id: 'container',
	        blogId: '22377-1702604613173-587',
	        name: '月伴飞鱼',
	        qrcode: '/小程序码.jpg',
	        keyword: '验证码',
	        btnText: '为防止机器刷接口，需要完成人机检测',
        	cookieAge: 1
	    });

	    var contents = document.getElementsByClassName("content999");
	    //监听文章内容的copy事件
	    contents[0].addEventListener('copy',function(e){
	        setClipboardText(e);
	    });

	    function setClipboardText(event){
	        // clipboardData 对象是为通过编辑菜单、快捷菜单和快捷键执行的编辑操作所保留的，也就是你复制或者剪切内容
	        let clipboardData = event.clipboardData || window.clipboardData;

	        // 如果未复制或者未剪切，则return出去
	        if (!clipboardData) { return; }

	        event.preventDefault();

	        // Selection 对象，表示用户选择的文本范围或光标的当前位置。
	        // 声明一个变量接收 -- 用户输入的剪切或者复制的文本转化为字符串
	        let text = window.getSelection().toString();
	    
	        if (text) {
	            // 如果文本存在则先取消文本默认事件
	            event.preventDefault();
	            // 通过调用常clipboardData对象的 setData(format, data) 方法；来设置相关文本
	            // format: 一个DOMString 表示要添加到 drag object的拖动数据的类型。
	            // data: 一个 DOMString表示要添加到 drag object的数据。
	            var copyright = '\n\n'
	            + '\n著作权归作者所有。'
	            + '\n商业转载请联系作者获得授权，非商业转载请注明出处。'
	            + '\n作者: 月伴飞鱼'
	            + '\n原文地址: http://hardyfish.top/2022/11/21/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E5%9F%BA%E7%A1%80/'
	    
	            clipboardData.setData('text/plain', text + copyright);
	    
	        }
	    };
	});

	
</script>

<script>
    const btw = new BTWPlugin();
    btw.init({
        id: 'container',
        blogId: '22377-1702604613173-587',
        name: '月伴飞鱼',
        qrcode: '/小程序码.jpg',
        keyword: '验证码',
        btnText: '为防止机器刷接口，需要完成人机检测',
        cookieAge: 1
    });

	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "https://hm.baidu.com/hm.js?7eeb54583579fabc0878be210d6ad60a";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
</script>
	</div>
	<div id="footer">
	<p>
	©2019-<span id="footerYear"></span> 
	<a href="/">月伴飞鱼</a> 
	
	
		|
		<span id="busuanzi_container_site_pv">
			PV 180986
		</span>
		|
		<span id="busuanzi_container_site_uv"> 
			UV 10079
		</span>
	
	<br>
	微信搜索 <a href="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/个人公众号.jpg" target="_blank">月伴飞鱼</a> 关注我
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>
	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>