<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		Redis | 
	 
	月伴飞鱼
	</title>
	
	<!-- keywords,description -->
	 

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/%E5%A4%B4%E5%83%8F.jpg">
	
  
  	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="/css/jquery.fancybox.min.css">

	
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="/lib/highlight/darcula.css">

	
<link rel="stylesheet" href="/css/clipboard-use.css">


	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">

	
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>


	
<script src="/lib/highlight/highlight.min.js"></script>

	
<script src="https://readmore.openwrite.cn/js/readmore.js"></script>

	
<script src="/lib/jquery-3.4.1.min.js"></script>

	
<script src="/lib/jquery.pjax.js"></script>


	
<script src="/js/main.js"></script>

	
<script src="/js/jquery.fancybox.min.js"></script>

	
		
<script src="/lib/valine/av-3.0.4-min.js"></script>

		
<script src="/lib/valine/Valine-1.3.10-min.js"></script>

	
	
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
	
<script src="/js/clipboard.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body oncontextmenu="return false;">
	<header id="header">
    <a id="title" href="/" class="logo">公众号月伴飞鱼</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">关于我</a>
		</li>

	    <li class="menu-item">
			<a href="/site" class="menu-item-link">关于网站</a>
		</li>

		<li class="menu-item">
			<a href="/个人公众号.jpg" class="menu-item-link" target="_blank">我的公众号</a>
		</li>
		
		<li class="menu-item">
			<a href="https://tech.meituan.com/" class="menu-item-link" target="_blank">
				美团技术团队
			</a>
		</li>
		<li class="menu-item">
			<a href="https://tech.youzan.com/" class="menu-item-link" target="_blank">
				有赞技术团队
			</a>
		</li>
		<!--<li class="menu-item">
			<select class="menu-item-link menu-item-select">
				<option class="menu-item-link"  value="volvo">Volvo</option>
				<option class="menu-item-link"  value="saab">Saab</option>
				<option class="menu-item-link"  value="fiat">Fiat</option>
				<option class="menu-item-link"  value="audi">Audi</option>
			</select>
		</li>-->
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="text" placeholder="按目录搜索一下">
		<div id="tree">
			

			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										中间件
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/12/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/Elasticsearch/">
										Elasticsearch
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/ZooKeeper/">
										ZooKeeper
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										前端相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/CSS/">
										CSS
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/Vue/">
										Vue
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/12/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">
										小程序
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										基础知识
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/11/27/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM/">
										JVM
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/11/21/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E5%9F%BA%E7%A1%80/">
										Java基础
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F/">
										分布式
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/12/10/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">
										并发编程
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
										设计模式
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										娱乐相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/27/%E5%A8%B1%E4%B9%90%E7%9B%B8%E5%85%B3/%E4%B9%A6%E7%B1%8D/">
										书籍
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/10/%E5%A8%B1%E4%B9%90%E7%9B%B8%E5%85%B3/%E7%94%B5%E5%BD%B1/">
										电影
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/09/%E5%A8%B1%E4%B9%90%E7%9B%B8%E5%85%B3/%E9%9F%B3%E4%B9%90/">
										音乐
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										学习专栏
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/26/%E5%AD%A6%E4%B9%A0%E4%B8%93%E6%A0%8F/%E5%A4%A7%E5%8E%82%E6%99%8B%E5%8D%87%E6%8C%87%E5%8D%97/">
										大厂晋升指南
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										工具相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/">
										实用工具
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">
										开发工具
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										数据库
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/27/%E6%95%B0%E6%8D%AE%E5%BA%93/HBase/">
										HBase
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/12/02/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">
										MySQL
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file active">
									<a href="/2023/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/">
										Redis
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										服务器
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E6%9C%8D%E5%8A%A1%E5%99%A8/Docker/">
										Docker
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/09/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/">
										Nginx
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/09/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E8%BF%90%E7%BB%B4%E7%9F%A5%E8%AF%86/">
										运维知识
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										架构相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/21/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/DDD/">
										DDD
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/26/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/%E7%B3%BB%E7%BB%9F%E4%BF%9D%E9%9A%9C/">
										系统保障
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/26/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">
										系统设计
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										框架相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/08/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/MyBatis/">
										MyBatis
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/14/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/Spring/">
										Spring
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/10/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/">
										开源框架
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										消息队列
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/KAFKA/">
										KAFKA
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/">
										RocketMQ
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										算法相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/11/26/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/LeetCode/">
										LeetCode
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/11/26/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E5%89%91%E6%8C%87OFFER/">
										剑指OFFER
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/11/25/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/">
										面试算法
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										英语相关
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										老友记
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/08/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E8%80%81%E5%8F%8B%E8%AE%B0/%E7%AC%AC%E4%B8%80%E5%AD%A3/">
										第一季
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/08/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E8%80%81%E5%8F%8B%E8%AE%B0/%E7%AC%AC%E4%B8%89%E5%AD%A3/">
										第三季
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										雅思
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/12/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E9%9B%85%E6%80%9D/%E5%89%91%E6%A1%A5%E9%9B%85%E6%80%9D%E5%90%AC%E5%8A%9B%E7%9C%9F%E9%A2%98/">
										剑桥雅思听力真题
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										计算机基础
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
										操作系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
										数据结构
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/">
										算法知识
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/12/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">
										网络基础
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">

	Redis
</h1>
<div class="article-meta">
	<span>月伴飞鱼</span>
	<span>2023-10-21 17:13:49</span>
    
		<div id="article-categories">
            
                
                    <span>
                        <i class="fa fa-folder" aria-hidden="true"></i>
                        <a href="/categories/数据库/">数据库</a>
						
                    </span>
                
            
		</div>
    
</div>

<div id="container" class = "content999" oncontextmenu="return false;">
	<div id="article-content">
		<p><strong>Redis为什么那么快？</strong></p>
<p>基于内存实现：</p>
<blockquote>
<p>Redis 将数据存储在内存中，读写操作不会受到磁盘的 IO 速度限制，所以Redis的读写速度会非常的快。</p>
<p>CPU 不是 Redis 的瓶颈，Redis 的瓶颈是<strong>机器内存的大小或者网络带宽</strong>。</p>
</blockquote>
<p>使用I&#x2F;O多路复用模型：</p>
<blockquote>
<p>Redis 线程不会阻塞在某一个特定的客户端请求处理上。</p>
<ul>
<li>可以同时和多个客户端连接并处理请求，从而提升了并发性。</li>
</ul>
</blockquote>
<p>采用单线程模型：</p>
<blockquote>
<p>Redis 的网络 IO 以及键值对指令读写是由一个线程来执行的。 </p>
<ul>
<li>对于 Redis 的持久化、集群数据同步、异步删除等都是其他线程执行。</li>
</ul>
<p><strong>单线程</strong> 避免了 <strong>线程切换</strong> 和 <strong>竞态</strong> 产生的消耗，对于服务端开发来说，<strong>锁和线程切换</strong> 通常是性能杀手。</p>
</blockquote>
<p>高效的数据结构：</p>
<blockquote>
<p>为了追求速度，不同数据类型使用不同的数据结构速度才得以提升。</p>
</blockquote>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>一个单机的 Redis 服务器默认情况下有 16 个数据库（0-15 号）。</p>
<ul>
<li>默认使用的是 0 号数据库，可以使用 <code>SELECT</code> 命令切换数据库。</li>
</ul>
<blockquote>
<p>每个数据库都由一个 <code>redis.h/redisDb</code> 结构表示:</p>
<ul>
<li>它记录了单个 Redis 数据库的键空间、所有键的过期时间、处于阻塞状态和就绪状态的键、数据库编号等。</li>
</ul>
<p>dict:</p>
<ul>
<li>一个记录键值对数据的字典。</li>
<li>键是一个字符串对象，值是字符串、列表、哈希表、集合和有序集合在内的任意一种 Redis 类型对象。</li>
</ul>
<p>expires:</p>
<ul>
<li>一个用于记录键的过期时间的字典。</li>
<li>键为 dict 中的数据库键，值为这个数据库键的过期时间戳，这个值以 long long 类型表示。</li>
</ul>
</blockquote>
<pre><code class="c">typedef struct redisDb &#123;
    // 数据库键空间，保存着数据库中的所有键值对
    dict *dict;
    // 键的过期时间，字典的键为键，字典的值为过期事件 UNIX 时间戳
    dict *expires;
    // 正处于阻塞状态的键
    dict *blocking_keys;
    // 可以解除阻塞的键
    dict *ready_keys;
    // 正在被 WATCH 命令监视的键
    dict *watched_keys;
    struct evictionPoolEntry *eviction_pool;
    // 数据库编号
    int id;
    // 数据库的键的平均 TTL，统计信息
    long long avg_ttl;
&#125; redisDb;
</code></pre>
<p><strong>数据类型</strong></p>
<blockquote>
<p><code>string</code>（<strong>字符串</strong>）、<code>hash</code>（<strong>哈希</strong>）、<code>list</code>（<strong>列表</strong>）、<code>set</code>（<strong>集合</strong>）、<code>zset</code>（<strong>有序集合</strong>）</p>
</blockquote>
<img src="/images/165f79470dff7693~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="img" style="zoom:50%;" />

<p><strong>查询键的数据类型</strong></p>
<blockquote>
<p>type key:</p>
<ul>
<li><p>例如键 <code>hello</code>  <strong>字符串类型</strong>，返回: <code>string</code>。</p>
</li>
<li><p>键 <code>mylist</code>  <strong>列表类型</strong>，返回: <code>list</code>。</p>
</li>
<li><p>如果键不存在，则返回 <code>none</code>。</p>
</li>
</ul>
</blockquote>
<pre><code class="java">127.0.0.1:6379&gt; set a b
OK
127.0.0.1:6379&gt; type a
string
127.0.0.1:6379&gt; rpush mylist a b c d e f g
(integer) 7
127.0.0.1:6379&gt; type mylist
list
</code></pre>
<p><strong>内部编码</strong></p>
<blockquote>
<p>对于每种 <strong>数据类型</strong>，实际上都有自己底层的 <strong>内部编码</strong> 实现，而且是 <strong>多种实现</strong>。</p>
<p>这样 <code>Redis</code> 会在合适的 <strong>场景</strong> 选择合适的 <strong>内部编码</strong>。</p>
</blockquote>
<img src="/images/165f79470e44f30b~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="img" style="zoom:50%;" />

<p>通过 <code>object encoding</code> 命令查询 <strong>内部编码</strong>：</p>
<pre><code class="java">127.0.0.1:6379&gt; object encoding hello
&quot;embstr&quot;
127.0.0.1:6379&gt; object encoding mylist
&quot;quicklist&quot;
</code></pre>
<p><strong>哈希</strong></p>
<blockquote>
<p><strong>哈希类型</strong> 的 <strong>内部编码</strong> 有两种。</p>
<p>ziplist（压缩列表）:</p>
<ul>
<li>当 <strong>哈希类型</strong> 元素个数 <strong>小于</strong> <code>hash-max-ziplist-entries</code> 配置，同时 <strong>所有值</strong> 都 <strong>小于</strong> <code>hash-max-ziplist-value</code> 配置时使用。</li>
<li><code>ziplist</code> 使用更加 <strong>紧凑的结构</strong> 实现多个元素的 <strong>连续存储</strong>，在 <strong>节省内存</strong> 方面比 <code>hashtable</code> 更加优秀。</li>
</ul>
<p>hashtable（哈希表）：</p>
<ul>
<li>当 <strong>哈希类型</strong> 无法满足 <code>ziplist</code> 的条件时，<code>Redis</code> 会使用 <code>hashtable</code> 作为 <strong>哈希</strong> 的 <strong>内部实现</strong>。</li>
<li>因为此时 <code>ziplist</code> 的 <strong>读写效率</strong> 会下降，而 <code>hashtable</code> 的读写 <strong>时间复杂度</strong> 为 <code>O（1）</code>。</li>
</ul>
</blockquote>
<p><strong>列表</strong></p>
<blockquote>
<p>列表类型的 <strong>内部编码</strong> 有两种。</p>
<p>ziplist（压缩列表）:</p>
<ul>
<li>当列表的元素个数 <strong>小于</strong> <code>list-max-ziplist-entries</code> 配置，同时列表中 <strong>每个元素</strong> 的值都 <strong>小于</strong>  <code>list-max-ziplist-value</code> 配置时使用。</li>
</ul>
<p>linkedlist（链表）：</p>
<ul>
<li>当 <strong>列表类型</strong> 无法满足 <code>ziplist</code> 的条件时， <code>Redis</code>会使用<code>linkedlist</code>作为 <strong>列表</strong> 的 <strong>内部实现</strong>。</li>
</ul>
</blockquote>
<p><strong>集合</strong></p>
<blockquote>
<p><strong>集合类型</strong> 的 <strong>内部编码</strong> 有两种。</p>
<p>intset（整数集合）：</p>
<ul>
<li>当集合中的元素都是 <strong>整数</strong> 且 <strong>元素个数</strong> 小于 <code>set-max-intset-entries</code> 配置时使用。</li>
</ul>
<p>hashtable（哈希表）：</p>
<ul>
<li>当集合类型 <strong>无法满足</strong> <code>intset</code> 的条件时，<code>Redis</code>会使用<code>hashtable</code>作为集合的 <strong>内部实现</strong>。</li>
</ul>
</blockquote>
<p><strong>Pipeline</strong></p>
<blockquote>
<p>通过将一批命令进行打包，然后发送给服务器，服务器执行完按顺序打包返回，这样就减少了频繁交互往返的时间，提升了性能。</p>
<ul>
<li>客户端将执行的命令写入到缓冲区（内存）中，最后再一次性发送 Redis。</li>
</ul>
</blockquote>
<p>Pipeline的优点：</p>
<blockquote>
<p>通过打包命令，一次性执行，可以节省连接-&gt;发送命令-&gt;返回结果这个过程所产生的往返时间，减少的I&#x2F;O的调用（用户态到内核态之间的切换）次数。</p>
</blockquote>
<p>Pipeline的缺点：</p>
<blockquote>
<p>每批打包的命令不能过多，因为所有命令前先缓存起所有命令的处理结果，这样就有一个内存的消耗。</p>
<p>不保证原子性，执行命令过程中，如果一个命令出现异常，也会继续执行其他命令。</p>
<p>每次只能作用在一个Redis节点上。</p>
</blockquote>
<h1 id="内存机制"><a href="#内存机制" class="headerlink" title="内存机制"></a>内存机制</h1><p><strong>内存回收策略</strong></p>
<p>Redis的内存回收机制主要体现在以下两个方面：</p>
<blockquote>
<p>删除到达过期时间的键对象。</p>
<p>内存使用达到Maxmemory上限时触发内存溢出控制策略。</p>
</blockquote>
<p>删除过期键对象：</p>
<blockquote>
<p>Redis所有的键都可以设置过期属性，内部保存在过期字典中。 </p>
<p>惰性删除： </p>
<ul>
<li>当客户端读取带有超时属性的键时，如果已经超过键设置的过期时间，会执行删除操作并返回空。</li>
</ul>
<p>定时任务删除： </p>
<ul>
<li>Redis内部维护一个定时任务，默认每秒运行10次。</li>
</ul>
</blockquote>
<p><strong>内存溢出策略</strong></p>
<p>当Redis所用内存达到Maxmemory上限时会触发相应的溢出策略：</p>
<blockquote>
<p>noeviction：</p>
<ul>
<li>默认策略，不会删除任何数据，拒绝所有写入操作并返回客户端错误信息，此时Redis只响应读操作。</li>
</ul>
<p>volatile-lru： </p>
<ul>
<li>根据LRU算法删除设置了超时属性的键。 </li>
<li>如果没有可删除的键对象，回退到noeviction策略。</li>
</ul>
<p>allkeys-lru： </p>
<ul>
<li>根据LRU算法删除键，不管数据有没有设置超时属性。</li>
</ul>
<p>allkeys-random： </p>
<ul>
<li>随机删除所有键。</li>
</ul>
<p>volatile-random： </p>
<ul>
<li>随机删除过期键。</li>
</ul>
<p>volatile-ttl： </p>
<ul>
<li>根据键值对象的ttl属性，删除最近将要过期数据，如果没有 回退 到noeviction策略。</li>
</ul>
</blockquote>
<blockquote>
<p>优先使用 <code>allkeys-lru</code> 策略。</p>
<ul>
<li>业务数据中有明显的冷热数据区分，建议使用 <code>allkeys-lru</code> 策略。</li>
</ul>
<p>业务应用中的数据访问频率相差不大，没有明显的冷热数据区分，建议使用 <code>allkeys-random</code> 策略。</p>
<p>业务中有置顶的需求，比如置顶新闻、置顶视频，可以使用 <code>volatile-lru</code> 策略。</p>
</blockquote>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><blockquote>
<p>Redis提供了MULTI，EXEC两个命令来完成事务。</p>
<ul>
<li><p>客户端使用一个命令MULTI开启事务。</p>
</li>
<li><p>客户端把事务中本身要执行的具体操作（例如增删改数据）发送给服务器端，这些命令暂存到一个命令队列中，并不会立即执行。</p>
</li>
<li><p>客户端向服务器端发送提交事务的命令EXEC，让数据库实际执行第二步中发送的具体操作。</p>
</li>
</ul>
</blockquote>
<p><strong>原子性</strong></p>
<blockquote>
<p>命令入队时就报错，会放弃事务执行，保证原子性。</p>
<p>命令入队时没报错，实际执行时报错，不保证原子性。</p>
<ul>
<li>EXEC命令执行时实例故障，如果开启AOF日志，可以保证原子性。</li>
</ul>
</blockquote>
<p><strong>一致性</strong></p>
<blockquote>
<p>在命令执行错误或 Redis 发生故障的情况下，Redis 事务机制对一致性是有保证的。</p>
</blockquote>
<p><strong>隔离性</strong></p>
<blockquote>
<p>并发操作在 EXEC 命令前执行，此时，隔离性的保证要使用 WATCH 机制来实现，否则隔离性无法保证。</p>
<p>并发操作在 EXEC 命令后执行，此时，隔离性可以保证。</p>
</blockquote>
<p>WATCH机制的作用：</p>
<blockquote>
<p>在事务执行前，监控一个或多个键的值变化情况，当事务调用EXEC命令执行时，Watch机制会先检查监控的键是否被其他客户端修改了，如果修改了，就放弃事务执行，避免事务的隔离性被破坏。</p>
</blockquote>
<p><strong>持久性</strong></p>
<blockquote>
<p>不管 Redis 采用什么持久化模式，<strong>事务的持久性属性是得不到保证的。</strong></p>
</blockquote>
<h1 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h1><blockquote>
<p><code>Redis</code> 的 <strong>主从复制</strong> 模式下，一旦 <strong>主节点</strong> 由于故障不能提供服务，需要手动将 <strong>从节点</strong> 晋升为 <strong>主节点</strong>，同时还要通知 <strong>客户端</strong> 更新 <strong>主节点地址</strong>。</p>
<ul>
<li><code>Redis 2.8</code>以后提供了<code>Redis Sentinel</code><strong>哨兵机制</strong> 来解决这个问题。</li>
</ul>
</blockquote>
<p><strong>Redis Sentinel的主要功能</strong></p>
<blockquote>
<p><code>Sentinel</code>是一个管理多个<code>Redis</code>实例的工具，它可以实现对<code>Redis</code>的 <strong>监控</strong>、<strong>通知</strong>、<strong>自动故障转移</strong>。</p>
<p><strong>监控</strong></p>
<ul>
<li><code>Sentinel</code> 会不断的检查 <strong>主服务器</strong> 和 <strong>从服务器</strong> 是否正常运行。</li>
</ul>
<p><strong>通知</strong></p>
<ul>
<li>当被监控的某个 <code>Redis</code> 服务器出现问题，<code>Sentinel</code> 通过 <code>API</code> <strong>脚本</strong> 向 <strong>管理员</strong> 或者其他的 <strong>应用程序</strong> 发送通知。</li>
</ul>
<p><strong>自动故障转移</strong></p>
<ul>
<li>当 <strong>主节点</strong> 不能正常工作时，<code>Sentinel</code> 会开始一次 <strong>自动的</strong> 故障转移操作，它会将与 <strong>失效主节点</strong> 是 <strong>主从关系</strong> 的其中一个 <strong>从节点</strong> 升级为新的 <strong>主节点</strong>，并且将其他的 <strong>从节点</strong> 指向 <strong>新的主节点</strong>。</li>
</ul>
<p><strong>配置提供者</strong></p>
<ul>
<li>在 <code>Redis Sentinel</code> 模式下，<strong>客户端应用</strong> 在初始化时连接的是 <code>Sentinel</code> <strong>节点集合</strong>，从中获取 <strong>主节点</strong> 的信息。</li>
</ul>
</blockquote>
<p><strong>主观下线和客观下线</strong></p>
<blockquote>
<p>默认情况下，<strong>每个</strong> <code>Sentinel</code> 节点会以 <strong>每秒一次</strong> 的频率对 <code>Redis</code> 节点和 <strong>其它</strong> 的 <code>Sentinel</code> 节点发送 <code>PING</code> 命令，并通过节点的 <strong>回复</strong> 来判断节点是否在线。</p>
<p><strong>主观下线</strong></p>
<ul>
<li>适用于所有 <strong>主节点</strong> 和 <strong>从节点</strong>。</li>
<li>如果在 <code>down-after-milliseconds</code> 毫秒内，<code>Sentinel</code> 没有收到 <strong>目标节点</strong> 的有效回复，则会判定 <strong>该节点</strong> 为 <strong>主观下线</strong>。</li>
</ul>
<p><strong>客观下线</strong></p>
<ul>
<li>只适用于 <strong>主节点</strong>。</li>
<li>如果 <strong>主节点</strong> 出现故障，<code>Sentinel</code> 节点会通过 <code>sentinel is-master-down-by-addr</code> 命令，向其它 <code>Sentinel</code> 节点询问对该节点的 <strong>状态判断</strong>。</li>
<li>如果超过 <code>&lt;quorum&gt;</code> 个数的节点判定 <strong>主节点</strong> 不可达，则该 <code>Sentinel</code> 节点会判断 <strong>主节点</strong> 为 <strong>客观下线</strong>。</li>
</ul>
</blockquote>
<p><strong>工作原理</strong></p>
<blockquote>
<p>每个 <code>Sentinel</code> 以 <strong>每秒钟</strong> 一次的频率，向它所知的 <strong>主服务器</strong>、<strong>从服务器</strong> 以及其他 <code>Sentinel</code> <strong>实例</strong> 发送一个 <code>PING</code> 命令。</p>
<p>如果一个 <strong>实例</strong>距离 <strong>最后一次</strong> 有效回复 <code>PING</code> 命令的时间超过 <code>down-after-milliseconds</code> 所指定的值，这个实例会被 <code>Sentinel</code> 标记为 <strong>主观下线</strong>。</p>
<p>如果一个 <strong>主服务器</strong> 被标记为 <strong>主观下线</strong>，并且有 <strong>足够数量</strong> 的 <code>Sentinel</code>在指定的 <strong>时间范围</strong> 内同意这一判断，那么这个 <strong>主服务器</strong> 被标记为 <strong>客观下线</strong>。</p>
<p><code>Sentinel</code> 和其他 <code>Sentinel</code> 协商 <strong>主节点</strong> 的状态，如果 <strong>主节点</strong> 处于 <code>SDOWN</code> 状态，则投票自动选出新的 <strong>主节点</strong>。</p>
<p>将剩余的 <strong>从节点</strong> 指向 <strong>新的主节点</strong> 进行 <strong>数据复制</strong>。</p>
</blockquote>
<p><img src="/images/16560ce6759c1cb3~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="img"></p>
<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><blockquote>
<p><code>Redis 3.0</code>之前，使用 <strong>哨兵</strong>（<code>Sentinel</code>）机制来监控各个节点之间的状态。</p>
<p>在<code>3.0</code>版本正式推出，解决了 <code>Redis</code>在 <strong>分布式</strong> 方面的需求。</p>
</blockquote>
<p><strong>数据分区</strong></p>
<blockquote>
<p><code>Redis Cluster</code>采用 <strong>虚拟槽分区</strong>，所有的 <strong>键</strong> 根据 <strong>哈希函数</strong> 映射到 <code>0~16383</code> 整数槽内。</p>
<ul>
<li>计算公式：<code>slot = CRC16（key）&amp; 16383</code>。</li>
<li>每个节点负责维护一部分槽以及槽所映射的 <strong>键值数据</strong>。</li>
</ul>
</blockquote>
<p><strong>集群的功能限制</strong></p>
<blockquote>
<p><code>key</code> <strong>批量操作</strong> 支持有限:</p>
<ul>
<li>类似 <code>mset</code>、<code>mget</code> 操作，目前只支持对具有相同 <code>slot</code> 值的 <code>key</code> 执行 <strong>批量操作</strong>。</li>
<li>对于 <strong>映射为不同</strong> <code>slot</code> 值的 <code>key</code> 由于执行 <code>mget</code>、<code>mget</code> 等操作可能存在于多个节点上，因此不被支持。</li>
</ul>
<p><code>key</code> <strong>事务操作</strong> 支持有限:</p>
<ul>
<li>只支持 <strong>多</strong> <code>key</code> 在 <strong>同一节点上</strong> 的 <strong>事务操作</strong>，当多个<code>key</code>分布在 <strong>不同</strong> 的节点上时 <strong>无法</strong> 使用事务功能。</li>
</ul>
<p>不支持 <strong>多数据库空间</strong>:</p>
<ul>
<li><strong>单机</strong> 下的<code>Redis</code>可以支持<code>16</code>个数据库（<code>db0 ~ db15</code>），<strong>集群模式</strong> 下只能使用 <strong>一个</strong> 数据库空间，即<code>db0</code>。</li>
</ul>
</blockquote>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p><strong>RDB持久化</strong></p>
<blockquote>
<p>将内存中的数据生成快照保存到磁盘里面，保存的文件后缀是 <code>.rdb</code>。</p>
<p>rdb 文件是一个经过压缩的二进制文件，当 Redis 重新启动时，可以读取 rdb 快照文件恢复数据。</p>
<ul>
<li>包括：rdbSave 和 rdbLoad 两个函数。<ul>
<li>rdbSave用于生成 RDB 文件并保存到磁盘，rdbLoad用于将 RDB 文件中的数据重新载入到内存中。</li>
</ul>
</li>
</ul>
<p>RDB 文件是一个单文件的全量数据，很适合数据的容灾备份与恢复。</p>
<ul>
<li>通过 RDB 文件恢复数据库耗时较短，通常 1G 的快照文件载入内存只需 20s 左右。</li>
</ul>
</blockquote>
<p><strong>RDB文件的生成方式</strong></p>
<p>手动触发保存:</p>
<blockquote>
<p>通过 SAVE 和 BGSAVE 命令手动触发快照生成。</p>
<p>SAVE 是一个同步式的命令，它会阻塞 Redis 服务器进程，直到 RDB 文件创建完成为止。</p>
<ul>
<li>在服务器进程阻塞期间，服务器不能处理任何其他命令请求。</li>
</ul>
<p>BGSAVE 是一个异步式的命令：</p>
<ul>
<li>会派生出一个子进程，由子进程负责创建 RDB 文件，服务器进程（父进程）继续处理客户的命令。</li>
</ul>
<p>基本过程：</p>
<ul>
<li><p>客户端发起 BGSAVE 命令，Redis 主进程判断当前是否存在正在执行备份的子进程，如果存在则直接返回。</p>
</li>
<li><p>父进程 fork 一个子进程 （fork 的过程中会造成阻塞的情况）。</p>
</li>
<li><p>fork 创建的子进程开始根据父进程的内存数据生成临时的快照文件，然后替换原文件。</p>
</li>
<li><p>子进程备份完毕后向父进程发送完成信息。</p>
</li>
</ul>
</blockquote>
<p><img src="/images/image-20231023181622055.png" alt="image-20231023181622055"></p>
<p>自动触发保存：</p>
<blockquote>
<p>通过 save 选项设置多个保存条件，只要其中任意一个条件被满足，服务器就会执行 BGSAVE 命令。 </p>
<p>只要满足以下 3 个条件中的任意一个，BGSAVE 命令就会被自动执行：</p>
<ul>
<li>服务器在 900 秒之内，对数据库进行了至少 1 次修改。</li>
<li>服务器在 300 秒之内，对数据库进行了至少 10 次修改。</li>
<li>服务器在 60 秒之内，对数据库进行了至少 10000 次修改。</li>
</ul>
</blockquote>
<p><strong>AOF持久化</strong></p>
<blockquote>
<p>AOF 会把 Redis 服务器每次执行的写命令记录到一个日志文件中，当服务器重启时再次执行 AOF 文件中的命令来恢复数据。</p>
<p>如果 Redis 服务器开启了 AOF 持久化，会优先使用 AOF 文件来还原数据库状态。</p>
<p>只有在 AOF 的持久化功能处于关闭状态时，服务器才会使用 RDB 文件还原数据库状态。</p>
</blockquote>
<p><strong>执行流程</strong></p>
<blockquote>
<p>AOF 不需要设置任何触发条件，对 Redis 服务器的所有写命令都会自动记录到 AOF 文件中。</p>
<p>AOF 文件的写入流程可以分为 3 个步骤：</p>
<ul>
<li><p>命令追加（append）：将 Redis 执行的写命令追加到 AOF 的缓冲区 <code>aof_buf</code>。</p>
</li>
<li><p>文件写入（write）和文件同步（fsync）：AOF 根据对应的策略将 <code>aof_buf</code> 的数据同步到硬盘。</p>
</li>
<li><p>文件重写（rewrite）：定期对 AOF 进行重写，从而实现对写命令的压缩。</p>
</li>
</ul>
</blockquote>
<p><strong>AOF缓冲区的文件同步策略</strong></p>
<blockquote>
<p><strong>appendfsync always</strong>：每执行一次命令保存一次</p>
<ul>
<li>命令写入 <code>aof_buf</code> 缓冲区后立即调用系统 fsync 函数同步到 AOF 文件，fsync 操作完成后线程返回，整个过程是阻塞的。</li>
</ul>
<p><strong>appendfsync no</strong>：不保存</p>
<ul>
<li>命令写入 <code>aof_buf</code> 缓冲区后调用系统 write 操作，不对 AOF 文件做 fsync 同步。<ul>
<li>同步由操作系统负责，通常同步周期为 30 秒。</li>
</ul>
</li>
</ul>
<p><strong>appendfsync everysec</strong>：每秒钟保存一次</p>
<ul>
<li>命令写入 <code>aof_buf</code> 缓冲区后调用系统 write 操作，write 完成后线程立刻返回，fsync 同步文件操作由单独的进程每秒调用一次。</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>文件同步策略</th>
<th>write 阻塞</th>
<th>fsync 阻塞</th>
<th>宕机时的数据丢失量</th>
</tr>
</thead>
<tbody><tr>
<td>always</td>
<td>阻塞</td>
<td>阻塞</td>
<td>最多只丢失一个命令的数据</td>
</tr>
<tr>
<td>no</td>
<td>阻塞</td>
<td>不阻塞</td>
<td>操作系统最后一次对 AOF 文件 fsync 后的数据</td>
</tr>
<tr>
<td>everysec</td>
<td>阻塞</td>
<td>不阻塞</td>
<td>一般不超过 1 秒钟的数据</td>
</tr>
</tbody></table>
<p><strong>文件重写</strong></p>
<blockquote>
<p>把对 AOF 文件中的写命令进行合并，压缩文件体积，同步到新的 AOF 文件中，然后使用新的 AOF 文件覆盖旧的 AOF 文件。</p>
</blockquote>
<p>触发机制：</p>
<blockquote>
<p>手动触发：</p>
<ul>
<li>调用 bgrewriteaof 命令，执行与 bgsave 有些类似</li>
</ul>
<p>自动触发：</p>
<ul>
<li>根据 <code>auto-aof-rewrite-min-size</code> 和 <code>auto-aof-rewrite-percentage</code> 配置项，以及 <code>aof_current_size</code> 和 <code>aof_base_size</code> 的状态确定触发时机</li>
</ul>
<ul>
<li>auto-aof-rewrite-min-size：执行 AOF 重写时，文件的最小体积，默认值为 64MB</li>
<li>auto-aof-rewrite-percentage：<ul>
<li>执行 AOF 重写时，当前 AOF 大小（<code>aof_current_size</code>）和上一次重写时 AOF 大小（<code>aof_base_size</code>）的比值</li>
</ul>
</li>
</ul>
</blockquote>
<p>重写流程:</p>
<blockquote>
<p>客户端通过 <code>bgrewriteaof</code> 命令对 Redis 主进程发起 AOF 重写请求。</p>
<p>主进程通过 fork 操作创建子进程，这个过程主进程是阻塞的。</p>
<p>主进程的 fork 操作完成后，继续处理其他命令，把新的写命令同时追加到 <code>aof_buf</code> 和 <code>aof_rewrite_buf</code> 缓冲区中。</p>
<ul>
<li>在文件重写完成之前，主进程会继续把写命令追加到 <code>aof_buf</code> 缓冲区，这样可以避免 AOF 重写失败造成数据丢失，保证原有的 AOF 文件的正确性。</li>
<li>由于 fork 操作运用写时复制技术，子进程只能共享 fork 操作时的内存数据，主进程会把新命令追加到一个 <code>aof_rewrite_buf</code> 缓冲区中，避免 AOF 重写时丢失这部分数据。</li>
</ul>
<p>子进程读取 Redis 进程中的数据快照，生成写入命令并按照命令合并规则批量写入到新的 AOF 文件。</p>
<p>子进程写完新的 AOF 文件后，向主进程发信号。</p>
<p>主进程接受到子进程的信号以后，将 <code>aof_rewrite_buf</code> 缓冲区中的写命令追加到新的 AOF 文件。</p>
<p>主进程使用新的 AOF 文件替换旧的 AOF 文件，AOF 重写过程完成。</p>
</blockquote>
<img src="/images/image-20231023183436329.png" alt="image-20231023183436329" style="zoom:90%;" />

<p><strong>RDB的优缺点：</strong></p>
<blockquote>
<p>优点:</p>
<ul>
<li>RDB 是一个压缩过的非常紧凑的文件，保存着某个时间点的数据集，适合做数据的备份、灾难恢复。</li>
<li>与 AOF 持久化方式相比，恢复大数据集的时候会更快。</li>
</ul>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>数据安全性是不如 AOF，保存整个数据集是个重量级的过程，可能要几分钟才进行一次持久化，如果服务器宕机，就可能丢失几分钟的数据。</p>
<p>Redis 数据集较大时，fork 的子进程要完成快照会比较耗费 CPU 和时间。</p>
</blockquote>
<p><strong>AOF的优缺点</strong></p>
<blockquote>
<p>优点:</p>
<ul>
<li>数据更完整，安全性更高，秒级数据丢失。</li>
<li>AOF 文件是一个只进行追加的命令文件，且写入操作是以 Redis 协议的格式保存的，内容是可读的，适合误删紧急恢复。</li>
</ul>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>对于相同的数据集，AOF 文件的体积要远远大于 RDB 文件，数据恢复也会比较慢。</p>
</blockquote>
<p><strong>RDB-AOF混合持久化</strong></p>
<blockquote>
<p>Redis 4.0 版本提供了一套基于 AOF-RDB 的混合持久化机制，保留了两种持久化机制的优点。</p>
<p>这样重写的 AOF 文件由两部份组成，一部分是 RDB 格式的头部数据，另一部分是 AOF 格式的尾部指令。</p>
<p>在 Redis 服务器重启的时候：</p>
<ul>
<li>可以预先加载 AOF 文件头部全量的 RDB 数据。</li>
<li>然后再重放 AOF 文件尾部增量的 AOF 命令，从而大大减少了重启过程中数据还原的时间。</li>
</ul>
</blockquote>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p><strong>热Key</strong></p>
<p>京东开源工具：<a target="_blank" rel="noopener" href="https://gitee.com/jd-platform-opensource/hotkey">https://gitee.com/jd-platform-opensource/hotkey</a></p>
<p>热 Key 带来问题：</p>
<blockquote>
<p>流量集中，达到服务器处理上限（<code>CPU</code>、网络 <code>IO</code> 等）。</p>
<p>会影响在同一个 <code>Redis</code> 实例上其他 <code>Key</code> 的读写请求操作。</p>
<p>热 <code>Key</code> 请求落到同一个 <code>Redis</code> 实例上，无法通过扩容解决。</p>
<p>大量 <code>Redis</code> 请求失败，查询操作可能打到数据库，拖垮数据库，导致整个服务不可用。</p>
</blockquote>
<p>如何发现热 Key：</p>
<blockquote>
<p>客户端进行收集:</p>
<ul>
<li>可以对客户端工具进行封装，在发送请求前进行收集采集，同时定时把收集到的数据上报到统一的服务进行聚合计算。</li>
</ul>
<p>在代理层进行收集:</p>
<ul>
<li>如果所有的<code>Redis</code>请求都经过<code>Proxy</code>（代理）的话，可以考虑改动<code>Proxy</code>代码进行收集。</li>
</ul>
</blockquote>
<p>热 Key 问题解决方案:</p>
<blockquote>
<p>增加 Redis 实例副本数量：</p>
<ul>
<li>对于出现热<code>Key</code>的<code>Redis</code>实例，可以通过水平扩容增加副本数量，将读请求的压力分担到不同副本节点上。</li>
</ul>
<p>二级缓存（本地缓存）</p>
</blockquote>
<p>热 Key 备份：</p>
<blockquote>
<p>通过热<code>Key</code>备份的方式，给热<code>Key</code>加上前缀或者后缀，把一个热 <code>Key</code> 的数量变成 <code>Redis</code> 实例个数 <code>N</code> 的倍数 <code>M</code>，从而由访问一个 RedisKey 变成访问 <code>N*M</code> 个 RedisKey。 </p>
<p><code>N*M</code> 个 RedisKey 经过分片分布到不同的实例上，将访问量均摊到所有实例。</p>
</blockquote>
<pre><code class="java">// N 为 Redis 实例个数，M 为 N 的 2倍
const M = N * 2
//生成随机数
random = GenRandom(0, M)
//构造备份新 Key
bakHotKey = hotKey + &quot;_&quot; + random
data = redis.GET(bakHotKey)
if data == NULL &#123;
    data = redis.GET(hotKey)
    if data == NULL &#123;
        data = GetFromDB()
        // 可以利用原子锁来写入数据保证数据一致性
        redis.SET(hotKey, data, expireTime)
        redis.SET(bakHotKey, data, expireTime + GenRandom(0, 5))
    &#125; else &#123;
        redis.SET(bakHotKey, data, expireTime + GenRandom(0, 5))
    &#125;
&#125;
</code></pre>
<blockquote>
<p>通过一个大于等于 <code>1</code> 小于 <code>M</code> 的随机数，得到一个 <code>bakHotKey</code>，程序会优先访问 <code>bakHotKey</code>，在得不到数据的情况下，再访问原来的 <code>hotkey</code>，并将 <code>hotkey</code> 的内容写回 <code>bakHotKey</code>。</p>
<p><code>bakHotKey</code> 的过期时间是 <code>hotkey</code> 的过期时间加上一个较小的随机正整数，保证在 <code>hotkey</code> 过期时，所有 <code>bakHotKey</code> 不会同时过期而造成缓存雪崩。</p>
</blockquote>
<p><strong>大key</strong></p>
<blockquote>
<p>如果String类型值大于10KB，Hash，Set，Zset，List类型的元素的个数大于5000个都可以称之为大key。</p>
</blockquote>
<p>大key的危害：</p>
<blockquote>
<p>客户端超时等待</p>
<p>阻塞工作线程</p>
<p>内存分布不均匀：</p>
<ul>
<li>集群模型在slot分片均匀的情况下，会出现数据和查询倾斜情况，部分有大key的Redis节点占用内存多。</li>
</ul>
</blockquote>
<p>如何处理大key：</p>
<blockquote>
<p>对大key进行拆分:</p>
<ul>
<li>将一个Big Key拆分为多个key-value这样的小Key，并确保每个key的成员数量或者大小在合理范围内。</li>
<li>通过get不同的key或者使用mget批量获取。</li>
</ul>
</blockquote>
<p><strong>缓存一致性</strong></p>
<table>
<thead>
<tr>
<th align="left">方案</th>
<th align="left">问题</th>
<th align="left">问题出现概率</th>
<th align="left">推荐程度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">更新缓存 -&gt; 更新数据库</td>
<td align="left">为了保证数据准确性，数据必须以数据库更新结果为准，所以该方案绝不可行</td>
<td align="left">大</td>
<td align="left">不推荐</td>
</tr>
<tr>
<td align="left">更新数据库 -&gt; 更新缓存</td>
<td align="left">并发更新数据库场景下，会将脏数据刷到缓存</td>
<td align="left">并发写场景，概率一般</td>
<td align="left">写请求较多时会出现不一致问题，不推荐使用。</td>
</tr>
<tr>
<td align="left">删除缓存 -&gt; 更新数据库</td>
<td align="left">更新数据库之前，若有查询请求，会将脏数据刷到缓存</td>
<td align="left">并发读场景，概率较大</td>
<td align="left">读请求较多时会出现不一致问题，不推荐使用</td>
</tr>
<tr>
<td align="left">更新数据库 -&gt; 删除缓存</td>
<td align="left">在更新数据库之前有查询请求，并且缓存失效了，会查询数据库，然后更新缓存。如果在查询数据库和更新缓存之间进行了数据库更新的操作，那么就会把脏数据刷到缓存</td>
<td align="left">并发读场景&amp;读操作慢于写操作，概率最小</td>
<td align="left"><strong>读操作比写操作更慢的情况较少，相比于其他方式出错的概率小一些。勉强推荐。</strong></td>
</tr>
</tbody></table>
<p><strong>缓存击穿</strong></p>
<img src="/images/640-20231025221358433.png" alt="图片" style="zoom:50%;" />

<p>解决方案：</p>
<blockquote>
<p>使用互斥锁。</p>
<p>提前使用互斥锁：</p>
<ul>
<li>即在value内部设置1个超时值(timeout1)，timeout1比实际的redis timeout(timeout2)小。</li>
<li>当从cache读取到timeout1发现它已经过期时候，马上延长timeout1并重新设置到cache。</li>
<li>然后再从数据库加载数据并设置到cache中。</li>
</ul>
<p>缓存永不过期。</p>
</blockquote>
<p><strong>缓存穿透</strong></p>
<blockquote>
<p>查询一个一定不存在的数据，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询。</p>
<p>在流量大时，要是DB无法承受瞬间流量冲击，DB可能就挂了。</p>
</blockquote>
<img src="/images/640-20231025221735811.png" alt="图片" style="zoom:50%;" />

<p>解决方案：</p>
<blockquote>
<p>缓存空数据。</p>
<p>布隆过滤器。</p>
</blockquote>
<p><strong>缓存雪崩</strong></p>
<blockquote>
<p>缓存中有大量数据同时过期，导致大量请求无法得到处理。</p>
</blockquote>
<p>解决方案：</p>
<blockquote>
<p>设计不同的过期时间。</p>
<p>对缓存增加多个副本。</p>
</blockquote>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p><strong>分布式锁</strong></p>
<blockquote>
<p>使用分布式锁的目的，是保证同一时间只有一个客户端可以对共享资源进行操作。</p>
</blockquote>
<p>使用SETNX实现：</p>
<blockquote>
<p><code>SETNX key value</code>，只在键key不存在的情况下，将键key的值设置为value，若键key存在，则SETNX不做任何动作。</p>
</blockquote>
<pre><code class="java">boolean result = jedis.setnx(&quot;lock-key&quot;,true)== 1L;
if  (result) &#123;
    try &#123;
        // do something
    &#125; finally &#123;
        jedis.del(&quot;lock-key&quot;);
    &#125;
 &#125;
</code></pre>
<blockquote>
<p>某个线程在获取锁之后由于某些异常因素（比如宕机）而不能正常的执行解锁操作，这个锁就永远释放不掉了。</p>
<ul>
<li>可以为这个锁加上一个超时时间。</li>
</ul>
<p><code>SET key value EX seconds</code> 的效果等同于执行 <code>SETEX key seconds value</code></p>
<p><code>SET key value PX milliseconds</code> 的效果等同于执行 <code>PSETEX key milliseconds value</code></p>
</blockquote>
<pre><code class="java">String result = jedis.set(&quot;lock-key&quot;,true, 5);
if (&quot;OK&quot;.equals(result)) &#123;
    try &#123;
        // do something
    &#125; finally &#123;
        jedis.del(&quot;lock-key&quot;);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>某线程A获取了锁设置了过期时间为10s，在执行业务逻辑时耗费了15s，此时线程A获取的锁被Redis的过期机制自动释放了。</p>
<p>在线程A获取锁并经过10s之后，改锁可能已经被其它线程获取到了。</p>
<ul>
<li>当线程A执行完业务逻辑准备解锁（DEL key）的时候，有可能删除掉的是其它线程已经获取到的锁。</li>
</ul>
<p>所以在解锁时判断锁是否是自己的，可以在设置key的时候将value设置为一个唯一值uniqueValue。</p>
<p>当解锁时，也就是删除key的时候先判断一下key对应的value是否等于先前设置的值，如果相等才能删除key。</p>
</blockquote>
<pre><code class="java">String velue= String.valueOf(System.currentTimeMillis())
String result = jedis.set(&quot;lock-key&quot;,velue, 5);
if (&quot;OK&quot;.equals(result)) &#123;
    try &#123;
        // do something
    &#125; finally &#123;
          //非原子操作
          if(jedis.get(&quot;lock-key&quot;)==value)&#123;
                jedis.del(&quot;lock-key&quot;);
        &#125;    
    &#125;
&#125;
</code></pre>
<blockquote>
<p><code>GET</code>和<code>DEL</code>是两个分开的操作，在GET执行之后且在DEL执行之前的间隙是可能会发生异常的。</p>
<p>只要保证解锁的代码是原子性的就能解决问题了。</p>
<p>由于Lua脚本的原子性，在Redis执行该脚本的过程中，其他客户端的命令都需要等待该Lua脚本执行完才能执行。</p>
</blockquote>
<pre><code class="lua">if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then
    return redis.call(&quot;del&quot;,KEYS[1])
else
    return 0
end
</code></pre>
<p>确保过期时间大于业务执行时间：</p>
<blockquote>
<p>为了防止多个线程同时执行业务代码，需要确保过期时间大于业务执行时间。</p>
<p>增加一个boolean类型的属性isOpenExpirationRenewal，用来标识是否开启定时刷新过期时间。</p>
<p>增加一个scheduleExpirationRenewal方法用于开启刷新过期时间的线程。</p>
<p>加锁代码在获取锁成功后将isOpenExpirationRenewal置为true，并且调用scheduleExpirationRenewal方法，开启刷新过期时间的线程。</p>
<p>解锁代码增加一行代码，将isOpenExpirationRenewal属性置为false，停止刷新过期时间的线程轮询。</p>
</blockquote>
<p>Redisson实现：</p>
<blockquote>
<p>获取锁成功就会开启一个定时任务，定时任务会定期检查去续期。</p>
<p>该定时调度每次调用的时间差是<code>internalLockLeaseTime/3</code>，也就10秒。</p>
<p>默认情况下，加锁的时间是30秒，如果加锁的业务没有执行完，那么到 30-10 &#x3D; 20秒的时候，就会进行一次续期，把锁重置成30秒。</p>
</blockquote>
<p><strong>RedLock</strong></p>
<blockquote>
<p>在集群中，主节点挂掉时，从节点会取而代之，客户端上却并没有明显感知。</p>
<p>原先第一个客户端在主节点中申请成功了一把锁，但是这把锁还没有来得及同步到从节点，主节点突然挂掉了。</p>
<p>然后从节点变成了主节点，这个新的节点内部没有这个锁，所以当另一个客户端过来请求加锁时，立即就批准了。</p>
<p>这样就会导致系统中同样一把锁被两个客户端同时持有，不安全性由此产生。</p>
</blockquote>
<p>Redlock算法就是为了解决这个问题:</p>
<blockquote>
<p>加锁时，它会向过半节点发送 set指令，只要过半节点 set 成功，那就认为加锁成功。</p>
<p>释放锁时，需要向所有节点发送 del 指令。</p>
<p>不过 Redlock 算法还需要考虑出错重试、时钟漂移等很多细节问题，同时因为 Redlock 需要向多个节点进行读写，意味着相比单实例 Redis 性能会下降一些。</p>
</blockquote>
<p>假设当前集群有 5 个节点，运行 Redlock 算法的客户端依次执行下面各个步骤，来完成获取锁的操作:</p>
<blockquote>
<p>客户端记录当前系统时间，以毫秒为单位。</p>
<p>依次尝试从 5 个 Redis 实例中，使用相同的 key 获取锁。</p>
<p>当向 Redis 请求获取锁时，客户端应该设置一个网络连接和响应超时时间，超时时间应该小于锁的失效时间，避免因为网络故障出现的问题。</p>
<p>客户端使用当前时间减去开始获取锁时间就得到了获取锁使用的时间。</p>
<p>当且仅当从半数以上的 Redis 节点获取到锁，并且当使用的时间小于锁失效时间时，锁才算获取成功。</p>
<p>如果获取到了锁，key 的真正有效时间等于有效时间减去获取锁所使用的时间，减少超时的几率。</p>
<p>如果获取锁失败，客户端应该在所有的 Redis 实例上进行解锁，即使是上一步操作请求失败的节点，防止因为服务端响应消息丢失，但是实际数据添加成功导致的不一致。</p>
<p>也就是说，假设锁30秒过期，三个节点加锁花了31秒，自然是加锁失败了。</p>
<p>在 Redis 官方推荐的 Java 客户端 Redisson 中，内置了对 RedLock 的实现。</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki">https://github.com/redisson/redisson/wiki</a></p>
</li>
</ul>
</blockquote>
<p>RedLock问题：</p>
<blockquote>
<p>RedLock 只是保证了锁的高可用性，并没有保证锁的正确性。</p>
<p>RedLock 是一个<strong>严重依赖系统时钟</strong>的分布式系统。</p>
</blockquote>
<p><strong>延时队列</strong></p>
<blockquote>
<p>使用 zset这个命令，用设置好的时间戳作为score进行排序，使用 <code>zadd score1 value1 ....</code>命令就可以一直往内存中生产消息。</p>
<p>再利用 zrangebysocre 查询符合条件的所有待处理的任务，通过循环执行队列任务即可。</p>
<ul>
<li>通过 <code>zrangebyscore key min max withscores limit 0 1</code> 查询最早的一条任务，来进行消费。</li>
</ul>
</blockquote>
<pre><code class="java">private Jedis jedis;

public void redisDelayQueueTest() &#123;
    String key = &quot;delay_queue&quot;;

    // 实际开发建议使用业务 ID 和随机生成的唯一 ID 作为 value, 随机生成的唯一 ID 可以保证消息的唯一性, 业务 ID 可以避免 value 携带的信息过多
    String orderId1 = UUID.randomUUID().toString();
    jedis.zadd(queueKey, System.currentTimeMillis() + 5000, orderId1);

    String orderId12 = UUID.randomUUID().toString();
    jedis.zadd(queueKey, System.currentTimeMillis() + 5000, orderId2);

    new Thread() &#123;
        @Override
        public void run() &#123;
            while (true) &#123;
                Set&lt;String&gt; resultList;
                // 只获取第一条数据, 只获取不会移除数据
                resultList = jedis.zrangebyscore(key, System.currentTimeMillis(), 0, 1);
                if (resultList.size() == 0) &#123;
                    try &#123;
                        Thread.sleep(1000);
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                        break;
                    &#125;
                &#125; else &#123;
                    // 移除数据获取到的数据
                    if (jedis.zrem(key, resultList.get(0)) &gt; 0) &#123;
                        String orderId = resultList.get(0);
                        log.info(&quot;orderId = &#123;&#125;&quot;, resultList.get(0));
                        this.handleMsg(orderId);
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;.start();
&#125;

public void handleMsg(T msg) &#123;
    System.out.println(msg);
&#125;
</code></pre>
<p>进一步优化:</p>
<blockquote>
<p>同一个任务可能会被多个进程取到之后再使用 zrem 进行争抢，那些没抢到 的进程都是白取了一次任务。</p>
<p>可以考虑使用 <code>lua scripting</code> 来优化一下这个逻辑，将 <code>zrangebyscore</code> 和 <code>zrem</code> 一同挪到服务器端进行原子化操作，这样多个进程之间争抢任务时就不会出现这种浪费了。</p>
</blockquote>
<pre><code class="lua">String luaScript = &quot;local resultArray = redis.call(&#39;zrangebyscore&#39;, KEYS[1], 0, ARGV[1], &#39;limit&#39; , 0, 1)\n&quot; +
        &quot;if #resultArray &gt; 0 then\n&quot; +
        &quot;    if redis.call(&#39;zrem&#39;, KEYS[1], resultArray[1]) &gt; 0 then\n&quot; +
        &quot;        return resultArray[1]\n&quot; +
        &quot;    else\n&quot; +
        &quot;        return &#39;&#39;\n&quot; +
        &quot;    end\n&quot; +
        &quot;else\n&quot; +
        &quot;    return &#39;&#39;\n&quot; +
        &quot;end&quot;;
jedis.eval(luaScript, ScriptOutputType.VALUE, new String[]&#123;key&#125;, String.valueOf(System.currentTimeMillis()));
</code></pre>
<p><strong>统计一个亿的Keys</strong></p>
<p>HyperLogLog：</p>
<blockquote>
<p>Redis提供了一个扩展类型HyperLogLog用于基数统计，计算<code>2^64</code>个元素大概只需要12KB的内存空间。</p>
<p>但是<code>HyperLogLog</code>是存在误差的，大概是在<code>0.81%</code>，如果需要精准的统计，还是需要使用<code>Set</code>。</p>
</blockquote>

	</div>
</div>


    <div class="post-guide">
        <div class="item left">
            
              <a href="/2023/10/21/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/DDD/">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  DDD
              </a>
            
        </div>
        <div class="item right">
            
              <a href="/2023/10/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/ZooKeeper/">
                ZooKeeper
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>




<script>

    //document.oncontextmenu=new Function("event.returnValue=false");
	//document.onselectstart=new Function("event.returnValue=false");

	

	$(function () {
		const btw = new BTWPlugin();
	    btw.init({
	        id: 'container',
	        blogId: '22377-1698371038275-425',
	        name: '月伴飞鱼',
	        qrcode: '/小程序码.jpg',
	        keyword: '验证码',
	    });

	    var contents = document.getElementsByClassName("content999");
	    //监听文章内容的copy事件
	    contents[0].addEventListener('copy',function(e){
	        setClipboardText(e);
	    });

	    function setClipboardText(event){
	        // clipboardData 对象是为通过编辑菜单、快捷菜单和快捷键执行的编辑操作所保留的，也就是你复制或者剪切内容
	        let clipboardData = event.clipboardData || window.clipboardData;

	        // 如果未复制或者未剪切，则return出去
	        if (!clipboardData) { return; }

	        event.preventDefault();

	        // Selection 对象，表示用户选择的文本范围或光标的当前位置。
	        // 声明一个变量接收 -- 用户输入的剪切或者复制的文本转化为字符串
	        let text = window.getSelection().toString();
	    
	        if (text) {
	            // 如果文本存在则先取消文本默认事件
	            event.preventDefault();
	            // 通过调用常clipboardData对象的 setData(format, data) 方法；来设置相关文本
	            // format: 一个DOMString 表示要添加到 drag object的拖动数据的类型。
	            // data: 一个 DOMString表示要添加到 drag object的数据。
	            var copyright = '\n\n'
	            + '\n著作权归作者所有。'
	            + '\n商业转载请联系作者获得授权，非商业转载请注明出处。'
	            + '\n作者: 月伴飞鱼'
	            + '\n原文地址: https://xiaoflyfish.cn/2023/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/'
	    
	            clipboardData.setData('text/plain', text + copyright);
	    
	        }
	    };
	});

	
</script>

<script>
    const btw = new BTWPlugin();
    btw.init({
        id: 'container',
        blogId: '22377-1698371038275-425',
        name: '月伴飞鱼',
        qrcode: '/小程序码.jpg',
        keyword: '验证码',
    });
</script>
	</div>
	<div id="footer">
	<p>
	©2019-<span id="footerYear"></span> 
	<a href="/">月伴飞鱼</a> 
	
	
		|
		<span id="busuanzi_container_site_pv">
			PV 180986
		</span>
		|
		<span id="busuanzi_container_site_uv"> 
			UV 10079
		</span>
	
	<br>
	微信搜索 <a href="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/个人公众号.jpg" target="_blank">月伴飞鱼</a> 关注我
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>
	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>