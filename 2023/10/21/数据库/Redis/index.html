<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		Redis | 
	 
	月伴飞鱼
	</title>
	
	<!-- keywords,description -->
	 

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/%E5%A4%B4%E5%83%8F.jpg">
	
  
  	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="/css/jquery.fancybox.min.css">

	
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="/lib/highlight/darcula.css">

	
<link rel="stylesheet" href="/css/clipboard-use.css">


	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">

	
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>


	
<script src="/lib/highlight/highlight.min.js"></script>

	
<script src="https://readmore.openwrite.cn/js/readmore.js"></script>

	
<script src="/lib/jquery-3.4.1.min.js"></script>

	
<script src="/lib/jquery.pjax.js"></script>


	
<script src="/js/main.js"></script>

	
<script src="/js/jquery.fancybox.min.js"></script>

	
		
<script src="/lib/valine/av-3.0.4-min.js"></script>

		
<script src="/lib/valine/Valine-1.3.10-min.js"></script>

	
	
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
	
<script src="/js/clipboard.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body oncontextmenu="return false;">
	<header id="header">
    <a id="title" href="/" class="logo">公众号月伴飞鱼</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">关于我</a>
		</li>

		<li class="menu-item">
			<a href="/个人公众号.jpg" class="menu-item-link" target="_blank">我的公众号</a>
		</li>
		
		<li class="menu-item">
			<a href="https://tech.meituan.com/" class="menu-item-link" target="_blank">
				美团技术团队
			</a>
		</li>
		<li class="menu-item">
			<a href="https://tech.youzan.com/" class="menu-item-link" target="_blank">
				有赞技术团队
			</a>
		</li>
		<!--<li class="menu-item">
			<select class="menu-item-link menu-item-select">
				<option class="menu-item-link"  value="volvo">Volvo</option>
				<option class="menu-item-link"  value="saab">Saab</option>
				<option class="menu-item-link"  value="fiat">Fiat</option>
				<option class="menu-item-link"  value="audi">Audi</option>
			</select>
		</li>-->
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="text" placeholder="按目录搜索一下">
		<div id="tree">
			

			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										中间件
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/12/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/Elasticsearch/">
										Elasticsearch
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/ZooKeeper/">
										ZooKeeper
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										前端相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/CSS/">
										CSS
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/Vue/">
										Vue
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/12/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">
										小程序
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										基础知识
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/11/27/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM/">
										JVM
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/11/21/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E5%9F%BA%E7%A1%80/">
										Java基础
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%88%86%E5%B8%83%E5%BC%8F/">
										分布式
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/12/10/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">
										并发编程
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
										设计模式
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										工具相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/">
										实用工具
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">
										开发工具
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										数据库
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/12/02/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">
										MySQL
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file active">
									<a href="/2023/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/">
										Redis
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										服务器
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E6%9C%8D%E5%8A%A1%E5%99%A8/Docker/">
										Docker
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/09/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/">
										Nginx
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/09/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E8%BF%90%E7%BB%B4%E7%9F%A5%E8%AF%86/">
										运维知识
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										架构相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/21/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/DDD/">
										DDD
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										框架相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/08/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/MyBatis/">
										MyBatis
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/14/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/Spring/">
										Spring
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/10/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/">
										开源框架
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										消息队列
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/KAFKA/">
										KAFKA
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/">
										RocketMQ
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										生活相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/10/%E7%94%9F%E6%B4%BB%E7%9B%B8%E5%85%B3/%E7%94%B5%E5%BD%B1/">
										电影
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/09/%E7%94%9F%E6%B4%BB%E7%9B%B8%E5%85%B3/%E9%9F%B3%E4%B9%90/">
										音乐
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										算法相关
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/11/26/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/LeetCode/">
										LeetCode
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/11/26/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E5%89%91%E6%8C%87OFFER/">
										剑指OFFER
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/11/25/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/">
										面试算法
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										英语相关
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										老友记
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/08/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E8%80%81%E5%8F%8B%E8%AE%B0/%E7%AC%AC%E4%B8%80%E5%AD%A3/">
										第一季
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/08/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E8%80%81%E5%8F%8B%E8%AE%B0/%E7%AC%AC%E4%B8%89%E5%AD%A3/">
										第三季
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										雅思
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/12/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/%E9%9B%85%E6%80%9D/%E5%89%91%E6%A1%A5%E9%9B%85%E6%80%9D%E5%90%AC%E5%8A%9B%E7%9C%9F%E9%A2%98/">
										剑桥雅思听力真题
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										计算机基础
									</a>
									
							<ul>
								<li class="file">
									<a href="/2023/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
										操作系统
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
										数据结构
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/10/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/">
										算法知识
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/12/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">
										网络基础
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">

	Redis
</h1>
<div class="article-meta">
	<span>月伴飞鱼</span>
	<span>2023-10-21 17:13:49</span>
    
		<div id="article-categories">
            
                
                    <span>
                        <i class="fa fa-folder" aria-hidden="true"></i>
                        <a href="/categories/数据库/">数据库</a>
						
                    </span>
                
            
		</div>
    
</div>

<div id="container" class = "content999" oncontextmenu="return false;">
	<div id="article-content">
		<p><strong>Redis为什么那么快？</strong></p>
<p>基于内存实现：</p>
<blockquote>
<p>Redis 将数据存储在内存中，读写操作不会受到磁盘的 IO 速度限制，所以Redis的读写速度会非常的快。</p>
<p>CPU 不是 Redis 的瓶颈，Redis 的瓶颈是<strong>机器内存的大小或者网络带宽</strong>。</p>
</blockquote>
<p>使用I&#x2F;O多路复用模型：</p>
<blockquote>
<p>Redis 线程不会阻塞在某一个特定的客户端请求处理上。</p>
<ul>
<li>可以同时和多个客户端连接并处理请求，从而提升了并发性。</li>
</ul>
</blockquote>
<p>采用单线程模型：</p>
<blockquote>
<p>Redis 的网络 IO 以及键值对指令读写是由一个线程来执行的。 </p>
<ul>
<li>对于 Redis 的持久化、集群数据同步、异步删除等都是其他线程执行。</li>
</ul>
<p><strong>单线程</strong> 避免了 <strong>线程切换</strong> 和 <strong>竞态</strong> 产生的消耗，对于服务端开发来说，<strong>锁和线程切换</strong> 通常是性能杀手。</p>
</blockquote>
<p>高效的数据结构：</p>
<blockquote>
<p>为了追求速度，不同数据类型使用不同的数据结构速度才得以提升。</p>
</blockquote>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p><strong>Redis数据结构</strong></p>
<blockquote>
<p><code>string</code>（<strong>字符串</strong>）、<code>hash</code>（<strong>哈希</strong>）、<code>list</code>（<strong>列表</strong>）、<code>set</code>（<strong>集合</strong>）、<code>zset</code>（<strong>有序集合</strong>）</p>
</blockquote>
<img src="/images/165f79470dff7693~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="img" style="zoom:50%;" />

<p><strong>查询键的数据结构类型</strong></p>
<blockquote>
<p>type key:</p>
<ul>
<li><p>例如键 <code>hello</code>  <strong>字符串类型</strong>，返回: <code>string</code>。</p>
</li>
<li><p>键 <code>mylist</code>  <strong>列表类型</strong>，返回: <code>list</code>。</p>
</li>
<li><p>如果键不存在，则返回 <code>none</code>。</p>
</li>
</ul>
</blockquote>
<pre><code class="java">127.0.0.1:6379&gt; set a b
OK
127.0.0.1:6379&gt; type a
string
127.0.0.1:6379&gt; rpush mylist a b c d e f g
(integer) 7
127.0.0.1:6379&gt; type mylist
list
</code></pre>
<p><strong>内部编码</strong></p>
<blockquote>
<p>对于每种 <strong>数据结构</strong>，实际上都有自己底层的 <strong>内部编码</strong> 实现，而且是 <strong>多种实现</strong>。</p>
<p>这样 <code>Redis</code> 会在合适的 <strong>场景</strong> 选择合适的 <strong>内部编码</strong>。</p>
</blockquote>
<img src="/images/165f79470e44f30b~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="img" style="zoom:50%;" />

<p>通过 <code>object encoding</code> 命令查询 <strong>内部编码</strong>：</p>
<pre><code class="java">127.0.0.1:6379&gt; object encoding hello
&quot;embstr&quot;
127.0.0.1:6379&gt; object encoding mylist
&quot;quicklist&quot;
</code></pre>
<p><strong>Pipeline</strong></p>
<blockquote>
<p>通过将一批命令进行打包，然后发送给服务器，服务器执行完按顺序打包返回，这样就减少了频繁交互往返的时间，提升了性能。</p>
<ul>
<li>客户端将执行的命令写入到缓冲区（内存）中，最后再一次性发送 Redis。</li>
</ul>
</blockquote>
<p>Pipeline的优点：</p>
<blockquote>
<p>通过打包命令，一次性执行，可以节省连接-&gt;发送命令-&gt;返回结果这个过程所产生的往返时间，减少的I&#x2F;O的调用（用户态到内核态之间的切换）次数。</p>
</blockquote>
<p>Pipeline的缺点：</p>
<blockquote>
<p>每批打包的命令不能过多，因为所有命令前先缓存起所有命令的处理结果，这样就有一个内存的消耗。</p>
<p>不保证原子性，执行命令过程中，如果一个命令出现异常，也会继续执行其他命令。</p>
<p>每次只能作用在一个Redis节点上。</p>
</blockquote>
<h1 id="内存机制"><a href="#内存机制" class="headerlink" title="内存机制"></a>内存机制</h1><p><strong>内存回收策略</strong></p>
<p>Redis的内存回收机制主要体现在以下两个方面：</p>
<blockquote>
<p>删除到达过期时间的键对象。</p>
<p>内存使用达到Maxmemory上限时触发内存溢出控制策略。</p>
</blockquote>
<p>删除过期键对象：</p>
<blockquote>
<p>Redis所有的键都可以设置过期属性，内部保存在过期字典中。 </p>
<p>惰性删除： </p>
<ul>
<li>当客户端读取带有超时属性的键时，如果已经超过键设置的过期时间，会执行删除操作并返回空。</li>
</ul>
<p>定时任务删除： </p>
<ul>
<li>Redis内部维护一个定时任务，默认每秒运行10次。</li>
</ul>
</blockquote>
<p><strong>内存溢出策略</strong></p>
<p>当Redis所用内存达到Maxmemory上限时会触发相应的溢出策略：</p>
<blockquote>
<p>noeviction：</p>
<ul>
<li>默认策略，不会删除任何数据，拒绝所有写入操作并返回客户端错误信息，此时Redis只响应读操作。</li>
</ul>
<p>volatile-lru： </p>
<ul>
<li>根据LRU算法删除设置了超时属性的键。 </li>
<li>如果没有可删除的键对象，回退到noeviction策略。</li>
</ul>
<p>allkeys-lru： </p>
<ul>
<li>根据LRU算法删除键，不管数据有没有设置超时属性。</li>
</ul>
<p>allkeys-random： </p>
<ul>
<li>随机删除所有键。</li>
</ul>
<p>volatile-random： </p>
<ul>
<li>随机删除过期键。</li>
</ul>
<p>volatile-ttl： </p>
<ul>
<li>根据键值对象的ttl属性，删除最近将要过期数据，如果没有 回退 到noeviction策略。</li>
</ul>
</blockquote>
<blockquote>
<p>优先使用 <code>allkeys-lru</code> 策略。</p>
<ul>
<li>业务数据中有明显的冷热数据区分，建议使用 <code>allkeys-lru</code> 策略。</li>
</ul>
<p>业务应用中的数据访问频率相差不大，没有明显的冷热数据区分，建议使用 <code>allkeys-random</code> 策略。</p>
<p>业务中有置顶的需求，比如置顶新闻、置顶视频，可以使用 <code>volatile-lru</code> 策略。</p>
</blockquote>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><blockquote>
<p>Redis提供了MULTI，EXEC两个命令来完成事务。</p>
<ul>
<li><p>客户端使用一个命令MULTI开启事务。</p>
</li>
<li><p>客户端把事务中本身要执行的具体操作（例如增删改数据）发送给服务器端，这些命令暂存到一个命令队列中，并不会立即执行。</p>
</li>
<li><p>客户端向服务器端发送提交事务的命令EXEC，让数据库实际执行第二步中发送的具体操作。</p>
</li>
</ul>
</blockquote>
<p><strong>原子性</strong></p>
<blockquote>
<p>命令入队时就报错，会放弃事务执行，保证原子性。</p>
<p>命令入队时没报错，实际执行时报错，不保证原子性。</p>
<ul>
<li>EXEC命令执行时实例故障，如果开启AOF日志，可以保证原子性。</li>
</ul>
</blockquote>
<p><strong>一致性</strong></p>
<blockquote>
<p>在命令执行错误或 Redis 发生故障的情况下，Redis 事务机制对一致性是有保证的。</p>
</blockquote>
<p><strong>隔离性</strong></p>
<blockquote>
<p>并发操作在 EXEC 命令前执行，此时，隔离性的保证要使用 WATCH 机制来实现，否则隔离性无法保证。</p>
<p>并发操作在 EXEC 命令后执行，此时，隔离性可以保证。</p>
</blockquote>
<p>WATCH机制的作用：</p>
<blockquote>
<p>在事务执行前，监控一个或多个键的值变化情况，当事务调用EXEC命令执行时，Watch机制会先检查监控的键是否被其他客户端修改了，如果修改了，就放弃事务执行，避免事务的隔离性被破坏。</p>
</blockquote>
<p><strong>持久性</strong></p>
<blockquote>
<p>不管 Redis 采用什么持久化模式，<strong>事务的持久性属性是得不到保证的。</strong></p>
</blockquote>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p><strong>热Key</strong></p>
<p>京东开源工具：<a target="_blank" rel="noopener" href="https://gitee.com/jd-platform-opensource/hotkey">https://gitee.com/jd-platform-opensource/hotkey</a></p>
<p>热 Key 带来问题：</p>
<blockquote>
<p>流量集中，达到服务器处理上限（<code>CPU</code>、网络 <code>IO</code> 等）。</p>
<p>会影响在同一个 <code>Redis</code> 实例上其他 <code>Key</code> 的读写请求操作。</p>
<p>热 <code>Key</code> 请求落到同一个 <code>Redis</code> 实例上，无法通过扩容解决。</p>
<p>大量 <code>Redis</code> 请求失败，查询操作可能打到数据库，拖垮数据库，导致整个服务不可用。</p>
</blockquote>
<p>如何发现热 Key：</p>
<blockquote>
<p>客户端进行收集:</p>
<ul>
<li>可以对客户端工具进行封装，在发送请求前进行收集采集，同时定时把收集到的数据上报到统一的服务进行聚合计算。</li>
</ul>
<p>在代理层进行收集:</p>
<ul>
<li>如果所有的<code>Redis</code>请求都经过<code>Proxy</code>（代理）的话，可以考虑改动<code>Proxy</code>代码进行收集。</li>
</ul>
</blockquote>
<p>热 Key 问题解决方案:</p>
<blockquote>
<p>增加 Redis 实例副本数量：</p>
<ul>
<li>对于出现热<code>Key</code>的<code>Redis</code>实例，可以通过水平扩容增加副本数量，将读请求的压力分担到不同副本节点上。</li>
</ul>
<p>二级缓存（本地缓存）</p>
</blockquote>
<p>热 Key 备份：</p>
<blockquote>
<p>通过热<code>Key</code>备份的方式，给热<code>Key</code>加上前缀或者后缀，把一个热 <code>Key</code> 的数量变成 <code>Redis</code> 实例个数 <code>N</code> 的倍数 <code>M</code>，从而由访问一个 RedisKey 变成访问 <code>N*M</code> 个 RedisKey。 </p>
<p><code>N*M</code> 个 RedisKey 经过分片分布到不同的实例上，将访问量均摊到所有实例。</p>
</blockquote>
<pre><code class="java">// N 为 Redis 实例个数，M 为 N 的 2倍
const M = N * 2
//生成随机数
random = GenRandom(0, M)
//构造备份新 Key
bakHotKey = hotKey + &quot;_&quot; + random
data = redis.GET(bakHotKey)
if data == NULL &#123;
    data = redis.GET(hotKey)
    if data == NULL &#123;
        data = GetFromDB()
        // 可以利用原子锁来写入数据保证数据一致性
        redis.SET(hotKey, data, expireTime)
        redis.SET(bakHotKey, data, expireTime + GenRandom(0, 5))
    &#125; else &#123;
        redis.SET(bakHotKey, data, expireTime + GenRandom(0, 5))
    &#125;
&#125;
</code></pre>
<blockquote>
<p>通过一个大于等于 <code>1</code> 小于 <code>M</code> 的随机数，得到一个 <code>bakHotKey</code>，程序会优先访问 <code>bakHotKey</code>，在得不到数据的情况下，再访问原来的 <code>hotkey</code>，并将 <code>hotkey</code> 的内容写回 <code>bakHotKey</code>。</p>
<p><code>bakHotKey</code> 的过期时间是 <code>hotkey</code> 的过期时间加上一个较小的随机正整数，保证在 <code>hotkey</code> 过期时，所有 <code>bakHotKey</code> 不会同时过期而造成缓存雪崩。</p>
</blockquote>
<p><strong>大key</strong></p>
<blockquote>
<p>如果String类型值大于10KB，Hash，Set，Zset，List类型的元素的个数大于5000个都可以称之为大key。</p>
</blockquote>
<p>大key的危害：</p>
<blockquote>
<p>客户端超时等待</p>
<p>阻塞工作线程</p>
<p>内存分布不均匀：</p>
<ul>
<li>集群模型在slot分片均匀的情况下，会出现数据和查询倾斜情况，部分有大key的Redis节点占用内存多。</li>
</ul>
</blockquote>
<p>如何处理大key：</p>
<blockquote>
<p>对大key进行拆分:</p>
<ul>
<li>将一个Big Key拆分为多个key-value这样的小Key，并确保每个key的成员数量或者大小在合理范围内。</li>
<li>通过get不同的key或者使用mget批量获取。</li>
</ul>
</blockquote>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p><strong>分布式锁</strong></p>
<blockquote>
<p>使用分布式锁的目的，是保证同一时间只有一个客户端可以对共享资源进行操作。</p>
</blockquote>
<p>使用SETNX实现：</p>
<blockquote>
<p><code>SETNX key value</code>，只在键key不存在的情况下，将键key的值设置为value，若键key存在，则SETNX不做任何动作。</p>
</blockquote>
<pre><code class="java">boolean result = jedis.setnx(&quot;lock-key&quot;,true)== 1L;
if  (result) &#123;
    try &#123;
        // do something
    &#125; finally &#123;
        jedis.del(&quot;lock-key&quot;);
    &#125;
 &#125;
</code></pre>
<blockquote>
<p>某个线程在获取锁之后由于某些异常因素（比如宕机）而不能正常的执行解锁操作，这个锁就永远释放不掉了。</p>
<ul>
<li>可以为这个锁加上一个超时时间。</li>
</ul>
<p><code>SET key value EX seconds</code> 的效果等同于执行 <code>SETEX key seconds value</code></p>
<p><code>SET key value PX milliseconds</code> 的效果等同于执行 <code>PSETEX key milliseconds value</code></p>
</blockquote>
<pre><code class="java">String result = jedis.set(&quot;lock-key&quot;,true, 5);
if (&quot;OK&quot;.equals(result)) &#123;
    try &#123;
        // do something
    &#125; finally &#123;
        jedis.del(&quot;lock-key&quot;);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>某线程A获取了锁设置了过期时间为10s，在执行业务逻辑时耗费了15s，此时线程A获取的锁被Redis的过期机制自动释放了。</p>
<p>在线程A获取锁并经过10s之后，改锁可能已经被其它线程获取到了。</p>
<ul>
<li>当线程A执行完业务逻辑准备解锁（DEL key）的时候，有可能删除掉的是其它线程已经获取到的锁。</li>
</ul>
<p>所以在解锁时判断锁是否是自己的，可以在设置key的时候将value设置为一个唯一值uniqueValue。</p>
<p>当解锁时，也就是删除key的时候先判断一下key对应的value是否等于先前设置的值，如果相等才能删除key。</p>
</blockquote>
<pre><code class="java">String velue= String.valueOf(System.currentTimeMillis())
String result = jedis.set(&quot;lock-key&quot;,velue, 5);
if (&quot;OK&quot;.equals(result)) &#123;
    try &#123;
        // do something
    &#125; finally &#123;
          //非原子操作
          if(jedis.get(&quot;lock-key&quot;)==value)&#123;
                jedis.del(&quot;lock-key&quot;);
        &#125;    
    &#125;
&#125;
</code></pre>
<blockquote>
<p><code>GET</code>和<code>DEL</code>是两个分开的操作，在GET执行之后且在DEL执行之前的间隙是可能会发生异常的。</p>
<p>只要保证解锁的代码是原子性的就能解决问题了。</p>
<p>由于Lua脚本的原子性，在Redis执行该脚本的过程中，其他客户端的命令都需要等待该Lua脚本执行完才能执行。</p>
</blockquote>
<pre><code class="lua">if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then
    return redis.call(&quot;del&quot;,KEYS[1])
else
    return 0
end
</code></pre>
<p>确保过期时间大于业务执行时间：</p>
<blockquote>
<p>为了防止多个线程同时执行业务代码，需要确保过期时间大于业务执行时间。</p>
<p>增加一个boolean类型的属性isOpenExpirationRenewal，用来标识是否开启定时刷新过期时间。</p>
<p>增加一个scheduleExpirationRenewal方法用于开启刷新过期时间的线程。</p>
<p>加锁代码在获取锁成功后将isOpenExpirationRenewal置为true，并且调用scheduleExpirationRenewal方法，开启刷新过期时间的线程。</p>
<p>解锁代码增加一行代码，将isOpenExpirationRenewal属性置为false，停止刷新过期时间的线程轮询。</p>
</blockquote>
<p>Redisson实现：</p>
<blockquote>
<p>获取锁成功就会开启一个定时任务，定时任务会定期检查去续期。</p>
<p>该定时调度每次调用的时间差是<code>internalLockLeaseTime/3</code>，也就10秒。</p>
<p>默认情况下，加锁的时间是30秒，如果加锁的业务没有执行完，那么到 30-10 &#x3D; 20秒的时候，就会进行一次续期，把锁重置成30秒。</p>
</blockquote>
<p><strong>RedLock</strong></p>
<blockquote>
<p>在集群中，主节点挂掉时，从节点会取而代之，客户端上却并没有明显感知。</p>
<p>原先第一个客户端在主节点中申请成功了一把锁，但是这把锁还没有来得及同步到从节点，主节点突然挂掉了。</p>
<p>然后从节点变成了主节点，这个新的节点内部没有这个锁，所以当另一个客户端过来请求加锁时，立即就批准了。</p>
<p>这样就会导致系统中同样一把锁被两个客户端同时持有，不安全性由此产生。</p>
</blockquote>
<p>Redlock算法就是为了解决这个问题:</p>
<blockquote>
<p>加锁时，它会向过半节点发送 set指令，只要过半节点 set 成功，那就认为加锁成功。</p>
<p>释放锁时，需要向所有节点发送 del 指令。</p>
<p>不过 Redlock 算法还需要考虑出错重试、时钟漂移等很多细节问题，同时因为 Redlock 需要向多个节点进行读写，意味着相比单实例 Redis 性能会下降一些。</p>
</blockquote>
<p>假设当前集群有 5 个节点，运行 Redlock 算法的客户端依次执行下面各个步骤，来完成获取锁的操作:</p>
<blockquote>
<p>客户端记录当前系统时间，以毫秒为单位。</p>
<p>依次尝试从 5 个 Redis 实例中，使用相同的 key 获取锁。</p>
<p>当向 Redis 请求获取锁时，客户端应该设置一个网络连接和响应超时时间，超时时间应该小于锁的失效时间，避免因为网络故障出现的问题。</p>
<p>客户端使用当前时间减去开始获取锁时间就得到了获取锁使用的时间。</p>
<p>当且仅当从半数以上的 Redis 节点获取到锁，并且当使用的时间小于锁失效时间时，锁才算获取成功。</p>
<p>如果获取到了锁，key 的真正有效时间等于有效时间减去获取锁所使用的时间，减少超时的几率。</p>
<p>如果获取锁失败，客户端应该在所有的 Redis 实例上进行解锁，即使是上一步操作请求失败的节点，防止因为服务端响应消息丢失，但是实际数据添加成功导致的不一致。</p>
<p>也就是说，假设锁30秒过期，三个节点加锁花了31秒，自然是加锁失败了。</p>
<p>在 Redis 官方推荐的 Java 客户端 Redisson 中，内置了对 RedLock 的实现。</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki">https://github.com/redisson/redisson/wiki</a></p>
</li>
</ul>
</blockquote>
<p>RedLock问题：</p>
<blockquote>
<p>RedLock 只是保证了锁的高可用性，并没有保证锁的正确性。</p>
<p>RedLock 是一个<strong>严重依赖系统时钟</strong>的分布式系统。</p>
</blockquote>
<p><strong>延时队列</strong></p>
<blockquote>
<p>使用 zset这个命令，用设置好的时间戳作为score进行排序，使用 <code>zadd score1 value1 ....</code>命令就可以一直往内存中生产消息。</p>
<p>再利用 zrangebysocre 查询符合条件的所有待处理的任务，通过循环执行队列任务即可。</p>
<ul>
<li>通过 <code>zrangebyscore key min max withscores limit 0 1</code> 查询最早的一条任务，来进行消费。</li>
</ul>
</blockquote>
<pre><code class="java">private Jedis jedis;

public void redisDelayQueueTest() &#123;
    String key = &quot;delay_queue&quot;;

    // 实际开发建议使用业务 ID 和随机生成的唯一 ID 作为 value, 随机生成的唯一 ID 可以保证消息的唯一性, 业务 ID 可以避免 value 携带的信息过多
    String orderId1 = UUID.randomUUID().toString();
    jedis.zadd(queueKey, System.currentTimeMillis() + 5000, orderId1);

    String orderId12 = UUID.randomUUID().toString();
    jedis.zadd(queueKey, System.currentTimeMillis() + 5000, orderId2);

    new Thread() &#123;
        @Override
        public void run() &#123;
            while (true) &#123;
                Set&lt;String&gt; resultList;
                // 只获取第一条数据, 只获取不会移除数据
                resultList = jedis.zrangebyscore(key, System.currentTimeMillis(), 0, 1);
                if (resultList.size() == 0) &#123;
                    try &#123;
                        Thread.sleep(1000);
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                        break;
                    &#125;
                &#125; else &#123;
                    // 移除数据获取到的数据
                    if (jedis.zrem(key, resultList.get(0)) &gt; 0) &#123;
                        String orderId = resultList.get(0);
                        log.info(&quot;orderId = &#123;&#125;&quot;, resultList.get(0));
                        this.handleMsg(orderId);
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;.start();
&#125;

public void handleMsg(T msg) &#123;
    System.out.println(msg);
&#125;
</code></pre>
<p>进一步优化:</p>
<blockquote>
<p>同一个任务可能会被多个进程取到之后再使用 zrem 进行争抢，那些没抢到 的进程都是白取了一次任务。</p>
<p>可以考虑使用 <code>lua scripting</code> 来优化一下这个逻辑，将 <code>zrangebyscore</code> 和 <code>zrem</code> 一同挪到服务器端进行原子化操作，这样多个进程之间争抢任务时就不会出现这种浪费了。</p>
</blockquote>
<pre><code class="lua">String luaScript = &quot;local resultArray = redis.call(&#39;zrangebyscore&#39;, KEYS[1], 0, ARGV[1], &#39;limit&#39; , 0, 1)\n&quot; +
        &quot;if #resultArray &gt; 0 then\n&quot; +
        &quot;    if redis.call(&#39;zrem&#39;, KEYS[1], resultArray[1]) &gt; 0 then\n&quot; +
        &quot;        return resultArray[1]\n&quot; +
        &quot;    else\n&quot; +
        &quot;        return &#39;&#39;\n&quot; +
        &quot;    end\n&quot; +
        &quot;else\n&quot; +
        &quot;    return &#39;&#39;\n&quot; +
        &quot;end&quot;;
jedis.eval(luaScript, ScriptOutputType.VALUE, new String[]&#123;key&#125;, String.valueOf(System.currentTimeMillis()));
</code></pre>
<p><strong>统计一个亿的Keys</strong></p>
<p>HyperLogLog：</p>
<blockquote>
<p>Redis提供了一个扩展类型HyperLogLog用于基数统计，计算<code>2^64</code>个元素大概只需要12KB的内存空间。</p>
<p>但是<code>HyperLogLog</code>是存在误差的，大概是在<code>0.81%</code>，如果需要精准的统计，还是需要使用<code>Set</code>。</p>
</blockquote>

	</div>
</div>


    <div class="post-guide">
        <div class="item left">
            
              <a href="/2023/10/21/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/DDD/">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  DDD
              </a>
            
        </div>
        <div class="item right">
            
              <a href="/2023/10/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/ZooKeeper/">
                ZooKeeper
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>




<script>

    //document.oncontextmenu=new Function("event.returnValue=false");
	//document.onselectstart=new Function("event.returnValue=false");

	

	$(function () {
		const btw = new BTWPlugin();
	    btw.init({
	        id: 'container',
	        blogId: '22377-1657723090751-870',
	        name: '月伴飞鱼',
	        qrcode: '/个人公众号.jpg',
	        keyword: '验证码',
	    });

	    var contents = document.getElementsByClassName("content999");
	    //监听文章内容的copy事件
	    contents[0].addEventListener('copy',function(e){
	        setClipboardText(e);
	    });

	    function setClipboardText(event){
	        // clipboardData 对象是为通过编辑菜单、快捷菜单和快捷键执行的编辑操作所保留的，也就是你复制或者剪切内容
	        let clipboardData = event.clipboardData || window.clipboardData;

	        // 如果未复制或者未剪切，则return出去
	        if (!clipboardData) { return; }

	        event.preventDefault();

	        // Selection 对象，表示用户选择的文本范围或光标的当前位置。
	        // 声明一个变量接收 -- 用户输入的剪切或者复制的文本转化为字符串
	        let text = window.getSelection().toString();
	    
	        if (text) {
	            // 如果文本存在则先取消文本默认事件
	            event.preventDefault();
	            // 通过调用常clipboardData对象的 setData(format, data) 方法；来设置相关文本
	            // format: 一个DOMString 表示要添加到 drag object的拖动数据的类型。
	            // data: 一个 DOMString表示要添加到 drag object的数据。
	            var copyright = '\n\n'
	            + '\n著作权归作者所有。'
	            + '\n商业转载请联系作者获得授权，非商业转载请注明出处。'
	            + '\n作者: 月伴飞鱼'
	            + '\n原文地址: https://xiaoflyfish.cn/2023/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/'
	    
	            clipboardData.setData('text/plain', text + copyright);
	    
	        }
	    };
	});

	
</script>

<script>
    const btw = new BTWPlugin();
    btw.init({
        id: 'container',
        blogId: '22377-1657723090751-870',
        name: '月伴飞鱼',
        qrcode: '/个人公众号.jpg',
        keyword: '验证码',
    });
</script>
	</div>
	<div id="footer">
	<p>
	©2019-<span id="footerYear"></span> 
	<a href="/">月伴飞鱼</a> 
	
	
		|
		<span id="busuanzi_container_site_pv">
			PV 180986
		</span>
		|
		<span id="busuanzi_container_site_uv"> 
			UV 10079
		</span>
	
	<br>
	微信搜索 <a href="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/个人公众号.jpg" target="_blank">月伴飞鱼</a> 关注我
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>
	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>